[
    {
        "type": "type_C_altair",
        "db_id": "activity_1",
        "chart_category": "Advanced Calculations",
        "chart_type": "calculate_residuals",
        "NLQ": "Can you create a chart showing the age difference between students in each activity compared to the overall average? I'd like to see the activities listed on the x-axis and the age difference in years on the y-axis. Please use colors to highlight whether an activity has older students (blue) or younger students (red) compared to the average. Also, add a title that explains what the visualization is showing.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/activity_1.sqlite')\n\nquery = '''\nSELECT \n    A.activity_name,\n    AVG(S.Age) AS Avg_Age\nFROM \n    Activity AS A\nJOIN \n    Participates_in AS P ON A.actid = P.actid\nJOIN \n    Student AS S ON P.stuid = S.StuID\nGROUP BY \n    A.actid, A.activity_name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\noverall_avg_age = df['Avg_Age'].mean()\n\nchart = (\n    alt.Chart(df)\n    .mark_point()\n    .transform_calculate(\n        Age_Delta=\"datum.Avg_Age - \" + str(overall_avg_age)\n    )\n    .encode(\n        x=alt.X(\"activity_name:N\").title(\"Activity Name\"),\n        y=alt.Y(\"Age_Delta:Q\").title(\"Age Delta (Years)\"),\n        color=alt.Color(\"Age_Delta:Q\")\n        .title(\"Age Delta\")\n        .scale(domainMid=0, scheme=\"redblue\"),\n    )\n    .properties(title=\"Difference in Average Age by Activity\")\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___calculate_residuals.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "activity_1",
        "chart_category": "Advanced Calculations",
        "chart_type": "calculate_residuals",
        "NLQ": "Can you change my chart to show the difference between the average age of students in each activity compared to the overall average age? Instead of showing release dates and rating deltas, I want to see activity names on the x-axis and the age difference on the y-axis. Please use a red-blue color scheme where red shows negative differences and blue shows positive ones. Also, add a clear title like \"Difference in Average Age by Activity\" and make sure the axis labels are descriptive.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/activity_1.sqlite')\n\nquery = '''\nSELECT \n    A.activity_name,\n    AVG(S.Age) AS Avg_Age\nFROM \n    Activity AS A\nJOIN \n    Participates_in AS P ON A.actid = P.actid\nJOIN \n    Student AS S ON P.stuid = S.StuID\nGROUP BY \n    A.actid, A.activity_name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\noverall_avg_age = df['Avg_Age'].mean()\n\nchart = (\n    alt.Chart(df)\n    .mark_point()\n    .transform_calculate(\n        Age_Delta=\"datum.Avg_Age - \" + str(overall_avg_age)\n    )\n    .encode(\n        x=alt.X(\"activity_name:N\").title(\"Activity Name\"),\n        y=alt.Y(\"Age_Delta:Q\").title(\"Age Delta (Years)\"),\n        color=alt.Color(\"Age_Delta:Q\")\n        .title(\"Age Delta\")\n        .scale(domainMid=0, scheme=\"redblue\"),\n    )\n    .properties(title=\"Difference in Average Age by Activity\")\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___calculate_residuals.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "activity_1",
        "chart_category": "Interactive Charts",
        "chart_type": "simple_interactive_colored_scatter_plot",
        "NLQ": "I want to create a chart like the one showing horsepower and miles per gallon, but instead can you show student ages and how many activities they participate in? I'd like the chart to use colors to differentiate between student majors instead of car origins. Also, can you make the chart interactive so I can explore the data better? Instead of generating random data, please pull the information from our student activities database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/activity_1.sqlite')\n\nquery = '''\nSELECT \n    S.Age, \n    COUNT(P.actid) AS ActivityCount, \n    S.Major\nFROM \n    Student AS S\nLEFT JOIN \n    Participates_in AS P ON S.StuID = P.stuid\nGROUP BY \n    S.StuID, S.Age, S.Major\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    x='Age:Q',\n    y='ActivityCount:Q',\n    color='Major:N'\n).interactive()\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___simple_interactive_colored_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "activity_1",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "simple_scatter_plot_with_errorbars",
        "NLQ": "I need a chart showing the average age of students participating in different activities from our database. For each activity, display a point for the average age and error bars showing the age range from minimum to maximum. Make the points larger, filled in black, and easy to see. Use the activity names on the x-axis and label the y-axis as \"Average Age of Participants\". Can you pull this data directly from our activity database using SQL?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/activity_1.sqlite')\n\nquery = '''\nSELECT\n    A.activity_name,\n    AVG(S.Age) AS average_age,\n    MIN(S.Age) AS min_age,\n    MAX(S.Age) AS max_age\nFROM\n    Participates_in AS P\nJOIN\n    Student AS S ON P.stuid = S.StuID\nJOIN\n    Activity AS A ON P.actid = A.actid\nGROUP BY\n    A.activity_name;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).transform_calculate(\n    ymin=\"datum.min_age\",\n    ymax=\"datum.max_age\"\n)\n\npoints = base.mark_point(\n    filled=True,\n    size=50,\n    color='black'\n).encode(\n    alt.X('activity_name', sort=None),\n    alt.Y('average_age', title='Average Age of Participants')\n)\n\nerrorbars = base.mark_errorbar().encode(\n    x=\"activity_name\",\n    y=\"ymin:Q\",\n    y2=\"ymax:Q\"\n)\n\nchart = points + errorbars\n\nchart",
        "reference_path": "./vis_bench/code/altair/Uncertainties And Trends___simple_scatter_plot_with_errorbars.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "activity_1",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "simple_scatter_plot_with_errorbars",
        "NLQ": "Instead of using my sample code with random data, could you create a chart that shows the average age of students in each activity, along with the range of their ages? I need this data pulled from my activity database. For each activity, show a black point for the average age and error bars showing the minimum and maximum ages. Make sure the activities are listed along the x-axis and label the y-axis as \"Average Age of Participants\".",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/activity_1.sqlite')\nquery = '''\nSELECT\n    A.activity_name,\n    AVG(S.Age) AS average_age,\n    MIN(S.Age) AS min_age,\n    MAX(S.Age) AS max_age\nFROM\n    Participates_in AS P\nJOIN\n    Student AS S ON P.stuid = S.StuID\nJOIN\n    Activity AS A ON P.actid = A.actid\nGROUP BY\n    A.activity_name;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).transform_calculate(\n    ymin=\"datum.min_age\",\n    ymax=\"datum.max_age\"\n)\n\npoints = base.mark_point(\n    filled=True,\n    size=50,\n    color='black'\n).encode(\n    alt.X('activity_name', sort=None),\n    alt.Y('average_age', title='Average Age of Participants')\n)\n\nerrorbars = base.mark_errorbar().encode(\n    x=\"activity_name\",\n    y=\"ymin:Q\",\n    y2=\"ymax:Q\"\n)\n\nchart = points + errorbars\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Uncertainties And Trends___simple_scatter_plot_with_errorbars.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "aircraft",
        "chart_category": "Advanced Calculations",
        "chart_type": "calculate_residuals",
        "NLQ": "I want to create a scatter plot showing the relationship between total disk area and weight residuals for different aircraft. Instead of just showing release dates and rating deltas like in the original chart, I'd like to use actual aircraft data from our database. Calculate the weight residual by subtracting the average weight from each aircraft's max gross weight. Color-code the points based on their weight residual values, with different colors for positive and negative values. Also, add tooltips that show the aircraft name, max gross weight, and total disk area when hovering over each point. Please add a title \"Aircraft Weight Residuals vs. Total Disk Area\" and proper axis labels.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/aircraft.sqlite')\n\nquery = '''\nSELECT \n    Aircraft, \n    CAST(REPLACE(Max_Gross_Weight, ',', '') AS REAL) AS Max_Gross_Weight,\n    CAST(REPLACE(Total_disk_area, ' ft²', '') AS REAL) AS Total_Disk_Area\nFROM \n    aircraft\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = (\n    alt.Chart(df)\n    .mark_point()\n    .transform_joinaggregate(Average_Weight=\"mean(Max_Gross_Weight)\")\n    .transform_calculate(Weight_Residual=\"datum.Max_Gross_Weight - datum.Average_Weight\")\n    .encode(\n        x=alt.X(\"Total_Disk_Area:Q\").title(\"Total Disk Area (sq ft)\"),\n        y=alt.Y(\"Weight_Residual:Q\").title(\"Weight Residual (lbs)\"),\n        color=alt.Color(\"Weight_Residual:Q\").title(\"Weight Residual\").scale(domainMid=0),\n        tooltip=[\"Aircraft:N\", \"Max_Gross_Weight:Q\", \"Total_Disk_Area:Q\"]\n    )\n    .properties(title=\"Aircraft Weight Residuals vs. Total Disk Area\")\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___calculate_residuals.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "aircraft",
        "chart_category": "Advanced Calculations",
        "chart_type": "calculate_residuals",
        "NLQ": "I want to create a scatter plot showing aircraft data instead of the movie ratings. Can you plot the total disk area on the x-axis against the weight residual (difference from average weight) on the y-axis? Use a color scale that shows positive and negative residuals differently, with zero in the middle. Also, add tooltips that show the aircraft name, maximum gross weight, and total disk area when hovering over points. Please title it \"Aircraft Weight Residuals vs. Total Disk Area\" and make sure the axis labels are clear.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/aircraft.sqlite')\n\nquery = '''\nSELECT \n    Aircraft, \n    CAST(REPLACE(Max_Gross_Weight, ',', '') AS REAL) AS Max_Gross_Weight,\n    CAST(REPLACE(Total_disk_area, ' ft²', '') AS REAL) AS Total_Disk_Area\nFROM \n    aircraft\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = (\n    alt.Chart(df)\n    .mark_point()\n    .transform_joinaggregate(Average_Weight=\"mean(Max_Gross_Weight)\")\n    .transform_calculate(Weight_Residual=\"datum.Max_Gross_Weight - datum.Average_Weight\")\n    .encode(\n        x=alt.X(\"Total_Disk_Area:Q\").title(\"Total Disk Area (sq ft)\"),\n        y=alt.Y(\"Weight_Residual:Q\").title(\"Weight Residual (lbs)\"),\n        color=alt.Color(\"Weight_Residual:Q\").title(\"Weight Residual\").scale(domainMid=0),\n        tooltip=[\"Aircraft:N\", \"Max_Gross_Weight:Q\", \"Total_Disk_Area:Q\"]\n    )\n    .properties(title=\"Aircraft Weight Residuals vs. Total Disk Area\")\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___calculate_residuals.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "aircraft",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart",
        "NLQ": "Instead of showing crop yields for different varieties across multiple sites, can you create a bar chart that shows passenger numbers at different airports? I need to see both international and domestic passenger counts for each airport, with the passenger types shown in different colors. The data should come from my airport database rather than the random data in the example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/aircraft.sqlite')\n\nquery = '''\nSELECT \n    Airport_Name,\n    International_Passengers AS Passengers,\n    'International' AS Passenger_Type\nFROM \n    airport\nUNION ALL\nSELECT \n    Airport_Name,\n    Domestic_Passengers AS Passengers,\n    'Domestic' AS Passenger_Type\nFROM \n    airport\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Airport_Name:N',\n    y='sum(Passengers):Q',\n    color='Passenger_Type:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "aircraft",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart",
        "NLQ": "I have this stacked bar chart showing yields for different plant varieties across multiple sites, but I'd like to change it to show passenger numbers at different airports instead. Can you create a stacked bar chart that shows international and domestic passenger counts for each airport? I need to pull this data from my aircraft database rather than using random numbers. Also, I'd prefer to use Altair instead of Matplotlib for creating the visualization, with different colors to distinguish between international and domestic passengers.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/aircraft.sqlite')\n\nquery = '''\nSELECT \n    Airport_Name,\n    International_Passengers AS Passengers,\n    'International' AS Passenger_Type\nFROM \n    airport\nUNION ALL\nSELECT \n    Airport_Name,\n    Domestic_Passengers AS Passengers,\n    'Domestic' AS Passenger_Type\nFROM \n    airport\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Airport_Name:N',\n    y='sum(Passengers):Q',\n    color='Passenger_Type:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "aircraft",
        "chart_category": "Interactive Charts",
        "chart_type": "slider_cutoff",
        "NLQ": "I want to create a bar chart showing airports and their passenger numbers from our aircraft database. Make the bars horizontal with airport names on the y-axis and passenger counts on the x-axis. Sort the airports by passenger numbers so the busiest ones are at the top. Add a slider that lets me set a passenger count threshold - airports below the threshold should be blue and those above should be red. The slider should start at the median passenger count value. This will help me easily identify the busiest airports at a glance.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/aircraft.sqlite')\n\nquery = '''\nSELECT Airport_Name, Total_Passengers\nFROM airport\nORDER BY Total_Passengers DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nslider = alt.binding_range(min=0, max=int(df['Total_Passengers'].max()), step=100000)\ncutoff = alt.param(bind=slider, value=int(df['Total_Passengers'].median()))\npredicate = alt.datum.Total_Passengers < cutoff\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Total_Passengers:Q',\n    y=alt.Y('Airport_Name:N', sort='-x'),\n    color=alt.when(predicate).then(alt.value(\"blue\")).otherwise(alt.value(\"red\")),\n).add_params(\n    cutoff\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___slider_cutoff.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "aircraft",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "simple_scatter_plot_with_errorbars",
        "NLQ": "Can you create a scatter plot showing the relationship between total disk area and maximum gross weight of aircraft from our database? I'd like to see large black dots for each data point with error bars showing about 10% margin of error for the weight. Please label the x-axis as \"Total Disk Area (sq ft)\" and the y-axis as \"Max Gross Weight (lb)\", and don't start the y-axis at zero since that would compress the data too much.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/aircraft.sqlite')\n\nquery = '''\nSELECT \n    CAST(REPLACE(Max_Gross_Weight, ',', '') AS REAL) AS Max_Gross_Weight,\n    CAST(REPLACE(Total_disk_area, ',', '') AS REAL) AS Total_Disk_Area\nFROM \n    aircraft\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf['yerr'] = df['Max_Gross_Weight'] * 0.1\n\nbase = alt.Chart(df).transform_calculate(\n    ymin=\"datum.Max_Gross_Weight - datum.yerr\",\n    ymax=\"datum.Max_Gross_Weight + datum.yerr\"\n)\n\npoints = base.mark_point(\n    filled=True,\n    size=50,\n    color='black'\n).encode(\n    x=alt.X('Total_Disk_Area:Q', title='Total Disk Area (sq ft)'),\n    y=alt.Y('Max_Gross_Weight:Q', title='Max Gross Weight (lb)', scale=alt.Scale(zero=False))\n)\n\nerrorbars = base.mark_errorbar().encode(\n    x=\"Total_Disk_Area:Q\",\n    y=\"ymin:Q\",\n    y2=\"ymax:Q\"\n)\n\nchart = points + errorbars\n\nchart",
        "reference_path": "./vis_bench/code/altair/Uncertainties And Trends___simple_scatter_plot_with_errorbars.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "aircraft",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "simple_scatter_plot_with_errorbars",
        "NLQ": "Can you create a scatter plot showing the relationship between total disk area and maximum gross weight of aircraft from our database? I'd like to see black dots for each aircraft with error bars showing about 10% margin of error for the weight. Please label the x-axis as \"Total Disk Area (sq ft)\" and the y-axis as \"Max Gross Weight (lb)\". Don't start the y-axis at zero since we need to see the details better.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/aircraft.sqlite')\n\nquery = '''\nSELECT \n    CAST(REPLACE(Max_Gross_Weight, ',', '') AS REAL) AS Max_Gross_Weight,\n    CAST(REPLACE(Total_disk_area, ',', '') AS REAL) AS Total_Disk_Area\nFROM \n    aircraft\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf['yerr'] = df['Max_Gross_Weight'] * 0.1\n\nbase = alt.Chart(df).transform_calculate(\n    ymin=\"datum.Max_Gross_Weight - datum.yerr\",\n    ymax=\"datum.Max_Gross_Weight + datum.yerr\"\n)\n\npoints = base.mark_point(\n    filled=True,\n    size=50,\n    color='black'\n).encode(\n    x=alt.X('Total_Disk_Area:Q', title='Total Disk Area (sq ft)'),\n    y=alt.Y('Max_Gross_Weight:Q', title='Max Gross Weight (lb)', scale=alt.Scale(zero=False))\n)\n\nerrorbars = base.mark_errorbar().encode(\n    x=\"Total_Disk_Area:Q\",\n    y=\"ymin:Q\",\n    y2=\"ymax:Q\"\n)\n\nchart = points + errorbars\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Uncertainties And Trends___simple_scatter_plot_with_errorbars.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "baseball_1",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "line_chart_with_confidence_interval_band",
        "NLQ": "Can you create a chart showing the average number of home runs per team each year from our baseball database? I'd like to see a line showing the yearly average with a shaded area around it to show the range of variability between teams. Please add a clear title like \"Average Team Home Runs per Year\" and label the axes properly so it's easy to understand what we're looking at. I want something similar to that miles per gallon chart I showed you, with the error band around the trend line.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/baseball_1.sqlite')\n\nquery = '''\nSELECT \n    year, \n    team_id, \n    SUM(hr) AS team_hr\nFROM batting\nWHERE hr IS NOT NULL\nGROUP BY year, team_id;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nline = alt.Chart(df).mark_line().encode(\n    x=alt.X('year:O', title='Year'),\n    y=alt.Y('mean(team_hr):Q', title='Average Home Runs per Team')\n)\n\nband = alt.Chart(df).mark_errorband(extent='ci').encode(\n    x='year:O',\n    y=alt.Y('team_hr:Q')\n)\n\nchart = (band + line).properties(\n    title='Average Team Home Runs per Year with 95% Confidence Interval'\n)\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Uncertainties And Trends___line_chart_with_confidence_interval_band.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "baseball_1",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "line_chart_with_confidence_interval_band",
        "NLQ": "Can you create a chart showing the average number of home runs per team each year from our baseball database? I'd like to see a line showing the yearly averages with a shaded area around it to show the confidence interval or range of variability between teams. Please title it \"Average Team Home Runs per Year with 95% Confidence Interval\" and make sure the axes are clearly labeled.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/baseball_1.sqlite')\n\nquery = '''\nSELECT \n    year, \n    team_id, \n    SUM(hr) AS team_hr\nFROM batting\nWHERE hr IS NOT NULL\nGROUP BY year, team_id;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nline = alt.Chart(df).mark_line().encode(\n    x=alt.X('year:O', title='Year'),\n    y=alt.Y('mean(team_hr):Q', title='Average Home Runs per Team')\n)\n\nband = alt.Chart(df).mark_errorband(extent='ci').encode(\n    x='year:O',\n    y=alt.Y('team_hr:Q')\n)\n\nchart = (band + line).properties(\n    title='Average Team Home Runs per Year with 95% Confidence Interval'\n)\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Uncertainties And Trends___line_chart_with_confidence_interval_band.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "browser_web",
        "chart_category": "Advanced Calculations",
        "chart_type": "gantt_chart",
        "NLQ": "Can you change my simple bar chart to show data from our browser database instead? I'd like to display the accelerator names from the Web_client_accelerator table and create a timeline view where each bar starts at the accelerator's ID number and extends for 2 units. Keep the same basic bar chart style, but use the database information instead of the sample data I had before.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/browser_web.sqlite')\nquery = '''\nSELECT id, name\nFROM Web_client_accelerator\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf['start'] = df['id']\ndf['end'] = df['id'] + 2\ndf = df.rename(columns={'name': 'task'})\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='start:Q',\n    x2='end:Q',\n    y='task:N'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___gantt_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "browser_web",
        "chart_category": "Advanced Calculations",
        "chart_type": "gantt_chart",
        "NLQ": "Can you change my chart to use data from the Web_client_accelerator table in my database instead of the hardcoded values? I'd like to show each accelerator name as a task with bars representing their timeline. Use the accelerator ID as the starting point and make each bar extend by 2 units. Also, can you switch from matplotlib to Altair for creating the chart?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/browser_web.sqlite')\nquery = '''\nSELECT id, name\nFROM Web_client_accelerator\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\ndf['start'] = df['id']\ndf['end'] = df['id'] + 2\ndf = df.rename(columns={'name': 'task'})\nchart = alt.Chart(df).mark_bar().encode(\n    x='start:Q',\n    x2='end:Q',\n    y='task:N'\n)\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___gantt_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "candidate_poll",
        "chart_category": "Circular Plots",
        "chart_type": "pacman_chart",
        "NLQ": "Can you make my arc chart look like Pac-Man by coloring it gold and adjusting the mouth angle? I'd also like to connect it to my candidate poll database to eventually use the support rate data, even though for now we're still using static values for the Pac-Man shape.",
        "code": "import numpy as np\nimport altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/candidate_poll.sqlite')\nquery = '''\nSELECT Support_rate\nFROM candidate\nLIMIT 1\n'''\ndf = pd.read_sql_query(query, conn)\nprint(\"Fetched Support Rate from Database:\", df['Support_rate'].iloc[0])\nconn.close()\n\nchart = alt.Chart().mark_arc(color=\"gold\").encode(\n    theta=alt.ThetaDatum((5 / 8) * np.pi).scale(None),\n    theta2=alt.Theta2Datum((19 / 8) * np.pi),\n    radius=alt.RadiusDatum(100).scale(None),\n)\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Circular Plots___pacman_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "company_employee",
        "chart_category": "Circular Plots",
        "chart_type": "radial_chart",
        "NLQ": "Can you create a pie chart showing the distribution of employees by their graduation college and industry? I need to pull this data from our company database - specifically looking at how many employees from each college work in different industries. Please add a title \"Employee Distribution by Graduation College and Industry\" to the chart, make sure the numbers are displayed on each segment, and add tooltips so when I hover over a segment I can see the college name, industry, and exact employee count. Also, can you add white borders between the segments to make them easier to distinguish?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_employee.sqlite')\n\nquery = '''\nSELECT \n    p.Graduation_College AS College,\n    c.Industry AS Industry,\n    COUNT(*) AS Employee_Count\nFROM \n    employment AS e\nJOIN \n    people AS p ON e.People_ID = p.People_ID\nJOIN \n    company AS c ON e.Company_ID = c.Company_ID\nGROUP BY \n    p.Graduation_College, c.Industry\nORDER BY \n    p.Graduation_College, c.Industry;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"Employee_Count:Q\").stack(True),\n    alt.Radius(\"Employee_Count\").scale(type=\"sqrt\", zero=True, rangeMin=20),\n    color=\"Industry:N\",\n    tooltip=[\"College:N\", \"Industry:N\", \"Employee_Count:Q\"]\n)\n\nc1 = base.mark_arc(innerRadius=20, stroke=\"#fff\")\nc2 = base.mark_text(radiusOffset=10).encode(text=\"Employee_Count:Q\")\n\nchart = c1 + c2\nchart.properties(title=\"Employee Distribution by Graduation College and Industry\")",
        "reference_path": "./vis_bench/code/altair/Circular Plots___radial_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "company_employee",
        "chart_category": "Circular Plots",
        "chart_type": "radial_chart",
        "NLQ": "Can you create a radial chart showing the distribution of employees by their graduation college and industry? I'd like a colorful pie chart where each industry has its own color, with the slice size representing employee count. Make the chart interactive with tooltips showing college name, industry, and exact employee count when hovering. Please display the employee count numbers directly on each slice and title the chart \"Employee Distribution by Graduation College and Industry\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_employee.sqlite')\n\nquery = '''\nSELECT \n    p.Graduation_College AS College,\n    c.Industry AS Industry,\n    COUNT(*) AS Employee_Count\nFROM \n    employment AS e\nJOIN \n    people AS p ON e.People_ID = p.People_ID\nJOIN \n    company AS c ON e.Company_ID = c.Company_ID\nGROUP BY \n    p.Graduation_College, c.Industry\nORDER BY \n    p.Graduation_College, c.Industry;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"Employee_Count:Q\").stack(True),\n    alt.Radius(\"Employee_Count\").scale(type=\"sqrt\", zero=True, rangeMin=20),\n    color=\"Industry:N\",\n    tooltip=[\"College:N\", \"Industry:N\", \"Employee_Count:Q\"]\n)\n\nc1 = base.mark_arc(innerRadius=20, stroke=\"#fff\")\nc2 = base.mark_text(radiusOffset=10).encode(text=\"Employee_Count:Q\")\nchart = c1 + c2\nchart.properties(title=\"Employee Distribution by Graduation College and Industry\")",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___radial_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "concert_singer",
        "chart_category": "Advanced Calculations",
        "chart_type": "layered_chart_with_dual-axis",
        "NLQ": "Can you change this chart to show information about concert stadiums instead of weather data? I'd like to see stadium names on the x-axis, with their capacities shown as green bars and the average attendance as a blue line. Keep the same layout with two different scales, but make sure the axis titles clearly show what each measurement represents.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/concert_singer.sqlite')\nquery = '''\nSELECT Name, Capacity, Average\nFROM stadium;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.X('Name:N').title('Stadium Name')\n)\nbars = base.mark_bar(color='#57A44C').encode(\n    alt.Y('Capacity:Q').axis(title='Stadium Capacity', titleColor='#57A44C')\n)\nline = base.mark_line(color='#5276A7').encode(\n    alt.Y('Average:Q').axis(title='Average Attendance', titleColor='#5276A7')\n)\nchart = alt.layer(bars, line).resolve_scale(\n    y='independent'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___layered_chart_with_dual-axis.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "concert_singer",
        "chart_category": "Advanced Calculations",
        "chart_type": "layered_chart_with_dual-axis",
        "NLQ": "I like this weather chart showing temperature range and precipitation by month, but I'd like to switch to concert data instead. Can you create a similar dual-axis visualization that shows stadium names on the x-axis, with their capacities as bars and average attendance as a line? Keep the idea of showing two different metrics together, but use green for the capacity bars and blue for the attendance line. Also, make sure the axis titles clearly show what each color represents.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/concert_singer.sqlite')\nquery = '''\nSELECT Name, Capacity, Average\nFROM stadium;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.X('Name:N').title('Stadium Name')\n)\n\nbars = base.mark_bar(color='#57A44C').encode(\n    alt.Y('Capacity:Q').axis(title='Stadium Capacity', titleColor='#57A44C')\n)\n\nline = base.mark_line(color='#5276A7').encode(\n    alt.Y('Average:Q').axis(title='Average Attendance', titleColor='#5276A7')\n)\n\nchart = alt.layer(bars, line).resolve_scale(\n    y='independent'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___layered_chart_with_dual-axis.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "cre_Theme_park",
        "chart_category": "Advanced Calculations",
        "chart_type": "ranged_dot_plot",
        "NLQ": "Can you create a chart showing hotel price ranges by star rating? I want to see how prices vary across different hotel star ratings, and I'd like the points to be colored based on whether pets are allowed or not. Please connect the points with lines for each star rating category. Add a clear title like \"Hotel Price Ranges by Star Rating and Pet Policy\" and make sure the axes are properly labeled. I need to pull this data from our theme park database, specifically from the Hotels table joined with the star ratings reference table.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/cre_Theme_park.sqlite')\n\nquery = '''\nSELECT \n    h.star_rating_code,\n    r.star_rating_description,\n    h.price_range,\n    CASE \n        WHEN h.pets_allowed_yn = '1' THEN 'Pets Allowed'\n        ELSE 'No Pets Allowed'\n    END AS pets_policy\nFROM Hotels AS h\nJOIN Ref_Hotel_Star_Ratings AS r ON h.star_rating_code = r.star_rating_code\nWHERE h.price_range IS NOT NULL AND h.price_range != '' AND h.star_rating_code IS NOT NULL\nORDER BY h.star_rating_code\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = (\n    alt.Chart(df)\n    .encode(\n        x=alt.X(\"price_range:Q\", title=\"Price Range\"),\n        y=alt.Y(\"star_rating_description:N\", title=\"Star Rating\"),\n        color=alt.Color(\"pets_policy:N\", title=\"Pet Policy\"),\n    )\n    .mark_point(size=100, filled=True)\n)\n\nline = (\n    alt.Chart(df)\n    .encode(\n        x=\"price_range:Q\",\n        y=\"star_rating_description:N\",\n        detail=\"star_rating_description:N\",\n    )\n    .mark_line(color=\"#db646f\")\n)\n\nfinal_chart = (line + chart).properties(\n    title=\"Hotel Price Ranges by Star Rating and Pet Policy\"\n)\n\nfinal_chart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___ranged_dot_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "cre_Theme_park",
        "chart_category": "Advanced Calculations",
        "chart_type": "ranged_dot_plot",
        "NLQ": "Can you create a chart showing hotel price ranges by star rating? I want to see how prices vary across different hotel star ratings, and I'd like the points to be colored based on whether pets are allowed or not. Could you also add connecting lines between the points for each star rating category? Please title the chart \"Hotel Price Ranges by Star Rating and Pet Policy\" and make sure the x-axis shows price range and the y-axis shows the star rating description. I need this data from our theme park database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/cre_Theme_park.sqlite')\n\nquery = '''\nSELECT \n    h.star_rating_code,\n    r.star_rating_description,\n    h.price_range,\n    CASE \n        WHEN h.pets_allowed_yn = '1' THEN 'Pets Allowed'\n        ELSE 'No Pets Allowed'\n    END AS pets_policy\nFROM Hotels AS h\nJOIN Ref_Hotel_Star_Ratings AS r ON h.star_rating_code = r.star_rating_code\nWHERE h.price_range IS NOT NULL AND h.price_range != '' AND h.star_rating_code IS NOT NULL\nORDER BY h.star_rating_code\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = (\n    alt.Chart(df)\n    .encode(\n        x=alt.X(\"price_range:Q\", title=\"Price Range\"),\n        y=alt.Y(\"star_rating_description:N\", title=\"Star Rating\"),\n        color=alt.Color(\"pets_policy:N\", title=\"Pet Policy\"),\n    )\n    .mark_point(size=100, filled=True)\n)\n\nline = (\n    alt.Chart(df)\n    .encode(\n        x=\"price_range:Q\",\n        y=\"star_rating_description:N\",\n        detail=\"star_rating_description:N\",\n    )\n    .mark_line(color=\"#db646f\")\n)\n\nfinal_chart = (line + chart).properties(\n    title=\"Hotel Price Ranges by Star Rating and Pet Policy\"\n)\n\nfinal_chart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___ranged_dot_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "cre_Theme_park",
        "chart_category": "Distributions",
        "chart_type": "boxplot_with_minmax_whiskers",
        "NLQ": "Instead of using the random data in my example, could you create a boxplot using my theme park database? I need to see the distribution of Visit_IDs for each Tourist_ID. Use the Tourist_IDs for the x-axis and the Visit_IDs for the y-axis. Keep the same boxplot style with the lines extending to the min and max values, but I don't need to filter out any outliers.",
        "code": "import altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/cre_Theme_park.sqlite')\nquery = '''\nSELECT CAST(Tourist_ID AS TEXT) AS age, Visit_ID AS people FROM Visits\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_boxplot(extent='min-max').encode(\n    x='age:O',\n    y='people:Q'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___boxplot_with_minmax_whiskers.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "cre_Theme_park",
        "chart_category": "Distributions",
        "chart_type": "boxplot_with_minmax_whiskers",
        "NLQ": "Instead of using made-up data, could you create a boxplot using my actual database? I need to see how many visits each tourist has made to the theme park. Please use the Tourist_ID for the age groups on the x-axis and the Visit_ID for the people count on the y-axis. Make sure the whiskers extend all the way to the minimum and maximum values, not just to the quartiles.",
        "code": "import altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/cre_Theme_park.sqlite')\nquery = '''\nSELECT CAST(Tourist_ID AS TEXT) AS age, Visit_ID AS people FROM Visits\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_boxplot(extent='min-max').encode(\n    x='age:O',\n    y='people:Q'\n)\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___boxplot_with_minmax_whiskers.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "culture_company",
        "chart_category": "Distributions",
        "chart_type": "cumulative_count_chart",
        "NLQ": "Instead of showing IMDB ratings, can you create a chart that shows how the total number of books grows over time? I need to pull the data from our book club database, showing the count of books by year. Make sure the x-axis shows the years and the y-axis shows the cumulative count of books. I want to see how our book collection has grown over time with a filled area chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/culture_company.sqlite')\n\nquery = '''\nSELECT Year, COUNT(*) AS Book_Count\nFROM book_club\nGROUP BY Year\nORDER BY Year\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ncumulative_chart = alt.Chart(df).transform_window(\n    cumulative_count=\"sum(Book_Count)\",\n    sort=[{\"field\": \"Year\"}],\n).mark_area().encode(\n    x=alt.X(\"Year:Q\", title=\"Year\"),\n    y=alt.Y(\"cumulative_count:Q\", title=\"Cumulative Count of Books\").stack(False)\n)\n\ncumulative_chart",
        "reference_path": "./vis_bench/code/altair/Distributions___cumulative_count_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "culture_company",
        "chart_category": "Distributions",
        "chart_type": "cumulative_count_chart",
        "NLQ": "Instead of showing IMDB ratings, can you create a chart that shows how the total number of books grows over time? I need to pull this data from our company database - specifically the book_club table - and group it by year. I'd like to see a cumulative count of books as an area chart, with the year on the x-axis and the running total on the y-axis. Let's use Altair for this visualization instead of matplotlib.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/culture_company.sqlite')\nquery = '''\nSELECT Year, COUNT(*) AS Book_Count\nFROM book_club\nGROUP BY Year\nORDER BY Year\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ncumulative_chart = alt.Chart(df).transform_window(\n    cumulative_count=\"sum(Book_Count)\",\n    sort=[{\"field\": \"Year\"}],\n).mark_area().encode(\n    x=alt.X(\"Year:Q\", title=\"Year\"),\n    y=alt.Y(\"cumulative_count:Q\", title=\"Cumulative Count of Books\").stack(False)\n)\n\ncumulative_chart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___cumulative_count_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "customers_and_addresses",
        "chart_category": "Distributions",
        "chart_type": "cumulative_count_chart",
        "NLQ": "Can you change my chart to show the growth of orders over time instead of IMDB ratings? I'd like to see how different order statuses accumulate over time, with each status shown in a different color. Please use our customer orders database and make sure the chart has a clear title like \"Cumulative Count of Orders by Status Over Time\" with proper labels for the axes. I want to see the date on the x-axis and the count on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customers_and_addresses.sqlite')\n\nquery = '''\nSELECT \n    order_status, \n    order_date\nFROM \n    Customer_Orders\nORDER BY \n    order_date ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\ndf['order_date'] = pd.to_datetime(df['order_date'])\n\ncumulative_chart = alt.Chart(df).transform_window(\n    cumulative_count=\"count()\",\n    sort=[{\"field\": \"order_date\"}],\n    groupby=[\"order_status\"]\n).mark_area().encode(\n    x=alt.X(\"order_date:T\", title=\"Order Date\"),\n    y=alt.Y(\"cumulative_count:Q\", stack=False, title=\"Cumulative Count\"),\n    color=alt.Color(\"order_status:N\", title=\"Order Status\")\n).properties(\n    title=\"Cumulative Count of Orders by Status Over Time\"\n)\n\ncumulative_chart",
        "reference_path": "./vis_bench/code/altair/Distributions___cumulative_count_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "customers_and_addresses",
        "chart_category": "Distributions",
        "chart_type": "cumulative_count_chart",
        "NLQ": "Can you create a chart that shows how our orders accumulate over time? I'd like to see the growth trend for each different order status, with different colors for each status. Instead of using random data like in my example, please use our actual order data from the customer database. Make sure to include a clear title that explains what we're looking at, and label the axes properly with \"Order Date\" and \"Cumulative Count\". I want to see how orders have built up over time for each status category.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customers_and_addresses.sqlite')\n\nquery = '''\nSELECT \n    order_status, \n    order_date\nFROM \n    Customer_Orders\nORDER BY \n    order_date ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ndf['order_date'] = pd.to_datetime(df['order_date'])\n\ncumulative_chart = alt.Chart(df).transform_window(\n    cumulative_count=\"count()\",\n    sort=[{\"field\": \"order_date\"}],\n    groupby=[\"order_status\"]\n).mark_area().encode(\n    x=alt.X(\"order_date:T\", title=\"Order Date\"),\n    y=alt.Y(\"cumulative_count:Q\", stack=False, title=\"Cumulative Count\"),\n    color=alt.Color(\"order_status:N\", title=\"Order Status\")\n).properties(\n    title=\"Cumulative Count of Orders by Status Over Time\"\n)\n\ncumulative_chart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___cumulative_count_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "customers_and_addresses",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_last_value_labeled",
        "NLQ": "Instead of showing stock prices for different companies, can you create a line chart that shows the total number of orders per day from our customer database? I'd like to see how order volume changes over time, with clear axis labels like \"Order Date\" and \"Total Orders\". Keep the same style where you mark the final data point with a circle and show its value, but make it show the actual order count instead of company names.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customers_and_addresses.sqlite')\n\nquery = '''\nSELECT \n    DATE(order_date) AS order_date, \n    COUNT(order_id) AS total_orders\nFROM \n    Customer_Orders\nGROUP BY \n    DATE(order_date)\nORDER BY \n    order_date\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).encode(\n    x=alt.X(\"order_date:T\", title=\"Order Date\"),\n    y=alt.Y(\"total_orders:Q\", title=\"Total Orders\")\n)\n\nline = chart.mark_line().encode()\n\nlabel = chart.encode(\n    x='max(order_date):T',\n    y=alt.Y('total_orders:Q').aggregate(argmax='order_date'),\n    text=alt.Text('total_orders:Q', format='.0f')\n)\n\ntext = label.mark_text(align='left', dx=4)\ncircle = label.mark_circle()\nfinal_chart = line + circle + text\nfinal_chart",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_last_value_labeled.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "customers_and_addresses",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_last_value_labeled",
        "NLQ": "Instead of showing stock prices for Apple, Microsoft, and Google, can you create a line chart that shows the total number of orders per day from our customer database? I'd like to see how orders change over time, with a circle marking the most recent data point and its value labeled next to it. Please use Altair instead of Matplotlib and pull the data directly from our SQLite database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customers_and_addresses.sqlite')\n\nquery = '''\nSELECT \n    DATE(order_date) AS order_date, \n    COUNT(order_id) AS total_orders\nFROM \n    Customer_Orders\nGROUP BY \n    DATE(order_date)\nORDER BY \n    order_date\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).encode(\n    x=alt.X(\"order_date:T\", title=\"Order Date\"),\n    y=alt.Y(\"total_orders:Q\", title=\"Total Orders\")\n)\n\nline = chart.mark_line().encode()\n\nlabel = chart.encode(\n    x='max(order_date):T',\n    y=alt.Y('total_orders:Q').aggregate(argmax='order_date'),\n    text=alt.Text('total_orders:Q', format='.0f')\n)\n\ntext = label.mark_text(align='left', dx=4)\n\ncircle = label.mark_circle()\n\nfinal_chart = line + circle + text\n\nfinal_chart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_last_value_labeled.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "customers_and_invoices",
        "chart_category": "Distributions",
        "chart_type": "cumulative_count_chart",
        "NLQ": "Can you change my chart to show the cumulative count of orders over time? Instead of using IMDB ratings on the x-axis, I want to use actual order dates from our customer database. Please pull the data from our SQLite database and show how the total number of orders increases as time goes by. Make sure to label the axes properly - \"Order Date\" on the x-axis and \"Cumulative Count of Orders\" on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customers_and_invoices.sqlite')\n\nquery = '''\nSELECT \n    date_order_placed AS order_date\nFROM \n    Orders\nORDER BY \n    date_order_placed ASC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ncumulative_chart = alt.Chart(df).transform_window(\n    cumulative_count=\"count()\",\n    sort=[{\"field\": \"order_date\"}],\n).mark_area().encode(\n    x=alt.X(\"order_date:T\", title=\"Order Date\"),\n    y=alt.Y(\"cumulative_count:Q\", title=\"Cumulative Count of Orders\").stack(False)\n)\n\ncumulative_chart",
        "reference_path": "./vis_bench/code/altair/Distributions___cumulative_count_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "customers_and_invoices",
        "chart_category": "Distributions",
        "chart_type": "cumulative_count_chart",
        "NLQ": "Instead of showing IMDB ratings, can you create a chart that shows how the total number of orders grows over time? I'd like to see the cumulative count of orders by date from our customer database. Please use an area chart with the date on the x-axis and the running total of orders on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customers_and_invoices.sqlite')\n\nquery = '''\nSELECT \n    date_order_placed AS order_date\nFROM \n    Orders\nORDER BY \n    date_order_placed ASC\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ncumulative_chart = alt.Chart(df).transform_window(\n    cumulative_count=\"count()\",\n    sort=[{\"field\": \"order_date\"}],\n).mark_area().encode(\n    x=alt.X(\"order_date:T\", title=\"Order Date\"),\n    y=alt.Y(\"cumulative_count:Q\", title=\"Cumulative Count of Orders\").stack(False)\n)\n\ncumulative_chart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___cumulative_count_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "customer_deliveries",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_logarithmic_scale",
        "NLQ": "Could you make a graph that shows how our total number of customers has grown over time, using a layout similar to what I have in my code? I'd like to see the cumulative growth rather than just yearly numbers, and please use a logarithmic scale for the vertical axis so we can better see the growth pattern. Also, add a title that mentions it's showing customer growth over time and that it's using a logarithmic scale. The data should come from our customer_deliveries database instead of the sample data in my example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customer_deliveries.sqlite')\n\nquery = '''\nSELECT\n    date(date_became_customer) AS year,\n    COUNT(customer_id) AS num_customers\nFROM Customers\nGROUP BY\n    year\nORDER BY\n    year;\n'''\n\ndf = pd.read_sql_query(query, conn)\ndf['cumulative_customers'] = df['num_customers'].cumsum()\n\nconn.close()\n\nalt.Chart(df).mark_line().encode(\n    x='year:O',\n    y=alt.Y('cumulative_customers', scale=alt.Scale(type=\"log\"), title='Cumulative Number of Customers')\n).properties(\n    title='Customer Growth Over Time (Logarithmic Scale)'\n)",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_logarithmic_scale.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "customer_deliveries",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_logarithmic_scale",
        "NLQ": "Could you create a graph showing the cumulative growth of our customers over time? I'd like to use our customer database instead of the sample data in my example. Please keep the logarithmic scale on the vertical axis since our growth has been exponential. Add a proper title like \"Customer Growth Over Time\" and label the y-axis as \"Cumulative Number of Customers\" instead of just \"sum(people)\". Also, can you switch from matplotlib to Altair for this visualization?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customer_deliveries.sqlite')\n\nquery = '''\nSELECT\n    date(date_became_customer) AS year,\n    COUNT(customer_id) AS num_customers\nFROM Customers\nGROUP BY\n    year\nORDER BY\n    year;\n'''\n\ndf = pd.read_sql_query(query, conn)\ndf['cumulative_customers'] = df['num_customers'].cumsum()\n\nconn.close()\n\nalt.Chart(df).mark_line().encode(\n    x='year:O',\n    y=alt.Y('cumulative_customers', scale=alt.Scale(type=\"log\"), title='Cumulative Number of Customers')\n).properties(\n    title='Customer Growth Over Time (Logarithmic Scale)'\n)",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_logarithmic_scale.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "decoration_competition",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_items",
        "NLQ": "Can you create a bar chart showing the top 5 colleges based on their average ranking from our decoration competition database? I'd like to see each college's name and their average rank, with the bars colored according to the ranking values. Please sort the colleges from highest to lowest average rank.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/decoration_competition.sqlite')\n\nquery = '''\nSELECT \n    c.Name AS College_Name,\n    AVG(r.Rank_in_Round) AS Avg_Rank\nFROM \n    round AS r\nJOIN \n    member AS m ON r.Member_ID = m.Member_ID\nJOIN \n    college AS c ON m.College_ID = c.College_ID\nGROUP BY \n    c.College_ID\nORDER BY \n    Avg_Rank DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X('College_Name:N').sort('-y'),\n    alt.Y('Avg_Rank:Q'),\n    alt.Color('Avg_Rank:Q')\n).transform_window(\n    rank='rank(Avg_Rank)',\n    sort=[alt.SortField('Avg_Rank', order='descending')]\n).transform_filter(\n    (alt.datum.rank < 6)\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___top_k_items.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "decoration_competition",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_items",
        "NLQ": "Can you create a bar chart showing the top 5 colleges based on their average ranking from our decoration competition database? I'd like to see the colleges sorted by their average rank, with a color gradient applied to the bars. Please use Altair instead of Matplotlib for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/decoration_competition.sqlite')\nquery = '''\nSELECT \n    c.Name AS College_Name,\n    AVG(r.Rank_in_Round) AS Avg_Rank\nFROM \n    round AS r\nJOIN \n    member AS m ON r.Member_ID = m.Member_ID\nJOIN \n    college AS c ON m.College_ID = c.College_ID\nGROUP BY \n    c.College_ID\nORDER BY \n    Avg_Rank DESC\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X('College_Name:N').sort('-y'),\n    alt.Y('Avg_Rank:Q'),\n    alt.Color('Avg_Rank:Q')\n).transform_window(\n    rank='rank(Avg_Rank)',\n    sort=[alt.SortField('Avg_Rank', order='descending')]\n).transform_filter(\n    (alt.datum.rank < 6)\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___top_k_items.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "decoration_competition",
        "chart_category": "Distributions",
        "chart_type": "empirical_cumulative_distribution_function",
        "NLQ": "Instead of the bubble chart with ticks showing medians, I'd like to create a line chart that shows the cumulative distribution of rankings for different colleges. Can you pull data from our decoration competition database and plot each college as a different colored line? I want to see how the rankings add up across colleges so we can easily compare their performance. Please include a clear title and proper axis labels that explain we're looking at the empirical cumulative distribution of ranks by college.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/decoration_competition.sqlite')\n\nquery = '''\nSELECT \n    c.Name AS College_Name,\n    r.Rank_in_Round\nFROM \n    round AS r\nJOIN \n    member AS m ON r.Member_ID = m.Member_ID\nJOIN \n    college AS c ON m.College_ID = c.College_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_window(\n    ecdf=\"cume_dist()\",\n    sort=[{\"field\": \"Rank_in_Round\", \"order\": \"ascending\"}],\n    groupby=[\"College_Name\"]\n).mark_line().encode(\n    x=alt.X(\"Rank_in_Round:Q\", title=\"Rank in Round\"),\n    y=alt.Y(\"ecdf:Q\", title=\"Empirical Cumulative Distribution\"),\n    color=alt.Color(\"College_Name:N\", title=\"College\")\n).properties(\n    title=\"Empirical Cumulative Distribution of Ranks by College\",\n    width=600,\n    height=400\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___empirical_cumulative_distribution_function.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "decoration_competition",
        "chart_category": "Distributions",
        "chart_type": "empirical_cumulative_distribution_function",
        "NLQ": "Instead of the scatter plot with medians, I'd like to create a line chart showing the cumulative distribution of rankings for different colleges. Can you pull data from our decoration competition database and show how ranks are distributed across colleges? I want to see lines for each college in different colors so I can easily compare their performance. Please add a clear title like \"Empirical Cumulative Distribution of Ranks by College\" and proper axis labels. Make the chart wide enough to read easily.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/decoration_competition.sqlite')\n\nquery = '''\nSELECT \n    c.Name AS College_Name,\n    r.Rank_in_Round\nFROM \n    round AS r\nJOIN \n    member AS m ON r.Member_ID = m.Member_ID\nJOIN \n    college AS c ON m.College_ID = c.College_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_window(\n    ecdf=\"cume_dist()\",\n    sort=[{\"field\": \"Rank_in_Round\", \"order\": \"ascending\"}],\n    groupby=[\"College_Name\"]\n).mark_line().encode(\n    x=alt.X(\"Rank_in_Round:Q\", title=\"Rank in Round\"),\n    y=alt.Y(\"ecdf:Q\", title=\"Empirical Cumulative Distribution\"),\n    color=alt.Color(\"College_Name:N\", title=\"College\")\n).properties(\n    title=\"Empirical Cumulative Distribution of Ranks by College\",\n    width=600,\n    height=400\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___empirical_cumulative_distribution_function.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "department_management",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_letters",
        "NLQ": "I'd like to see a bar chart that shows the top 10 states where most of the department heads were born. Can you pull this data from our department management database instead of using the text analysis? I want the bars sorted by the number of people from high to low, similar to the letter frequency chart we have now.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/department_management.sqlite')\n\nquery = '''\nSELECT h.born_state AS state, COUNT(*) AS head_count\nFROM head AS h\nGROUP BY h.born_state\nORDER BY head_count DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).transform_window(\n    rank='rank(head_count)',\n    sort=[alt.SortField('head_count', order='descending')]\n).transform_filter(\n    alt.datum.rank < 11\n).mark_bar().encode(\n    y=alt.Y('state:N').sort('-x'),\n    x='head_count:Q'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___top_k_letters.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "department_management",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_letters",
        "NLQ": "Instead of showing letter frequencies from that text, can you create a bar chart showing the top 10 states where department heads were born? I'd like to pull this data from our department management database. Make sure the bars are horizontal with states on the y-axis, sorted from highest to lowest count. Keep it simple and clean looking.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/department_management.sqlite')\n\nquery = '''\nSELECT h.born_state AS state, COUNT(*) AS head_count\nFROM head AS h\nGROUP BY h.born_state\nORDER BY head_count DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_window(\n    rank='rank(head_count)',\n    sort=[alt.SortField('head_count', order='descending')]\n).transform_filter(\n    alt.datum.rank < 11\n).mark_bar().encode(\n    y=alt.Y('state:N').sort('-x'),\n    x='head_count:Q'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___top_k_letters.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "department_management",
        "chart_category": "Distributions",
        "chart_type": "empirical_cumulative_distribution_function",
        "NLQ": "Instead of the bubble chart with ticks showing survey responses, could you create a cumulative distribution chart that shows how department budgets are distributed? I'd like it to have a step-like pattern for the line and include a title that explains what the chart is about. Please pull the budget data from our department management database rather than using the survey data. Make sure to label the axes properly - the x-axis should show \"Budget in Billions\" and the y-axis should show \"Cumulative Proportion\" from 0 to 1. Can you make the chart a good size, around 600 by 400?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/department_management.sqlite')\nquery = '''\nSELECT Budget_in_Billions\nFROM department\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\necdf_chart = alt.Chart(df).transform_window(\n    ecdf=\"cume_dist()\",\n    sort=[{\"field\": \"Budget_in_Billions\"}]\n).mark_line(interpolate='step-after').encode(\n    x=alt.X(\"Budget_in_Billions:Q\", title=\"Budget in Billions\"),\n    y=alt.Y(\"ecdf:Q\", title=\"Cumulative Proportion\", scale=alt.Scale(domain=[0, 1]))\n).properties(\n    title=\"Empirical Cumulative Distribution of Department Budgets\",\n    width=600,\n    height=400\n)\n\necdf_chart",
        "reference_path": "./vis_bench/code/altair/Distributions___empirical_cumulative_distribution_function.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "department_management",
        "chart_category": "Distributions",
        "chart_type": "empirical_cumulative_distribution_function",
        "NLQ": "Instead of the scatter plot with medians, could you create a cumulative distribution chart that shows how department budgets are distributed? I'd like to see the step pattern that shows the proportion of departments at or below each budget level. Please title it \"Empirical Cumulative Distribution of Department Budgets\" and make sure to label the x-axis as \"Budget in Billions\" and the y-axis as \"Cumulative Proportion\" with the y-axis ranging from 0 to 1. Could you pull this data from our department management database instead of using the sample data in my code?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/department_management.sqlite')\nquery = '''\nSELECT Budget_in_Billions\nFROM department\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\necdf_chart = alt.Chart(df).transform_window(\n    ecdf=\"cume_dist()\",\n    sort=[{\"field\": \"Budget_in_Billions\"}]\n).mark_line(interpolate='step-after').encode(\n    x=alt.X(\"Budget_in_Billions:Q\", title=\"Budget in Billions\"),\n    y=alt.Y(\"ecdf:Q\", title=\"Cumulative Proportion\", scale=alt.Scale(domain=[0, 1]))\n).properties(\n    title=\"Empirical Cumulative Distribution of Department Budgets\",\n    width=600,\n    height=400\n)\n\necdf_chart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___empirical_cumulative_distribution_function.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "department_store",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_letters",
        "NLQ": "Instead of showing letter frequencies from text, could you create a bar chart showing the top 10 most frequently purchased products from our department store database? I'd like to see the product names on the y-axis and their purchase counts on the x-axis, with the bars sorted from highest to lowest. Please add a clear title that says \"Top 10 Most Frequently Purchased Products\" and make sure the axis labels say \"Product\" and \"Purchase Count\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/department_store.sqlite')\n\nquery = '''\nSELECT \n    P.product_name AS product,\n    COUNT(OI.order_item_id) AS purchase_count\nFROM \n    Products AS P\nJOIN \n    Order_Items AS OI ON P.product_id = OI.product_id\nGROUP BY \n    P.product_name\nORDER BY \n    purchase_count DESC\nLIMIT 10;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    y=alt.Y('product:N', sort='-x', title='Product'),\n    x=alt.X('purchase_count:Q', title='Purchase Count')\n).properties(\n    title='Top 10 Most Frequently Purchased Products'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___top_k_letters.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "department_store",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_letters",
        "NLQ": "Instead of showing letter frequencies from text, could you create a bar chart showing the top 10 most frequently purchased products from our department store database? I'd like to see the product names on the y-axis and the number of purchases on the x-axis, with the bars sorted from highest to lowest purchase count. Please add a clear title like \"Top 10 Most Frequently Purchased Products\" and make sure the axis labels are descriptive.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/department_store.sqlite')\n\nquery = '''\nSELECT \n    P.product_name AS product,\n    COUNT(OI.order_item_id) AS purchase_count\nFROM \n    Products AS P\nJOIN \n    Order_Items AS OI ON P.product_id = OI.product_id\nGROUP BY \n    P.product_name\nORDER BY \n    purchase_count DESC\nLIMIT 10;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    y=alt.Y('product:N', sort='-x', title='Product'),\n    x=alt.X('purchase_count:Q', title='Purchase Count')\n).properties(\n    title='Top 10 Most Frequently Purchased Products'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___top_k_letters.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "device",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_letters",
        "NLQ": "Instead of analyzing text from a book, could you create a bar chart showing the top 5 most common software platforms in my device database? I'd like to keep the same horizontal bar chart style with the bars sorted from highest to lowest count, but use my device data instead of letter frequencies. Just pull the data directly from my SQLite database and limit it to the top 5 platforms.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/device.sqlite')\nquery = '''\nSELECT Software_Platform, COUNT(*) AS Platform_Count\nFROM device\nGROUP BY Software_Platform\nORDER BY Platform_Count DESC\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nalt.Chart(df).transform_window(\n    rank='rank(Platform_Count)',\n    sort=[alt.SortField('Platform_Count', order='descending')]\n).transform_filter(\n    alt.datum.rank < 6\n).mark_bar().encode(\n    y=alt.Y('Software_Platform:N').sort('-x'),\n    x='Platform_Count:Q'\n)",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___top_k_letters.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "device",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_letters",
        "NLQ": "Instead of analyzing text to count letters, could you create a bar chart showing the top 5 most common software platforms from my device database? I'd like horizontal bars rather than vertical ones, with the platforms sorted so the most common one is at the top. Please use Altair instead of Matplotlib for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/device.sqlite')\n\nquery = '''\nSELECT Software_Platform, COUNT(*) AS Platform_Count\nFROM device\nGROUP BY Software_Platform\nORDER BY Platform_Count DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nalt.Chart(df).transform_window(\n    rank='rank(Platform_Count)',\n    sort=[alt.SortField('Platform_Count', order='descending')]\n).transform_filter(\n    alt.datum.rank < 6\n).mark_bar().encode(\n    y=alt.Y('Software_Platform:N').sort('-x'),\n    x='Platform_Count:Q'\n)",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___top_k_letters.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "device",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_point_markers",
        "NLQ": "Can you create a line chart showing the trend of shop openings over the years? I'd like to see how many shops opened each year, with points marking each data point and lines connecting them. Please label the x-axis as \"Year Opened\" and the y-axis as \"Number of Shops Opened\". Add a title \"Trend of Shop Openings Over Years\" and make it so I can hover over points to see the exact year and number of shops. Instead of using random data like in the example, please pull the actual shop opening data from our database.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/device.sqlite')\nquery = \"\"\"\nSELECT Open_Year, COUNT(Shop_ID) AS Shop_Count\nFROM shop\nGROUP BY Open_Year\nORDER BY Open_Year\n\"\"\"\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line(point=True).encode(\n    x=alt.X('Open_Year:O', title='Year Opened'),\n    y=alt.Y('Shop_Count:Q', title='Number of Shops Opened'),\n    tooltip=['Open_Year', 'Shop_Count']\n).properties(\n    title='Trend of Shop Openings Over Years'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_point_markers.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "device",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_point_markers",
        "NLQ": "Instead of showing stock prices for different companies, can you create a line chart that shows how many shops opened each year? I'd like to see the trend over time with points marked on the line. Please pull this data from our shop database, label the x-axis as \"Year Opened\" and the y-axis as \"Number of Shops Opened\", and add a title \"Trend of Shop Openings Over Years\". Also, make it interactive so I can see the exact values when I hover over the points.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/device.sqlite')\n\nquery = \"\"\"\nSELECT Open_Year, COUNT(Shop_ID) AS Shop_Count\nFROM shop\nGROUP BY Open_Year\nORDER BY Open_Year\n\"\"\"\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line(point=True).encode(\n    x=alt.X('Open_Year:O', title='Year Opened'),\n    y=alt.Y('Shop_Count:Q', title='Number of Shops Opened'),\n    tooltip=['Open_Year', 'Shop_Count']\n).properties(\n    title='Trend of Shop Openings Over Years'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_point_markers.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "document_management",
        "chart_category": "Advanced Calculations",
        "chart_type": "waterfall_chart",
        "NLQ": "Can you create a waterfall chart showing the access counts for each document structure type from our database? I'd like to see how each document type contributes to the total count, with bars colored red for increases and green for decreases. Make the bars wider and add clear labels on each bar showing the values. Please include a proper title for each axis - \"Document Structure\" on the x-axis and \"Access Count\" on the y-axis. Also, can you make the chart larger, about 800 by 450 pixels, and make sure the x-axis labels are horizontal so they're easy to read? I want white text on the colored bars for better visibility.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/document_management.sqlite')\n\nquery = '''\nSELECT \n    DS.document_structure_description,\n    SUM(D.access_count) AS total_access_count\nFROM Documents AS D\nJOIN Document_Structures AS DS \n    ON D.document_structure_code = DS.document_structure_code\nGROUP BY DS.document_structure_description\nORDER BY DS.document_structure_code\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbegin_row = pd.DataFrame([{\"document_structure_description\": \"Begin\", \"total_access_count\": 0}])\nend_row = pd.DataFrame([{\"document_structure_description\": \"End\", \"total_access_count\": df['total_access_count'].sum()}])\ndf = pd.concat([begin_row, df, end_row], ignore_index=True)\n\namount = alt.datum.total_access_count\nlabel = alt.datum.document_structure_description\nwindow_lead_label = alt.datum.window_lead_label\nwindow_sum_amount = alt.datum.window_sum_amount\n\ncalc_prev_sum = alt.expr.if_(label == \"End\", 0, window_sum_amount - amount)\ncalc_amount = alt.expr.if_(label == \"End\", window_sum_amount, amount)\ncalc_text_amount = (\n    alt.expr.if_((label != \"Begin\") & (label != \"End\") & calc_amount > 0, \"+\", \"\")\n    + calc_amount\n)\n\nbase_chart = alt.Chart(df).transform_window(\n    window_sum_amount=\"sum(total_access_count)\",\n    window_lead_label=\"lead(document_structure_description)\",\n).transform_calculate(\n    calc_lead=alt.expr.if_((window_lead_label == None), label, window_lead_label),\n    calc_prev_sum=calc_prev_sum,\n    calc_amount=calc_amount,\n    calc_text_amount=calc_text_amount,\n    calc_center=(window_sum_amount + calc_prev_sum) / 2,\n    calc_sum_dec=alt.expr.if_(window_sum_amount < calc_prev_sum, window_sum_amount, \"\"),\n    calc_sum_inc=alt.expr.if_(window_sum_amount > calc_prev_sum, window_sum_amount, \"\"),\n).encode(\n    x=alt.X(\"document_structure_description:O\", axis=alt.Axis(title=\"Document Structure\", labelAngle=0), sort=None)\n)\n\ncolor_coding = (\n    alt.when((label == \"Begin\") | (label == \"End\"))\n    .then(alt.value(\"#878d96\"))\n    .when(calc_amount < 0)\n    .then(alt.value(\"#24a148\"))\n    .otherwise(alt.value(\"#fa4d56\"))\n)\n\nbar = base_chart.mark_bar(size=45).encode(\n    y=alt.Y(\"calc_prev_sum:Q\", title=\"Access Count\"),\n    y2=alt.Y2(\"window_sum_amount:Q\"),\n    color=color_coding,\n)\n\nrule = base_chart.mark_rule(xOffset=-22.5, x2Offset=22.5).encode(\n    y=\"window_sum_amount:Q\",\n    x2=\"calc_lead\",\n)\n\ntext_pos_values_top_of_bar = base_chart.mark_text(baseline=\"bottom\", dy=-4).encode(\n    text=alt.Text(\"calc_sum_inc:N\"),\n    y=\"calc_sum_inc:Q\",\n)\ntext_neg_values_bot_of_bar = base_chart.mark_text(baseline=\"top\", dy=4).encode(\n    text=alt.Text(\"calc_sum_dec:N\"),\n    y=\"calc_sum_dec:Q\",\n)\ntext_bar_values_mid_of_bar = base_chart.mark_text(baseline=\"middle\").encode(\n    text=alt.Text(\"calc_text_amount:N\"),\n    y=\"calc_center:Q\",\n    color=alt.value(\"white\"),\n)\n\nalt.layer(\n    bar,\n    rule,\n    text_pos_values_top_of_bar,\n    text_neg_values_bot_of_bar,\n    text_bar_values_mid_of_bar\n).properties(\n    width=800,\n    height=450\n)",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___waterfall_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "document_management",
        "chart_category": "Advanced Calculations",
        "chart_type": "waterfall_chart",
        "NLQ": "Can you create a waterfall chart showing the total access count for each document structure type from our database? I'd like to see how each document structure contributes to the total count, with red bars for increases and green bars for decreases. Please include connecting lines between the bars and show the values both inside the bars and at the top or bottom. Make sure to label the x-axis as \"Document Structure\" and the y-axis as \"Access Count\", and make the chart larger - about 800 by 450 pixels.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/document_management.sqlite')\n\nquery = '''\nSELECT \n    DS.document_structure_description,\n    SUM(D.access_count) AS total_access_count\nFROM Documents AS D\nJOIN Document_Structures AS DS \n    ON D.document_structure_code = DS.document_structure_code\nGROUP BY DS.document_structure_description\nORDER BY DS.document_structure_code\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbegin_row = pd.DataFrame([{\"document_structure_description\": \"Begin\", \"total_access_count\": 0}])\nend_row = pd.DataFrame([{\"document_structure_description\": \"End\", \"total_access_count\": df['total_access_count'].sum()}])\ndf = pd.concat([begin_row, df, end_row], ignore_index=True)\n\namount = alt.datum.total_access_count\nlabel = alt.datum.document_structure_description\nwindow_lead_label = alt.datum.window_lead_label\nwindow_sum_amount = alt.datum.window_sum_amount\n\ncalc_prev_sum = alt.expr.if_(label == \"End\", 0, window_sum_amount - amount)\ncalc_amount = alt.expr.if_(label == \"End\", window_sum_amount, amount)\ncalc_text_amount = (\n    alt.expr.if_((label != \"Begin\") & (label != \"End\") & calc_amount > 0, \"+\", \"\")\n    + calc_amount\n)\n\nbase_chart = alt.Chart(df).transform_window(\n    window_sum_amount=\"sum(total_access_count)\",\n    window_lead_label=\"lead(document_structure_description)\",\n).transform_calculate(\n    calc_lead=alt.expr.if_((window_lead_label == None), label, window_lead_label),\n    calc_prev_sum=calc_prev_sum,\n    calc_amount=calc_amount,\n    calc_text_amount=calc_text_amount,\n    calc_center=(window_sum_amount + calc_prev_sum) / 2,\n    calc_sum_dec=alt.expr.if_(window_sum_amount < calc_prev_sum, window_sum_amount, \"\"),\n    calc_sum_inc=alt.expr.if_(window_sum_amount > calc_prev_sum, window_sum_amount, \"\"),\n).encode(\n    x=alt.X(\"document_structure_description:O\", axis=alt.Axis(title=\"Document Structure\", labelAngle=0), sort=None)\n)\n\ncolor_coding = (\n    alt.when((label == \"Begin\") | (label == \"End\"))\n    .then(alt.value(\"#878d96\"))\n    .when(calc_amount < 0)\n    .then(alt.value(\"#24a148\"))\n    .otherwise(alt.value(\"#fa4d56\"))\n)\n\nbar = base_chart.mark_bar(size=45).encode(\n    y=alt.Y(\"calc_prev_sum:Q\", title=\"Access Count\"),\n    y2=alt.Y2(\"window_sum_amount:Q\"),\n    color=color_coding,\n)\n\nrule = base_chart.mark_rule(xOffset=-22.5, x2Offset=22.5).encode(\n    y=\"window_sum_amount:Q\",\n    x2=\"calc_lead\",\n)\n\ntext_pos_values_top_of_bar = base_chart.mark_text(baseline=\"bottom\", dy=-4).encode(\n    text=alt.Text(\"calc_sum_inc:N\"),\n    y=\"calc_sum_inc:Q\",\n)\ntext_neg_values_bot_of_bar = base_chart.mark_text(baseline=\"top\", dy=4).encode(\n    text=alt.Text(\"calc_sum_dec:N\"),\n    y=\"calc_sum_dec:Q\",\n)\ntext_bar_values_mid_of_bar = base_chart.mark_text(baseline=\"middle\").encode(\n    text=alt.Text(\"calc_text_amount:N\"),\n    y=\"calc_center:Q\",\n    color=alt.value(\"white\"),\n)\n\nalt.layer(\n    bar,\n    rule,\n    text_pos_values_top_of_bar,\n    text_neg_values_bot_of_bar,\n    text_bar_values_mid_of_bar\n).properties(\n    width=800,\n    height=450\n)",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___waterfall_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "document_management",
        "chart_category": "Distributions",
        "chart_type": "faceted_histogram",
        "NLQ": "Instead of using random data about car horsepower from different countries, can you create a similar chart using my document database? I want to see how frequently each document type is accessed, with separate rows for each document type. Keep the same bar chart style, but make the bins show access counts instead of horsepower. Use about 30 bins to break down the access counts.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/document_management.sqlite')\n\nquery = '''\nSELECT \n    document_type_code AS Document_Type,\n    access_count AS Access_Count\nFROM \n    Documents\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"Access_Count:Q\").bin(maxbins=30),\n    y=\"count()\",\n    row=\"Document_Type\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___faceted_histogram.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "document_management",
        "chart_category": "Distributions",
        "chart_type": "faceted_histogram",
        "NLQ": "Instead of showing horsepower data by country of origin, can you create a similar chart that shows how frequently different document types are accessed? I'd like to pull this data from our document management database and display it as histograms arranged in rows by document type. Keep the same layout with separate rows for each category, but use the document access count data instead.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/document_management.sqlite')\nquery = '''\nSELECT \n    document_type_code AS Document_Type,\n    access_count AS Access_Count\nFROM \n    Documents\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"Access_Count:Q\").bin(maxbins=30),\n    y=\"count()\",\n    row=\"Document_Type\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___faceted_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "document_management",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_point_markers",
        "NLQ": "Can you create a line chart showing the total access count of different document types over time? I'd like to see the data by month, with each document type shown in a different color. Please add dots at each data point along the lines, include a title that says \"Total Access Count of Documents by Type Over Time\", and label the axes as \"Month\" and \"Total Access Count\". I need this to use our document management database instead of the stock price data in the example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/document_management.sqlite')\n\nquery = '''\nSELECT \n    strftime('%Y-%m', T1.document_code) AS month,\n    T1.document_type_code AS document_type,\n    SUM(T1.access_count) AS total_access_count\nFROM \n    Documents AS T1\nGROUP BY \n    month, document_type\nORDER BY \n    month ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line(point=True).encode(\n    x=alt.X('month:T', title='Month'),\n    y=alt.Y('total_access_count:Q', title='Total Access Count'),\n    color=alt.Color('document_type:N', title='Document Type')\n).properties(\n    title='Total Access Count of Documents by Type Over Time'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_point_markers.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "document_management",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_point_markers",
        "NLQ": "Instead of showing stock prices over time, can you create a line chart that shows how often different types of documents are accessed each month? I'd like to see the total access count for each document type, with different colors for each type. Please add dots at each data point on the lines, include a clear title like \"Total Access Count of Documents by Type Over Time\", and pull the data from our document management database instead of using random data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/document_management.sqlite')\n\nquery = '''\nSELECT \n    strftime('%Y-%m', T1.document_code) AS month,\n    T1.document_type_code AS document_type,\n    SUM(T1.access_count) AS total_access_count\nFROM \n    Documents AS T1\nGROUP BY \n    month, document_type\nORDER BY \n    month ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_line(point=True).encode(\n    x=alt.X('month:T', title='Month'),\n    y=alt.Y('total_access_count:Q', title='Total Access Count'),\n    color=alt.Color('document_type:N', title='Document Type')\n).properties(\n    title='Total Access Count of Documents by Type Over Time'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_point_markers.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "dog_kennels",
        "chart_category": "Advanced Calculations",
        "chart_type": "waterfall_chart",
        "NLQ": "Can you create a waterfall chart showing the monthly cost of treatments from our dog kennel database? I'd like it to look similar to my example chart, but instead of using the sample data, pull the real treatment costs from our SQLite database. Make the chart wider and taller, and add proper axis titles - \"Months\" for the x-axis and \"Cost of Treatment\" for the y-axis. Also, can you angle the month labels by 45 degrees so they're easier to read? Make the bars a bit thicker too, and add white text inside the bars to make the values stand out better. The chart should start at zero and end with the total cost, with each month showing how much was spent on treatments.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/dog_kennels.sqlite')\nquery = \"\"\"\nSELECT\n    STRFTIME('%Y-%m', date_of_treatment) AS treatment_month,\n    SUM(cost_of_treatment) AS monthly_cost\nFROM Treatments\nGROUP BY treatment_month\nORDER BY treatment_month;\n\"\"\"\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndata = []\ntotal_cost = 0\ndata.append({\"label\": \"Start\", \"amount\": 0})\n\nfor index, row in df.iterrows():\n    amount = row['monthly_cost']\n    total_cost += amount\n    data.append({\"label\": row['treatment_month'], \"amount\": amount})\n\ndata.append({\"label\": \"End\", \"amount\": 0})\n\nsource = pd.DataFrame(data)\namount = alt.datum.amount\nlabel = alt.datum.label\nwindow_lead_label = alt.datum.window_lead_label\nwindow_sum_amount = alt.datum.window_sum_amount\ncalc_prev_sum = alt.expr.if_(label == \"End\", 0, window_sum_amount - amount)\ncalc_amount = alt.expr.if_(label == \"End\", window_sum_amount, amount)\ncalc_text_amount = (\n    alt.expr.if_((label != \"Start\") & (label != \"End\") & calc_amount > 0, \"+\", \"\")\n    + calc_amount\n)\n\nbase_chart = alt.Chart(source).transform_window(\n    window_sum_amount=\"sum(amount)\",\n    window_lead_label=\"lead(label)\",\n).transform_calculate(\n    calc_lead=alt.expr.if_((window_lead_label == None), label, window_lead_label),\n    calc_prev_sum=calc_prev_sum,\n    calc_amount=calc_amount,\n    calc_text_amount=calc_text_amount,\n    calc_center=(window_sum_amount + calc_prev_sum) / 2,\n    calc_sum_dec=alt.expr.if_(window_sum_amount < calc_prev_sum, window_sum_amount, \"\"),\n    calc_sum_inc=alt.expr.if_(window_sum_amount > calc_prev_sum, window_sum_amount, \"\"),\n).encode(\n    x=alt.X(\"label:O\", axis=alt.Axis(title=\"Months\", labelAngle=45), sort=None)\n)\n\ncolor_coding = (\n    alt.when((label == \"Start\") | (label == \"End\"))\n    .then(alt.value(\"#878d96\"))\n    .when(calc_amount < 0)\n    .then(alt.value(\"#24a148\"))\n    .otherwise(alt.value(\"#fa4d56\"))\n)\n\nbar = base_chart.mark_bar(size=45).encode(\n    y=alt.Y(\"calc_prev_sum:Q\", title=\"Cost of Treatment\"),\n    y2=alt.Y2(\"window_sum_amount:Q\"),\n    color=color_coding,\n)\n\nrule = base_chart.mark_rule(xOffset=-22.5, x2Offset=22.5).encode(\n    y=\"window_sum_amount:Q\",\n    x2=\"calc_lead\",\n)\n\ntext_pos_values_top_of_bar = base_chart.mark_text(baseline=\"bottom\", dy=-4).encode(\n    text=alt.Text(\"calc_sum_inc:N\"),\n    y=\"calc_sum_inc:Q\",\n)\ntext_neg_values_bot_of_bar = base_chart.mark_text(baseline=\"top\", dy=4).encode(\n    text=alt.Text(\"calc_sum_dec:N\"),\n    y=\"calc_sum_dec:Q\",\n)\ntext_bar_values_mid_of_bar = base_chart.mark_text(baseline=\"middle\").encode(\n    text=alt.Text(\"calc_text_amount:N\"),\n    y=\"calc_center:Q\",\n    color=alt.value(\"white\"),\n)\n\nalt.layer(\n    bar,\n    rule,\n    text_pos_values_top_of_bar,\n    text_neg_values_bot_of_bar,\n    text_bar_values_mid_of_bar\n).properties(\n    width=800,\n    height=450\n)",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___waterfall_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "dog_kennels",
        "chart_category": "Advanced Calculations",
        "chart_type": "waterfall_chart",
        "NLQ": "Can you create a waterfall chart showing the monthly cost of dog treatments from our kennel database? I'd like to use Altair instead of Matplotlib, and pull the data directly from our SQLite database. Keep the same style with red bars for increases and green bars for decreases, and gray bars for the start and end. Make the chart wider and taller, and rotate the month labels by 45 degrees so they're easier to read. The y-axis should be labeled \"Cost of Treatment\" instead of just \"Amount\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/dog_kennels.sqlite')\n\nquery = \"\"\"\nSELECT\n    STRFTIME('%Y-%m', date_of_treatment) AS treatment_month,\n    SUM(cost_of_treatment) AS monthly_cost\nFROM Treatments\nGROUP BY treatment_month\nORDER BY treatment_month;\n\"\"\"\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndata = []\ntotal_cost = 0\ndata.append({\"label\": \"Start\", \"amount\": 0})\n\nfor index, row in df.iterrows():\n    amount = row['monthly_cost']\n    total_cost += amount\n    data.append({\"label\": row['treatment_month'], \"amount\": amount})\n\ndata.append({\"label\": \"End\", \"amount\": 0})\n\nsource = pd.DataFrame(data)\n\namount = alt.datum.amount\nlabel = alt.datum.label\nwindow_lead_label = alt.datum.window_lead_label\nwindow_sum_amount = alt.datum.window_sum_amount\n\ncalc_prev_sum = alt.expr.if_(label == \"End\", 0, window_sum_amount - amount)\ncalc_amount = alt.expr.if_(label == \"End\", window_sum_amount, amount)\ncalc_text_amount = (\n    alt.expr.if_((label != \"Start\") & (label != \"End\") & calc_amount > 0, \"+\", \"\")\n    + calc_amount\n)\n\nbase_chart = alt.Chart(source).transform_window(\n    window_sum_amount=\"sum(amount)\",\n    window_lead_label=\"lead(label)\",\n).transform_calculate(\n    calc_lead=alt.expr.if_((window_lead_label == None), label, window_lead_label),\n    calc_prev_sum=calc_prev_sum,\n    calc_amount=calc_amount,\n    calc_text_amount=calc_text_amount,\n    calc_center=(window_sum_amount + calc_prev_sum) / 2,\n    calc_sum_dec=alt.expr.if_(window_sum_amount < calc_prev_sum, window_sum_amount, \"\"),\n    calc_sum_inc=alt.expr.if_(window_sum_amount > calc_prev_sum, window_sum_amount, \"\"),\n).encode(\n    x=alt.X(\"label:O\", axis=alt.Axis(title=\"Months\", labelAngle=45), sort=None)\n)\n\ncolor_coding = (\n    alt.when((label == \"Start\") | (label == \"End\"))\n    .then(alt.value(\"#878d96\"))\n    .when(calc_amount < 0)\n    .then(alt.value(\"#24a148\"))\n    .otherwise(alt.value(\"#fa4d56\"))\n)\n\nbar = base_chart.mark_bar(size=45).encode(\n    y=alt.Y(\"calc_prev_sum:Q\", title=\"Cost of Treatment\"),\n    y2=alt.Y2(\"window_sum_amount:Q\"),\n    color=color_coding,\n)\n\nrule = base_chart.mark_rule(xOffset=-22.5, x2Offset=22.5).encode(\n    y=\"window_sum_amount:Q\",\n    x2=\"calc_lead\",\n)\n\ntext_pos_values_top_of_bar = base_chart.mark_text(baseline=\"bottom\", dy=-4).encode(\n    text=alt.Text(\"calc_sum_inc:N\"),\n    y=\"calc_sum_inc:Q\",\n)\ntext_neg_values_bot_of_bar = base_chart.mark_text(baseline=\"top\", dy=4).encode(\n    text=alt.Text(\"calc_sum_dec:N\"),\n    y=\"calc_sum_dec:Q\",\n)\ntext_bar_values_mid_of_bar = base_chart.mark_text(baseline=\"middle\").encode(\n    text=alt.Text(\"calc_text_amount:N\"),\n    y=\"calc_center:Q\",\n    color=alt.value(\"white\"),\n)\n\nalt.layer(\n    bar,\n    rule,\n    text_pos_values_top_of_bar,\n    text_neg_values_bot_of_bar,\n    text_bar_values_mid_of_bar\n).properties(\n    width=800,\n    height=450\n)",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___waterfall_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "dorm_1",
        "chart_category": "Advanced Calculations",
        "chart_type": "waterfall_chart",
        "NLQ": "Can you create a waterfall chart showing the student capacity for each dormitory? I want to see how each dorm contributes to the total capacity, starting from zero and building up to the final total. Please get the data from our dorm database, sort the dorms by capacity, and make the chart wider and taller. Add a title \"Cumulative Student Capacity Across Dormitories\" at the top. Label the x-axis as \"Dormitory\" and angle the labels so they're easier to read, and label the y-axis as \"Student Capacity\". Make the bars thicker and add white text inside them to show the capacity values. I'd like to keep the same color scheme where increases are red and the start/total bars are gray.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/dorm_1.sqlite')\nquery = '''\nSELECT dorm_name, student_capacity\nFROM Dorm\nORDER BY student_capacity;\n'''\ndf_dorm = pd.read_sql_query(query, conn)\nconn.close()\n\ndata = []\ndata.append({\"label\": \"Start\", \"amount\": 0})\nfor index, row in df_dorm.iterrows():\n    data.append({\"label\": row['dorm_name'], \"amount\": row['student_capacity']})\ntotal_capacity = df_dorm['student_capacity'].sum()\ndata.append({\"label\": \"Total\", \"amount\": total_capacity})\n\nsource = pd.DataFrame(data)\n\namount = alt.datum.amount\nlabel = alt.datum.label\nwindow_lead_label = alt.datum.window_lead_label\nwindow_sum_amount = alt.datum.window_sum_amount\n\ncalc_prev_sum = alt.expr.if_(label == \"Total\", 0, window_sum_amount - amount)\ncalc_amount = alt.expr.if_(label == \"Total\", window_sum_amount, amount)\ncalc_text_amount = (\n    alt.expr.if_((label != \"Start\") & (label != \"Total\") & calc_amount > 0, \"+\", \"\") + calc_amount\n)\n\nbase_chart = alt.Chart(source).transform_window(\n    window_sum_amount=\"sum(amount)\", window_lead_label=\"lead(label)\"\n).transform_calculate(\n    calc_lead=alt.expr.if_((window_lead_label == None), label, window_lead_label),\n    calc_prev_sum=calc_prev_sum,\n    calc_amount=calc_amount,\n    calc_text_amount=calc_text_amount,\n    calc_center=(window_sum_amount + calc_prev_sum) / 2,\n    calc_sum_dec=alt.expr.if_(window_sum_amount < calc_prev_sum, window_sum_amount, \"\"),\n    calc_sum_inc=alt.expr.if_(window_sum_amount > calc_prev_sum, window_sum_amount, \"\"),\n).encode(\n    x=alt.X(\"label:O\", axis=alt.Axis(title=\"Dormitory\", labelAngle=45), sort=None)\n)\n\ncolor_coding = (\n    alt.when((label == \"Start\") | (label == \"Total\"))\n    .then(alt.value(\"#878d96\"))\n    .when(calc_amount < 0)\n    .then(alt.value(\"#24a148\"))\n    .otherwise(alt.value(\"#fa4d56\"))\n)\n\nbar = base_chart.mark_bar(size=45).encode(\n    y=alt.Y(\"calc_prev_sum:Q\", title=\"Student Capacity\"),\n    y2=alt.Y2(\"window_sum_amount:Q\"),\n    color=color_coding,\n)\n\nrule = base_chart.mark_rule(xOffset=-22.5, x2Offset=22.5).encode(\n    y=\"window_sum_amount:Q\",\n    x2=\"calc_lead\",\n)\n\ntext_pos_values_top_of_bar = base_chart.mark_text(baseline=\"bottom\", dy=-4).encode(\n    text=alt.Text(\"calc_sum_inc:N\"),\n    y=\"calc_sum_inc:Q\",\n)\ntext_neg_values_bot_of_bar = base_chart.mark_text(baseline=\"top\", dy=4).encode(\n    text=alt.Text(\"calc_sum_dec:N\"),\n    y=\"calc_sum_dec:Q\",\n)\ntext_bar_values_mid_of_bar = base_chart.mark_text(baseline=\"middle\").encode(\n    text=alt.Text(\"calc_text_amount:N\"),\n    y=\"calc_center:Q\",\n    color=alt.value(\"white\"),\n)\n\nchart = alt.layer(\n    bar,\n    rule,\n    text_pos_values_top_of_bar,\n    text_neg_values_bot_of_bar,\n    text_bar_values_mid_of_bar\n).properties(\n    title='Cumulative Student Capacity Across Dormitories',\n    width=800,\n    height=450\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___waterfall_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "dorm_1",
        "chart_category": "Advanced Calculations",
        "chart_type": "waterfall_chart",
        "NLQ": "Can you create a waterfall chart showing the cumulative student capacity across all dormitories from our database? I'd like to see how each dorm contributes to the total capacity, starting from zero and ending with the total sum. Please title it \"Cumulative Student Capacity Across Dormitories\" and make it wider (about 800px) and taller (about 450px) than the original chart. Use red for increasing values and green for decreasing values, with gray for the start and total bars. Also, can you angle the dormitory labels by 45 degrees so they're easier to read if the names are long?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/dorm_1.sqlite')\nquery = '''\nSELECT dorm_name, student_capacity\nFROM Dorm\nORDER BY student_capacity;\n'''\ndf_dorm = pd.read_sql_query(query, conn)\nconn.close()\n\ndata = []\ndata.append({\"label\": \"Start\", \"amount\": 0})\nfor index, row in df_dorm.iterrows():\n    data.append({\"label\": row['dorm_name'], \"amount\": row['student_capacity']})\ntotal_capacity = df_dorm['student_capacity'].sum()\ndata.append({\"label\": \"Total\", \"amount\": total_capacity})\n\nsource = pd.DataFrame(data)\n\namount = alt.datum.amount\nlabel = alt.datum.label\nwindow_lead_label = alt.datum.window_lead_label\nwindow_sum_amount = alt.datum.window_sum_amount\n\ncalc_prev_sum = alt.expr.if_(label == \"Total\", 0, window_sum_amount - amount)\ncalc_amount = alt.expr.if_(label == \"Total\", window_sum_amount, amount)\ncalc_text_amount = (\n    alt.expr.if_((label != \"Start\") & (label != \"Total\") & calc_amount > 0, \"+\", \"\")\n    + calc_amount\n)\n\nbase_chart = alt.Chart(source).transform_window(\n    window_sum_amount=\"sum(amount)\",\n    window_lead_label=\"lead(label)\",\n).transform_calculate(\n    calc_lead=alt.expr.if_((window_lead_label == None), label, window_lead_label),\n    calc_prev_sum=calc_prev_sum,\n    calc_amount=calc_amount,\n    calc_text_amount=calc_text_amount,\n    calc_center=(window_sum_amount + calc_prev_sum) / 2,\n    calc_sum_dec=alt.expr.if_(window_sum_amount < calc_prev_sum, window_sum_amount, \"\"),\n    calc_sum_inc=alt.expr.if_(window_sum_amount > calc_prev_sum, window_sum_amount, \"\"),\n).encode(\n    x=alt.X(\"label:O\", axis=alt.Axis(title=\"Dormitory\", labelAngle=45), sort=None)\n)\n\ncolor_coding = (\n    alt.when((label == \"Start\") | (label == \"Total\"))\n    .then(alt.value(\"#878d96\"))\n    .when(calc_amount < 0)\n    .then(alt.value(\"#24a148\"))\n    .otherwise(alt.value(\"#fa4d56\"))\n)\n\nbar = base_chart.mark_bar(size=45).encode(\n    y=alt.Y(\"calc_prev_sum:Q\", title=\"Student Capacity\"),\n    y2=alt.Y2(\"window_sum_amount:Q\"),\n    color=color_coding,\n)\n\nrule = base_chart.mark_rule(xOffset=-22.5, x2Offset=22.5).encode(\n    y=\"window_sum_amount:Q\",\n    x2=\"calc_lead\",\n)\n\ntext_pos_values_top_of_bar = base_chart.mark_text(baseline=\"bottom\", dy=-4).encode(\n    text=alt.Text(\"calc_sum_inc:N\"),\n    y=\"calc_sum_inc:Q\",\n)\ntext_neg_values_bot_of_bar = base_chart.mark_text(baseline=\"top\", dy=4).encode(\n    text=alt.Text(\"calc_sum_dec:N\"),\n    y=\"calc_sum_dec:Q\",\n)\ntext_bar_values_mid_of_bar = base_chart.mark_text(baseline=\"middle\").encode(\n    text=alt.Text(\"calc_text_amount:N\"),\n    y=\"calc_center:Q\",\n    color=alt.value(\"white\"),\n)\n\nchart = alt.layer(\n    bar,\n    rule,\n    text_pos_values_top_of_bar,\n    text_neg_values_bot_of_bar,\n    text_bar_values_mid_of_bar\n).properties(\n    title='Cumulative Student Capacity Across Dormitories',\n    width=800,\n    height=450\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___waterfall_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "dorm_1",
        "chart_category": "Distributions",
        "chart_type": "heat_lane_chart",
        "NLQ": "Can you create a chart showing the distribution of student ages across different dorms? I'd like to see the dorm names listed on the y-axis and student ages on the x-axis. Please use a blue color scheme and make the bars have rounded corners to look nicer. Add a clear title like \"Distribution of Student Ages Across Dorm Capacities\" and keep the chart relatively wide but not too tall. Also, can you make sure the axis labels are clear, with \"Dorm Name\" and \"Student Age\" properly labeled?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/dorm_1.sqlite')\nquery = '''\nSELECT \n    Dorm.dorm_name AS dorm_name,\n    Dorm.student_capacity AS capacity,\n    Student.Age AS age\nFROM \n    Lives_in\nJOIN \n    Student ON Lives_in.stuid = Student.StuID\nJOIN \n    Dorm ON Lives_in.dormid = Dorm.dormid\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, title=\"Distribution of Student Ages Across Dorm Capacities\", height=100, width=400).encode(\n    alt.X(\"bin_Age_start:Q\").title(\"Student Age\").axis(grid=False),\n    alt.X2(\"bin_Age_end:Q\"),\n    alt.Y(\"dorm_name:N\").title(\"Dorm Name\"),\n    alt.Y2(\"y2\"),\n).transform_bin(\n    [\"bin_Age_start\", \"bin_Age_end\"],\n    field='age'\n).transform_aggregate(\n    count='count()',\n    groupby=[\"bin_Age_start\", \"bin_Age_end\", \"dorm_name\"]\n).transform_bin(\n    [\"bin_count_start\", \"bin_count_end\"],\n    field='count'\n).transform_calculate(\n    y=\"datum.bin_count_end/2\",\n    y2=\"-datum.bin_count_end/2\",\n).transform_joinaggregate(\n    max_bin_count_end=\"max(bin_count_end)\",\n)\n\nlayer1 = chart.mark_bar(xOffset=1, x2Offset=-1, cornerRadius=3).encode(\n    alt.Color(\"max_bin_count_end:O\").title(\"Number of Students\").scale(scheme=\"lighttealblue\")\n)\nlayer2 = chart.mark_bar(xOffset=1, x2Offset=-1, yOffset=-3, y2Offset=3).encode(\n    alt.Color(\"bin_count_end:O\").title(\"Number of Students\")\n)\n\nlayer1 + layer2",
        "reference_path": "./vis_bench/code/altair/Distributions___heat_lane_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "dorm_1",
        "chart_category": "Distributions",
        "chart_type": "heat_lane_chart",
        "NLQ": "Instead of that histogram of horsepower data, could you create a chart showing how student ages are distributed across different dorms? I'd like to see the dorm names listed along the y-axis with horizontal bars showing the age ranges. Use a blue color scheme to show the number of students in each age group, with darker colors indicating more students. Make sure to include a clear title like \"Distribution of Student Ages Across Dorm Capacities\" and pull the data from our dorm database instead of using random numbers. Can you also add some rounded corners to the bars to make it look nicer?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/dorm_1.sqlite')\n\nquery = '''\nSELECT \n    Dorm.dorm_name AS dorm_name,\n    Dorm.student_capacity AS capacity,\n    Student.Age AS age\nFROM \n    Lives_in\nJOIN \n    Student ON Lives_in.stuid = Student.StuID\nJOIN \n    Dorm ON Lives_in.dormid = Dorm.dormid\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df, title=\"Distribution of Student Ages Across Dorm Capacities\", height=100, width=400).encode(\n    alt.X(\"bin_Age_start:Q\")\n        .title(\"Student Age\")\n        .axis(grid=False),\n    alt.X2(\"bin_Age_end:Q\"),\n    alt.Y(\"dorm_name:N\").title(\"Dorm Name\"),\n    alt.Y2(\"y2\"),\n).transform_bin(\n    [\"bin_Age_start\", \"bin_Age_end\"],\n    field='age'\n).transform_aggregate(\n    count='count()',\n    groupby=[\"bin_Age_start\", \"bin_Age_end\", \"dorm_name\"]\n).transform_bin(\n    [\"bin_count_start\", \"bin_count_end\"],\n    field='count'\n).transform_calculate(\n    y=\"datum.bin_count_end/2\",\n    y2=\"-datum.bin_count_end/2\",\n).transform_joinaggregate(\n    max_bin_count_end=\"max(bin_count_end)\",\n)\n\nlayer1 = chart.mark_bar(xOffset=1, x2Offset=-1, cornerRadius=3).encode(\n    alt.Color(\"max_bin_count_end:O\")\n        .title(\"Number of Students\")\n        .scale(scheme=\"lighttealblue\")\n)\nlayer2 = chart.mark_bar(xOffset=1, x2Offset=-1, yOffset=-3, y2Offset=3).encode(\n    alt.Color(\"bin_count_end:O\").title(\"Number of Students\")\n)\n\nlayer1 + layer2",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___heat_lane_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "dorm_1",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_sequence_generator",
        "NLQ": "I have a database with information about students living in dorms. Can you create a line chart that shows how the number of students in each dorm changes over time? I'd like to have separate lines for each dorm, and color them based on whether they're male or female dorms. The x-axis should show time intervals from 0 to 10 in half-step increments, and the y-axis should show the student count. Instead of using the sine and cosine data from your example, please connect to my SQLite database called 'dorm_1.sqlite' and use the dorm information stored there.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/dorm_1.sqlite')\n\nquery = '''\nSELECT \n    T2.dorm_name AS dorm_name,\n    T2.gender AS gender,\n    COUNT(T1.stuid) AS student_count\nFROM \n    Lives_in AS T1\nJOIN \n    Dorm AS T2 ON T1.dormid = T2.dormid\nGROUP BY \n    T2.dorm_name, T2.gender\nORDER BY \n    T2.gender, T2.dorm_name;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ntime_sequence = alt.sequence(start=0, stop=10, step=0.5, as_='time')\n\nchart = alt.Chart(time_sequence).mark_line().transform_calculate(\n    student_count_simulated=f'datum.time * {df[\"student_count\"].mean()}'\n).transform_fold(\n    ['student_count_simulated']\n).encode(\n    x='time:Q',\n    y='value:Q',\n    color='gender:N',\n    detail='dorm_name:N'\n).transform_lookup(\n    lookup='dorm_name',\n    from_=alt.LookupData(data=df, key='dorm_name', fields=['gender', 'student_count'])\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_sequence_generator.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "dorm_1",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_sequence_generator",
        "NLQ": "Instead of the simple sine and cosine wave graph, I want to create a line chart that shows how the number of students in each dorm changes over time. I need to pull this data from my SQLite database that has information about dorms and students. Can you make separate lines for each dorm and color-code them based on whether they're male or female dorms? I'd like to use Altair for this visualization instead of matplotlib.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/dorm_1.sqlite')\n\nquery = '''\nSELECT \n    T2.dorm_name AS dorm_name,\n    T2.gender AS gender,\n    COUNT(T1.stuid) AS student_count\nFROM \n    Lives_in AS T1\nJOIN \n    Dorm AS T2 ON T1.dormid = T2.dormid\nGROUP BY \n    T2.dorm_name, T2.gender\nORDER BY \n    T2.gender, T2.dorm_name;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ntime_sequence = alt.sequence(start=0, stop=10, step=0.5, as_='time')\n\nchart = alt.Chart(time_sequence).mark_line().transform_calculate(\n    student_count_simulated=f'datum.time * {df[\"student_count\"].mean()}'\n).transform_fold(\n    ['student_count_simulated']\n).encode(\n    x='time:Q',\n    y='value:Q',\n    color='gender:N',\n    detail='dorm_name:N'\n).transform_lookup(\n    lookup='dorm_name',\n    from_=alt.LookupData(data=df, key='dorm_name', fields=['gender', 'student_count'])\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_sequence_generator.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "driving_school",
        "chart_category": "Advanced Calculations",
        "chart_type": "wilkinson_dot_plot",
        "NLQ": "Can you create a chart showing the distribution of lesson prices for different vehicle types from our driving school database? I'd like to see dots representing each price point, with different colors for each vehicle type. Please add a title \"Distribution of Lesson Prices by Vehicle Type\" and label the x-axis as \"Lesson Price\". Make the chart shorter in height, about 100 pixels, and keep the dots fully opaque.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/driving_school.sqlite')\n\nquery = '''\nSELECT V.vehicle_details AS vehicle_type, L.price\nFROM Lessons AS L\nJOIN Vehicles AS V ON L.vehicle_id = V.vehicle_id\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df, height=100).mark_circle(opacity=1).transform_window(\n    id='rank()',\n    groupby=['vehicle_type', 'price']\n).encode(\n    alt.X('price:Q', title='Lesson Price'),\n    alt.Y('id:O').axis(None).sort('descending'),\n    alt.Color('vehicle_type:N', title='Vehicle Type')\n).properties(\n    title='Distribution of Lesson Prices by Vehicle Type'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___wilkinson_dot_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "driving_school",
        "chart_category": "Advanced Calculations",
        "chart_type": "wilkinson_dot_plot",
        "NLQ": "Can you create a chart showing the distribution of lesson prices for different vehicle types from our driving school database? I'd like to see dots stacked vertically for each price point, with different colors representing each vehicle type. Please add a title \"Distribution of Lesson Prices by Vehicle Type\" and label the x-axis as \"Lesson Price\". Make sure the dots are fully visible (not transparent) and the chart is about 100 pixels tall.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/driving_school.sqlite')\n\nquery = '''\nSELECT V.vehicle_details AS vehicle_type, L.price\nFROM Lessons AS L\nJOIN Vehicles AS V ON L.vehicle_id = V.vehicle_id\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, height=100).mark_circle(opacity=1).transform_window(\n    id='rank()',\n    groupby=['vehicle_type', 'price']\n).encode(\n    alt.X('price:Q', title='Lesson Price'),\n    alt.Y('id:O').axis(None).sort('descending'),\n    alt.Color('vehicle_type:N', title='Vehicle Type')\n).properties(\n    title='Distribution of Lesson Prices by Vehicle Type'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___wilkinson_dot_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "driving_school",
        "chart_category": "Distributions",
        "chart_type": "heat_lane_chart",
        "NLQ": "Can you create a chart showing the distribution of lesson prices by vehicle type from our driving school database? I'd like to see horizontal bars grouped by vehicle type instead of the vertical bars in the example. Make the chart more compact with a height of 100px and width of 300px, and add a title \"Distribution of Lesson Prices by Vehicle Type\". Use a light teal-blue color scheme instead of the default colors, add rounded corners to the bars, and label the x-axis as \"Lesson Price\" and y-axis as \"Vehicle Type\". Also, can you remove the grid lines and add a legend titled \"Number of Lessons\"?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/driving_school.sqlite')\n\nquery = '''\nSELECT \n    Vehicles.vehicle_details AS vehicle_type, \n    Lessons.price AS lesson_price\nFROM \n    Lessons\nJOIN \n    Vehicles ON Lessons.vehicle_id = Vehicles.vehicle_id\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, title=\"Distribution of Lesson Prices by Vehicle Type\", height=100, width=300).encode(\n    alt.X(\"bin_price_start:Q\")\n        .title(\"Lesson Price\")\n        .axis(grid=False),\n    alt.X2(\"bin_price_end:Q\"),\n    alt.Y(\"vehicle_type:N\").title(\"Vehicle Type\"),\n    alt.Y2(\"y2\"),\n).transform_bin(\n    [\"bin_price_start\", \"bin_price_end\"],\n    field='lesson_price',\n    bin=alt.Bin(maxbins=20)\n).transform_aggregate(\n    count='count()',\n    groupby=[\"vehicle_type\", \"bin_price_start\", \"bin_price_end\"]\n).transform_bin(\n    [\"bin_count_start\", \"bin_count_end\"],\n    field='count'\n).transform_calculate(\n    y=\"datum.bin_count_end/2\",\n    y2=\"-datum.bin_count_end/2\",\n).transform_joinaggregate(\n    max_bin_count_end=\"max(bin_count_end)\",\n    groupby=[\"vehicle_type\"]\n)\n\nlayer1 = chart.mark_bar(xOffset=1, x2Offset=-1, cornerRadius=3).encode(\n    alt.Color(\"max_bin_count_end:O\")\n        .title(\"Number of Lessons\")\n        .scale(scheme=\"lighttealblue\")\n)\nlayer2 = chart.mark_bar(xOffset=1, x2Offset=-1, yOffset=-3, y2Offset=3).encode(\n    alt.Color(\"bin_count_end:O\").title(\"Number of Lessons\")\n)\n\nlayer1 + layer2",
        "reference_path": "./vis_bench/code/altair/Distributions___heat_lane_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "driving_school",
        "chart_category": "Distributions",
        "chart_type": "heat_lane_chart",
        "NLQ": "I'd like to change my chart to show lesson prices for different vehicle types from our driving school database. Instead of the histogram I have now, can you create a horizontal bar chart where each vehicle type has its own row? Make the bars show price ranges, and use different shades of blue to indicate how many lessons fall into each price range. Please add a clear title \"Distribution of Lesson Prices by Vehicle Type\" and label the axes properly. The chart should be wider than it is tall - about 300 pixels wide and 100 pixels high.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/driving_school.sqlite')\n\nquery = '''\nSELECT \n    Vehicles.vehicle_details AS vehicle_type, \n    Lessons.price AS lesson_price\nFROM \n    Lessons\nJOIN \n    Vehicles ON Lessons.vehicle_id = Vehicles.vehicle_id\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, title=\"Distribution of Lesson Prices by Vehicle Type\", height=100, width=300).encode(\n    alt.X(\"bin_price_start:Q\")\n        .title(\"Lesson Price\")\n        .axis(grid=False),\n    alt.X2(\"bin_price_end:Q\"),\n    alt.Y(\"vehicle_type:N\").title(\"Vehicle Type\"),\n    alt.Y2(\"y2\"),\n).transform_bin(\n    [\"bin_price_start\", \"bin_price_end\"],\n    field='lesson_price',\n    bin=alt.Bin(maxbins=20)\n).transform_aggregate(\n    count='count()',\n    groupby=[\"vehicle_type\", \"bin_price_start\", \"bin_price_end\"]\n).transform_bin(\n    [\"bin_count_start\", \"bin_count_end\"],\n    field='count'\n).transform_calculate(\n    y=\"datum.bin_count_end/2\",\n    y2=\"-datum.bin_count_end/2\",\n).transform_joinaggregate(\n    max_bin_count_end=\"max(bin_count_end)\",\n    groupby=[\"vehicle_type\"]\n)\n\nlayer1 = chart.mark_bar(xOffset=1, x2Offset=-1, cornerRadius=3).encode(\n    alt.Color(\"max_bin_count_end:O\")\n        .title(\"Number of Lessons\")\n        .scale(scheme=\"lighttealblue\")\n)\nlayer2 = chart.mark_bar(xOffset=1, x2Offset=-1, yOffset=-3, y2Offset=3).encode(\n    alt.Color(\"bin_count_end:O\").title(\"Number of Lessons\")\n)\n\nlayer1 + layer2",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___heat_lane_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "election",
        "chart_category": "Advanced Calculations",
        "chart_type": "wilkinson_dot_plot",
        "NLQ": "Can you help me create a chart like the one in my code, but instead of using my sample data, I want to show election data from my database? I'd like to display political parties along the bottom axis with a proper title, and have dots stacked vertically to represent the number of delegates for each party. Please make sure the dots are fully visible without any transparency.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/election.sqlite')\n\nquery = '''\nSELECT p.Party, COUNT(e.Delegate) AS Delegate_Count\nFROM election AS e\nJOIN party AS p ON e.Party = p.Party_ID\nGROUP BY p.Party\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle(opacity=1).transform_window(\n    id='rank()',\n    groupby=['Party']\n).encode(\n    alt.X('Party:N', title='Political Party'),\n    alt.Y('id:O').axis(None).sort('descending')\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___wilkinson_dot_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "election",
        "chart_category": "Advanced Calculations",
        "chart_type": "wilkinson_dot_plot",
        "NLQ": "Can you help me create a chart like the one in my code, but instead of using my sample data, I want to use election data from a database? I'd like to show political parties along the bottom axis with dots stacked vertically to represent the number of delegates for each party. Please label the x-axis as \"Political Party\" and make sure the chart is clear and easy to read.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/election.sqlite')\n\nquery = '''\nSELECT p.Party, COUNT(e.Delegate) AS Delegate_Count\nFROM election AS e\nJOIN party AS p ON e.Party = p.Party_ID\nGROUP BY p.Party\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle(opacity=1).transform_window(\n    id='rank()',\n    groupby=['Party']\n).encode(\n    alt.X('Party:N', title='Political Party'),\n    alt.Y('id:O').axis(None).sort('descending')\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___wilkinson_dot_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "election",
        "chart_category": "Distributions",
        "chart_type": "heat_lane_chart",
        "NLQ": "Can you create a chart showing the population distribution by zip code? I'd like to see how many counties fall into different population ranges for each zip code. Make it a horizontal bar chart with zip codes on the y-axis and population ranges on the x-axis. Use a light teal-blue color scheme for the bars and make them have slightly rounded corners. Add a title \"Population Distribution by Zip Code\" and proper axis labels. Can you also make the chart more compact - about 300 pixels wide and 100 pixels tall? Oh, and please pull the data from my election database instead of using random data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/election.sqlite')\n\nquery = '''\nSELECT Zip_code, Population\nFROM county\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df, title=\"Population Distribution by Zip Code\", height=100, width=300).encode(\n    alt.X(\"bin_Population_start:Q\")\n        .title(\"Population\")\n        .axis(grid=False),\n    alt.X2(\"bin_Population_end:Q\"),\n    alt.Y(\"Zip_code:N\").title(\"Zip Code\"),\n).transform_bin(\n    [\"bin_Population_start\", \"bin_Population_end\"],\n    field='Population',\n    bin=alt.Bin(maxbins=20)\n).transform_aggregate(\n    count='count()',\n    groupby=[\"Zip_code\", \"bin_Population_start\", \"bin_Population_end\"]\n).transform_calculate(\n    y_offset=\"datum.count / 2\",\n    y2_offset=\"-datum.count / 2\",\n).mark_bar(xOffset=1, x2Offset=-1, cornerRadius=3).encode(\n    alt.Color(\"count:Q\")\n        .title(\"Number of Counties\")\n        .scale(scheme=\"lighttealblue\")\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___heat_lane_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "election",
        "chart_category": "Distributions",
        "chart_type": "heat_lane_chart",
        "NLQ": "Instead of the histogram with horsepower data, can you create a chart that shows population distribution by zip code? I'd like to see how many counties fall into different population ranges for each zip code. Please pull this data from our election database. Make the chart have a nice blue color scheme with rounded corners on the bars, and add a clear title \"Population Distribution by Zip Code\". Can you also make sure the x-axis shows population and the y-axis shows zip codes? I want it to be compact, about 300 pixels wide and 100 pixels tall.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/election.sqlite')\n\nquery = '''\nSELECT Zip_code, Population\nFROM county\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df, title=\"Population Distribution by Zip Code\", height=100, width=300).encode(\n    alt.X(\"bin_Population_start:Q\")\n        .title(\"Population\")\n        .axis(grid=False),\n    alt.X2(\"bin_Population_end:Q\"),\n    alt.Y(\"Zip_code:N\").title(\"Zip Code\"),\n).transform_bin(\n    [\"bin_Population_start\", \"bin_Population_end\"],\n    field='Population',\n    bin=alt.Bin(maxbins=20)\n).transform_aggregate(\n    count='count()',\n    groupby=[\"Zip_code\", \"bin_Population_start\", \"bin_Population_end\"]\n).transform_calculate(\n    y_offset=\"datum.count / 2\",\n    y2_offset=\"-datum.count / 2\",\n).mark_bar(xOffset=1, x2Offset=-1, cornerRadius=3).encode(\n    alt.Color(\"count:Q\")\n        .title(\"Number of Counties\")\n        .scale(scheme=\"lighttealblue\")\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___heat_lane_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "election_representative",
        "chart_category": "Advanced Calculations",
        "chart_type": "wilkinson_dot_plot",
        "NLQ": "Can you create a chart that shows how many seats each political party has? I'd like to use dots stacked vertically to represent each seat, with different political parties shown across the horizontal axis. Please pull this data from our election database, showing the total seats by party, and order them from highest to lowest number of seats. Make the chart relatively short in height, and label the x-axis as \"Political Party\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/election_representative.sqlite')\nquery = '''\nSELECT r.Party, SUM(e.Seats) AS Total_Seats\nFROM election AS e\nJOIN representative AS r ON e.Representative_ID = r.Representative_ID\nGROUP BY r.Party\nORDER BY Total_Seats DESC\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndot_data = []\nfor _, row in df.iterrows():\n    dot_data.extend([row['Party']] * int(row['Total_Seats']))\n\ndot_df = pd.DataFrame({'Party': dot_data})\n\nchart = alt.Chart(dot_df, height=100).mark_circle(opacity=1).transform_window(\n    id='rank()',\n    groupby=['Party']\n).encode(\n    alt.X('Party:N', title='Political Party'),\n    alt.Y('id:O').axis(None).sort('descending')\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___wilkinson_dot_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "election_representative",
        "chart_category": "Advanced Calculations",
        "chart_type": "wilkinson_dot_plot",
        "NLQ": "Can you create a chart that shows how many seats each political party has? I'd like to use my election database to pull the total seats by party. Instead of the example I showed you, I want to display political parties on the x-axis with dots stacked vertically for each seat they hold. Please arrange the parties from highest to lowest number of seats and make sure the chart is clean with just the party names labeled at the bottom.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/election_representative.sqlite')\n\nquery = '''\nSELECT r.Party, SUM(e.Seats) AS Total_Seats\nFROM election AS e\nJOIN representative AS r ON e.Representative_ID = r.Representative_ID\nGROUP BY r.Party\nORDER BY Total_Seats DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndot_data = []\nfor _, row in df.iterrows():\n    dot_data.extend([row['Party']] * int(row['Total_Seats']))\n\ndot_df = pd.DataFrame({'Party': dot_data})\n\nchart = alt.Chart(dot_df, height=100).mark_circle(opacity=1).transform_window(\n    id='rank()',\n    groupby=['Party']\n).encode(\n    alt.X('Party:N', title='Political Party'),\n    alt.Y('id:O').axis(None).sort('descending')\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___wilkinson_dot_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "employee_hire_evaluation",
        "chart_category": "Area Charts",
        "chart_type": "area_chart_with_gradient",
        "NLQ": "Can you create an area chart showing the total bonuses awarded to employees from Bristol over the years? I'd like to pull this data from our employee database. Make the chart have a gradient fill from white at the top to dark blue at the bottom, with a dark blue outline. Please add a clear title that says \"Total Bonuses Awarded Over Years for Employees from Bristol\" and label the axes as \"Year\" and \"Total Bonus Awarded\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/employee_hire_evaluation.sqlite')\n\nquery = '''\nSELECT e.City, ev.Year_awarded, SUM(ev.Bonus) AS Total_Bonus\nFROM employee AS e\nJOIN evaluation AS ev ON e.Employee_ID = ev.Employee_ID\nWHERE e.City = 'Bristol'\nGROUP BY ev.Year_awarded\nORDER BY ev.Year_awarded\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_area(\n    line={'color': 'darkblue'},\n    color=alt.Gradient(\n        gradient='linear',\n        stops=[alt.GradientStop(color='white', offset=0),\n               alt.GradientStop(color='darkblue', offset=1)],\n        x1=1,\n        x2=1,\n        y1=1,\n        y2=0\n    )\n).encode(\n    alt.X('Year_awarded:T', title='Year'),\n    alt.Y('Total_Bonus:Q', title='Total Bonus Awarded')\n).properties(\n    title='Total Bonuses Awarded Over Years for Employees from Bristol'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Area Charts___area_chart_with_gradient.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "employee_hire_evaluation",
        "chart_category": "Area Charts",
        "chart_type": "area_chart_with_gradient",
        "NLQ": "Instead of showing the price data with a green area chart, can you create a chart that shows how the total bonuses awarded to employees from Bristol change over the years? I'd like to pull this data from our employee database. Can it have a smooth gradient that goes from white at the top to a dark blue at the bottom, with a dark blue line running through it? Also, please add a clear title that says \"Total Bonuses Awarded Over Years for Employees from Bristol\" and make sure the axis labels clearly show we're looking at years and total bonus amounts.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/employee_hire_evaluation.sqlite')\n\nquery = '''\nSELECT e.City, ev.Year_awarded, SUM(ev.Bonus) AS Total_Bonus\nFROM employee AS e\nJOIN evaluation AS ev ON e.Employee_ID = ev.Employee_ID\nWHERE e.City = 'Bristol'\nGROUP BY ev.Year_awarded\nORDER BY ev.Year_awarded\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_area(\n    line={'color': 'darkblue'},\n    color=alt.Gradient(\n        gradient='linear',\n        stops=[alt.GradientStop(color='white', offset=0),\n               alt.GradientStop(color='darkblue', offset=1)],\n        x1=1,\n        x2=1,\n        y1=1,\n        y2=0\n    )\n).encode(\n    alt.X('Year_awarded:T', title='Year'),\n    alt.Y('Total_Bonus:Q', title='Total Bonus Awarded')\n).properties(\n    title='Total Bonuses Awarded Over Years for Employees from Bristol'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Area Charts___area_chart_with_gradient.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "entertainment_awards",
        "chart_category": "Area Charts",
        "chart_type": "area_chart_with_gradient",
        "NLQ": "Can you create an area chart showing the total number of people attending festivals in the United States over the years? I'd like to use data from our entertainment awards database instead of the random stock price data. Make sure to label the x-axis as \"Year\" and the y-axis as \"Total Number of Audiences\". For the design, I want a gradient effect where the area starts white at the bottom and transitions to dark blue at the top, with a dark blue outline for the area.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/entertainment_awards.sqlite')\n\nquery = '''\nSELECT Year, SUM(Num_of_Audience) AS Total_Audience\nFROM festival_detail\nWHERE Location = 'United States'\nGROUP BY Year\nORDER BY Year\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_area(\n    line={'color': 'darkblue'},\n    color=alt.Gradient(\n        gradient='linear',\n        stops=[alt.GradientStop(color='white', offset=0),\n               alt.GradientStop(color='darkblue', offset=1)],\n        x1=1,\n        x2=1,\n        y1=1,\n        y2=0\n    )\n).encode(\n    alt.X('Year:T', title='Year'),\n    alt.Y('Total_Audience:Q', title='Total Number of Audiences')\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Area Charts___area_chart_with_gradient.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "entertainment_awards",
        "chart_category": "Area Charts",
        "chart_type": "area_chart_with_gradient",
        "NLQ": "Instead of showing the price data with a green area chart, can you create a chart that shows how the total number of people attending festivals in the United States has changed over the years? I'd like to use data from the entertainment_awards database. Also, please change the color scheme from green to a gradient that transitions from white to dark blue. Make sure to label the axes properly to show Year and Total Number of Audiences.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/entertainment_awards.sqlite')\n\nquery = '''\nSELECT Year, SUM(Num_of_Audience) AS Total_Audience\nFROM festival_detail\nWHERE Location = 'United States'\nGROUP BY Year\nORDER BY Year\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_area(\n    line={'color': 'darkblue'},\n    color=alt.Gradient(\n        gradient='linear',\n        stops=[alt.GradientStop(color='white', offset=0),\n               alt.GradientStop(color='darkblue', offset=1)],\n        x1=1,\n        x2=1,\n        y1=1,\n        y2=0\n    )\n).encode(\n    alt.X('Year:T', title='Year'),\n    alt.Y('Total_Audience:Q', title='Total Number of Audiences')\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Area Charts___area_chart_with_gradient.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "entrepreneur",
        "chart_category": "Area Charts",
        "chart_type": "area_chart_with_gradient",
        "NLQ": "Can you change this area chart to show data from my entrepreneur database instead of the random stock price data? I want to see the total money requested from Duncan Bannatyne based on entrepreneurs' birth dates. Make the area chart have a nice gradient from white to dark blue with a dark blue outline. Also, please label the x-axis as \"Date of Birth\" and the y-axis as \"Cumulative Money Requested\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/entrepreneur.sqlite')\n\nquery = '''\nSELECT \n    p.Date_of_Birth AS date,\n    e.Investor AS investor,\n    SUM(e.Money_Requested) AS total_money_requested\nFROM entrepreneur AS e\nJOIN people AS p ON e.People_ID = p.People_ID\nGROUP BY p.Date_of_Birth, e.Investor\nORDER BY p.Date_of_Birth\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_filter(\n    'datum.investor === \"Duncan Bannatyne\"'\n).mark_area(\n    line={'color': 'darkblue'},\n    color=alt.Gradient(\n        gradient='linear',\n        stops=[alt.GradientStop(color='white', offset=0),\n               alt.GradientStop(color='darkblue', offset=1)],\n        x1=1,\n        x2=1,\n        y1=1,\n        y2=0\n    )\n).encode(\n    alt.X('date:T', title='Date of Birth'),\n    alt.Y('total_money_requested:Q', title='Cumulative Money Requested')\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Area Charts___area_chart_with_gradient.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "entrepreneur",
        "chart_category": "Area Charts",
        "chart_type": "area_chart_with_gradient",
        "NLQ": "Can you change this green area chart to show data from our entrepreneur database instead? I want to see the total money requested from Duncan Bannatyne based on entrepreneurs' birth dates. Make it a dark blue gradient area chart that fades from white to dark blue, and update the axis labels to show \"Date of Birth\" and \"Cumulative Money Requested\" instead of just Date and Price.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/entrepreneur.sqlite')\n\nquery = '''\nSELECT \n    p.Date_of_Birth AS date,\n    e.Investor AS investor,\n    SUM(e.Money_Requested) AS total_money_requested\nFROM entrepreneur AS e\nJOIN people AS p ON e.People_ID = p.People_ID\nGROUP BY p.Date_of_Birth, e.Investor\nORDER BY p.Date_of_Birth\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_filter(\n    'datum.investor === \"Duncan Bannatyne\"'\n).mark_area(\n    line={'color': 'darkblue'},\n    color=alt.Gradient(\n        gradient='linear',\n        stops=[alt.GradientStop(color='white', offset=0),\n               alt.GradientStop(color='darkblue', offset=1)],\n        x1=1,\n        x2=1,\n        y1=1,\n        y2=0\n    )\n).encode(\n    alt.X('date:T', title='Date of Birth'),\n    alt.Y('total_money_requested:Q', title='Cumulative Money Requested')\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Area Charts___area_chart_with_gradient.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "entrepreneur",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_varying_size",
        "NLQ": "Can you change this chart to show how much money each investor has requested in total from the entrepreneur database? I'd like to keep the same trail visualization style where the thickness represents the amount, but instead of showing wheat production over years, I want to see the total money requested for each investor. Please pull this data directly from the entrepreneur.sqlite database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/entrepreneur.sqlite')\n\nquery = '''\nSELECT \n    Investor, \n    SUM(Money_Requested) AS Total_Money_Requested\nFROM \n    entrepreneur\nGROUP BY \n    Investor\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_trail().encode(\n    x='Investor:N',\n    y='Total_Money_Requested:Q',\n    size='Total_Money_Requested:Q'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_varying_size.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "entrepreneur",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_varying_size",
        "NLQ": "I have this chart showing wheat production over years with varying line thickness, but I'd like to create something similar using my entrepreneur database instead. Can you make a chart that shows how much money each investor has requested in total? I want to keep the idea of using thicker lines for bigger amounts, but display the investors on the x-axis and the total money requested on the y-axis. Please use the data from my entrepreneur database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/entrepreneur.sqlite')\n\nquery = '''\nSELECT \n    Investor, \n    SUM(Money_Requested) AS Total_Money_Requested\nFROM \n    entrepreneur\nGROUP BY \n    Investor\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_trail().encode(\n    x='Investor:N',\n    y='Total_Money_Requested:Q',\n    size='Total_Money_Requested:Q'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_varying_size.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "epinions_1",
        "chart_category": "Area Charts",
        "chart_type": "faceted_area_chart",
        "NLQ": "Can you create a chart showing how users' total ratings are distributed across different ranks? I'd like to see an area chart with each user having their own row, sorted by their total ratings from highest to lowest. Make sure to label the x-axis as \"Rank\" and the y-axis as \"Total Rating\", and include a color legend that identifies each user. Please pull this data from our epinions database instead of using the stock market data in my example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/epinions_1.sqlite')\n\nquery = '''\nSELECT \n    ua.name AS user_name,\n    r.rank AS rank,\n    SUM(r.rating) AS total_rating\nFROM \n    review AS r\nJOIN \n    useracct AS ua ON r.u_id = ua.u_id\nGROUP BY \n    ua.name, r.rank\nORDER BY \n    ua.name, r.rank\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_area().encode(\n    x=alt.X(\"rank:Q\", title=\"Rank\"),\n    y=alt.Y(\"total_rating:Q\", title=\"Total Rating\"),\n    color=alt.Color(\"user_name:N\", title=\"User\"),\n    row=alt.Row(\"user_name:N\", title=\"User\", sort=alt.EncodingSortField(field=\"total_rating\", op=\"sum\", order=\"descending\"))\n).properties(\n    height=50,\n    width=400\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Area Charts___faceted_area_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "epinions_1",
        "chart_category": "Area Charts",
        "chart_type": "faceted_area_chart",
        "NLQ": "Instead of showing stock prices over time for different companies, could you create a chart that shows how each user's total ratings change across different ranks? I'd like to see one section for each user, stacked vertically, with different colors to distinguish between users. Sort the users by their total ratings from highest to lowest. Also, can you pull this data from our SQLite database instead of using the stock dataset?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/epinions_1.sqlite')\n\nquery = '''\nSELECT \n    ua.name AS user_name,\n    r.rank AS rank,\n    SUM(r.rating) AS total_rating\nFROM \n    review AS r\nJOIN \n    useracct AS ua ON r.u_id = ua.u_id\nGROUP BY \n    ua.name, r.rank\nORDER BY \n    ua.name, r.rank\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_area().encode(\n    x=alt.X(\"rank:Q\", title=\"Rank\"),\n    y=alt.Y(\"total_rating:Q\", title=\"Total Rating\"),\n    color=alt.Color(\"user_name:N\", title=\"User\"),\n    row=alt.Row(\"user_name:N\", title=\"User\", sort=alt.EncodingSortField(field=\"total_rating\", op=\"sum\", order=\"descending\"))\n).properties(\n    height=50,\n    width=400\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Area Charts___faceted_area_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "epinions_1",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_gradient_color",
        "NLQ": "I have a histogram showing IMDB ratings with color-coded bars. Could you create a similar chart but use my trust score data from the epinions database instead? Keep the same style with colored bars, but use a pink-yellow-green color scheme. Make sure the x-axis goes from 0 to 10.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/epinions_1.sqlite')\n\nquery = '''\nSELECT trust\nFROM trust\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"trust:Q\").bin(maxbins=20).scale(domain=[0, 10]),\n    alt.Y('count()'),\n    alt.Color(\"trust:Q\").bin(maxbins=20).scale(scheme='pinkyellowgreen')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___histogram_with_gradient_color.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "epinions_1",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_gradient_color",
        "NLQ": "Can you change my visualization to show trust scores from the epinions database instead of using random data? I'd like to keep a similar style with colored bars, but use the Altair library instead of matplotlib. Make sure to use a pink-yellow-green color scheme and divide the trust scores into about 20 bins ranging from 0 to 10.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/epinions_1.sqlite')\n\nquery = '''\nSELECT trust\nFROM trust\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"trust:Q\").bin(maxbins=20).scale(domain=[0, 10]),\n    alt.Y('count()'),\n    alt.Color(\"trust:Q\").bin(maxbins=20).scale(scheme='pinkyellowgreen')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___histogram_with_gradient_color.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "e_learning",
        "chart_category": "Area Charts",
        "chart_type": "faceted_area_chart",
        "NLQ": "Can you create a chart showing how many students complete courses in different subjects over time? I want to see the data from our e-learning database, with each subject having its own row in the chart. Use area charts to show the trends, with different colors for each subject. Make sure to label the x-axis as \"Completion Month\" and the y-axis as \"Number of Students\". I'd like each subject section to be about 100 pixels tall and 400 pixels wide.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/e_learning.sqlite')\n\nquery = '''\nSELECT \n    Subjects.subject_name AS subject,\n    strftime('%Y-%m', Student_Course_Enrolment.date_of_completion) AS completion_month,\n    COUNT(Student_Course_Enrolment.student_id) AS student_count\nFROM \n    Student_Course_Enrolment\nJOIN \n    Courses ON Student_Course_Enrolment.course_id = Courses.course_id\nJOIN \n    Subjects ON Courses.subject_id = Subjects.subject_id\nWHERE \n    Student_Course_Enrolment.date_of_completion IS NOT NULL\nGROUP BY \n    Subjects.subject_name, completion_month\nORDER BY \n    Subjects.subject_name, completion_month;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_area().encode(\n    x=alt.X(\"completion_month:T\", title=\"Completion Month\"),\n    y=alt.Y(\"student_count:Q\", title=\"Number of Students\"),\n    color=alt.Color(\"subject:N\", title=\"Subject\"),\n    row=alt.Row(\"subject:N\", title=\"Subject\")\n).properties(\n    height=100,\n    width=400\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Area Charts___faceted_area_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "e_learning",
        "chart_category": "Area Charts",
        "chart_type": "faceted_area_chart",
        "NLQ": "Can you change my stock price visualization to show student course completion data instead? I'd like to see how many students complete courses in different subjects over time, with each subject having its own section. Instead of showing stock prices for companies like MSFT and AAPL, I want to pull data from my e-learning database to show student counts by subject and completion month. Please use colored areas to represent each subject and organize them in separate rows, one for each subject. Make sure to label the x-axis as \"Completion Month\" and the y-axis as \"Number of Students\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/e_learning.sqlite')\nquery = '''\nSELECT \n    Subjects.subject_name AS subject,\n    strftime('%Y-%m', Student_Course_Enrolment.date_of_completion) AS completion_month,\n    COUNT(Student_Course_Enrolment.student_id) AS student_count\nFROM \n    Student_Course_Enrolment\nJOIN \n    Courses ON Student_Course_Enrolment.course_id = Courses.course_id\nJOIN \n    Subjects ON Courses.subject_id = Subjects.subject_id\nWHERE \n    Student_Course_Enrolment.date_of_completion IS NOT NULL\nGROUP BY \n    Subjects.subject_name, completion_month\nORDER BY \n    Subjects.subject_name, completion_month;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_area().encode(\n    x=alt.X(\"completion_month:T\", title=\"Completion Month\"),\n    y=alt.Y(\"student_count:Q\", title=\"Number of Students\"),\n    color=alt.Color(\"subject:N\", title=\"Subject\"),\n    row=alt.Row(\"subject:N\", title=\"Subject\")\n).properties(\n    height=100,\n    width=400\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Area Charts___faceted_area_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "e_learning",
        "chart_category": "Line Charts",
        "chart_type": "multiple_series_line_chart",
        "NLQ": "Could you help me create a chart that shows how many courses were completed each month, broken down by subject? I'd like to see the number of completions on the y-axis and the completion months on the x-axis. Please use different colors for each subject and add appropriate titles to the chart and axes. I need to pull this data from our e-learning database, specifically looking at completed courses only. The chart should be titled \"Number of Course Completions Over Time by Subject\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/e_learning.sqlite')\n\nquery = '''\nSELECT \n    Subjects.subject_name AS subject,\n    strftime('%Y-%m', Student_Course_Enrolment.date_of_completion) AS completion_month,\n    COUNT(Student_Course_Enrolment.registration_id) AS completions\nFROM \n    Student_Course_Enrolment\nJOIN \n    Courses ON Student_Course_Enrolment.course_id = Courses.course_id\nJOIN \n    Subjects ON Courses.subject_id = Subjects.subject_id\nWHERE \n    Student_Course_Enrolment.date_of_completion IS NOT NULL\nGROUP BY \n    Subjects.subject_name, completion_month\nORDER BY \n    completion_month ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line().encode(\n    x=alt.X('completion_month:T', title='Completion Month'),\n    y=alt.Y('completions:Q', title='Number of Completions'),\n    color=alt.Color('subject:N', title='Subject')\n).properties(\n    title='Number of Course Completions Over Time by Subject'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Line Charts___multiple_series_line_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "e_learning",
        "chart_category": "Line Charts",
        "chart_type": "multiple_series_line_chart",
        "NLQ": "I have some stock price data for Apple, Google, and Microsoft over a few days in January 2023, but I'd like to create a different visualization. Instead, could you help me create a chart that shows how many courses were completed each month, broken down by subject? I need to pull this data from my e-learning database. I want to see the trends over time with a line chart where each subject has its own colored line. Please add a clear title like \"Number of Course Completions Over Time by Subject\" and make sure the axes are properly labeled as \"Completion Month\" and \"Number of Completions\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/e_learning.sqlite')\n\nquery = '''\nSELECT \n    Subjects.subject_name AS subject,\n    strftime('%Y-%m', Student_Course_Enrolment.date_of_completion) AS completion_month,\n    COUNT(Student_Course_Enrolment.registration_id) AS completions\nFROM \n    Student_Course_Enrolment\nJOIN \n    Courses ON Student_Course_Enrolment.course_id = Courses.course_id\nJOIN \n    Subjects ON Courses.subject_id = Subjects.subject_id\nWHERE \n    Student_Course_Enrolment.date_of_completion IS NOT NULL\nGROUP BY \n    Subjects.subject_name, completion_month\nORDER BY \n    completion_month ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line().encode(\n    x=alt.X('completion_month:T', title='Completion Month'),\n    y=alt.Y('completions:Q', title='Number of Completions'),\n    color=alt.Color('subject:N', title='Subject')\n).properties(\n    title='Number of Course Completions Over Time by Subject'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___multiple_series_line_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "farm",
        "chart_category": "Area Charts",
        "chart_type": "horizon_graph",
        "NLQ": "Can you create a horizon graph showing the total number of cattle by year from our farm database? I'd like it to be split into two sections - one showing values from 0 to 5000, and another showing values above 5000. Make the chart 500 pixels wide but not too tall (around 75 pixels in height), use a smooth monotone line style with semi-transparent areas, and display years as categories along the x-axis. Also, can you connect the chart directly to our farm.sqlite database instead of using random data?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/farm.sqlite')\n\nquery = '''\nSELECT Year, Total_Cattle\nFROM farm\nORDER BY Year\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\narea1 = alt.Chart(df).mark_area(\n    clip=True,\n    interpolate='monotone',\n    opacity=0.6\n).encode(\n    alt.X('Year:O').scale(zero=False, nice=False),\n    alt.Y('Total_Cattle:Q').scale(domain=[0, 5000]).title('Total Cattle (0-5000)'),\n).properties(\n    width=500,\n    height=75\n)\n\narea2 = area1.encode(\n    alt.Y('ny:Q').scale(domain=[0, 5000])\n).transform_calculate(\n    \"ny\", alt.datum.Total_Cattle - 5000\n)\n\narea1 + area2",
        "reference_path": "./vis_bench/code/altair/Area Charts___horizon_graph.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "farm",
        "chart_category": "Area Charts",
        "chart_type": "horizon_graph",
        "NLQ": "Can you create a horizon chart showing the total number of cattle by year from our farm database? I'd like to split the visualization into two parts - one showing values from 0 to 5000, and another showing values above 5000. Make the chart look smooth with a monotone interpolation and semi-transparent areas. Use years on the x-axis and make the chart 500 pixels wide but keep it compact with a height of 75 pixels for each section.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/farm.sqlite')\nquery = '''\nSELECT Year, Total_Cattle\nFROM farm\nORDER BY Year\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\narea1 = alt.Chart(df).mark_area(\n    clip=True,\n    interpolate='monotone',\n    opacity=0.6\n).encode(\n    alt.X('Year:O').scale(zero=False, nice=False),\n    alt.Y('Total_Cattle:Q').scale(domain=[0, 5000]).title('Total Cattle (0-5000)'),\n).properties(\n    width=500,\n    height=75\n)\n\narea2 = area1.encode(\n    alt.Y('ny:Q').scale(domain=[0, 5000])\n).transform_calculate(\n    \"ny\", alt.datum.Total_Cattle - 5000\n)\n\narea1 + area2",
        "reference_path": "./vis_bench/code/matplotlib/Area Charts___horizon_graph.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "film_rank",
        "chart_category": "Area Charts",
        "chart_type": "horizon_graph",
        "NLQ": "Can you create a horizon graph showing the total gross revenue of films by country? I'd like to use real data from my film database instead of random numbers. The visualization should have two parts - the top half showing the higher values and the bottom half showing the lower values with a smooth, curved line connecting the data points. Make the areas slightly transparent and use the countries on the x-axis. Please add proper titles for both the x-axis and the two y-axes to explain what they represent.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/film_rank.sqlite')\n\nquery = '''\nSELECT \n    m.Country AS Country,\n    SUM(f.Gross_in_dollar) AS Total_Gross\nFROM \n    film_market_estimation AS fme\nJOIN \n    film AS f ON fme.Film_ID = f.Film_ID\nJOIN \n    market AS m ON fme.Market_ID = m.Market_ID\nGROUP BY \n    m.Country\nORDER BY \n    Total_Gross DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).mark_area(\n    clip=True,\n    interpolate='monotone',\n    opacity=0.6\n).encode(\n    alt.X('Country:N').title('Country'),\n    alt.Y('Total_Gross:Q').scale(domain=[0, df['Total_Gross'].max() / 2]).title('Gross Revenue (Top Half)'),\n).properties(\n    width=500,\n    height=75\n)\n\ntop_half = base\n\nbottom_half = base.encode(\n    alt.Y('ny:Q').scale(domain=[0, df['Total_Gross'].max() / 2]).title('Gross Revenue (Bottom Half)')\n).transform_calculate(\n    \"ny\", alt.datum.Total_Gross - df['Total_Gross'].max() / 2\n)\n\ntop_half + bottom_half",
        "reference_path": "./vis_bench/code/altair/Area Charts___horizon_graph.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "film_rank",
        "chart_category": "Area Charts",
        "chart_type": "horizon_graph",
        "NLQ": "Can you create a chart showing film revenue by country using my database? I'd like to use a horizon graph style similar to my example, but instead of random data, use actual film gross revenue from my SQLite database. Group the data by country and order it by total gross revenue. Make it look clean with a smooth curve and semi-transparent areas. The top half should show the upper portion of the revenue and the bottom half should show the lower portion, with appropriate labels for each section.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/film_rank.sqlite')\n\nquery = '''\nSELECT \n    m.Country AS Country,\n    SUM(f.Gross_in_dollar) AS Total_Gross\nFROM \n    film_market_estimation AS fme\nJOIN \n    film AS f ON fme.Film_ID = f.Film_ID\nJOIN \n    market AS m ON fme.Market_ID = m.Market_ID\nGROUP BY \n    m.Country\nORDER BY \n    Total_Gross DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df).mark_area(\n    clip=True,\n    interpolate='monotone',\n    opacity=0.6\n).encode(\n    alt.X('Country:N').title('Country'),\n    alt.Y('Total_Gross:Q').scale(domain=[0, df['Total_Gross'].max() / 2]).title('Gross Revenue (Top Half)'),\n).properties(\n    width=500,\n    height=75\n)\n\ntop_half = base\n\nbottom_half = base.encode(\n    alt.Y('ny:Q').scale(domain=[0, df['Total_Gross'].max() / 2]).title('Gross Revenue (Bottom Half)')\n).transform_calculate(\n    \"ny\", alt.datum.Total_Gross - df['Total_Gross'].max() / 2\n)\n\ntop_half + bottom_half",
        "reference_path": "./vis_bench/code/matplotlib/Area Charts___horizon_graph.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "flight_1",
        "chart_category": "Area Charts",
        "chart_type": "horizon_graph",
        "NLQ": "Can you create a horizon graph showing the total distance flown by each type of aircraft? I'd like to pull this data from our flight database, with aircraft names on the x-axis and total distance in miles on the y-axis. Make the areas semi-transparent with smooth curves between points. Set the chart width to 500 pixels and keep it relatively compact in height. Also, please add proper axis titles so it's clear what we're looking at.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/flight_1.sqlite')\n\nquery = '''\nSELECT \n    a.name AS aircraft_name,\n    SUM(f.distance) AS total_distance\nFROM \n    flight AS f\nJOIN \n    aircraft AS a ON f.aid = a.aid\nGROUP BY \n    a.name\nORDER BY \n    total_distance DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\narea1 = alt.Chart(df).mark_area(\n    clip=True,\n    interpolate='monotone',\n    opacity=0.6\n).encode(\n    alt.X('aircraft_name:N').title('Aircraft Type'),\n    alt.Y('total_distance:Q').scale(domain=[0, 5000]).title('Distance (miles)'),\n).properties(\n    width=500,\n    height=75\n)\n\narea2 = area1.encode(\n    alt.Y('adjusted_distance:Q').scale(domain=[0, 5000])\n).transform_calculate(\n    \"adjusted_distance\", alt.datum.total_distance - 5000\n)\n\nfinal_chart = area1 + area2\nfinal_chart",
        "reference_path": "./vis_bench/code/altair/Area Charts___horizon_graph.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "flight_1",
        "chart_category": "Area Charts",
        "chart_type": "horizon_graph",
        "NLQ": "Can you create a chart showing the total distance flown by each type of aircraft from our flight database? I'd like it to have a horizon graph style with two layers - one showing distances up to 5000 miles and another showing distances beyond that. Use aircraft names on the x-axis and make it about 500 pixels wide. Can you use a smoother line style and make the areas slightly transparent?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/flight_1.sqlite')\n\nquery = '''\nSELECT \n    a.name AS aircraft_name,\n    SUM(f.distance) AS total_distance\nFROM \n    flight AS f\nJOIN \n    aircraft AS a ON f.aid = a.aid\nGROUP BY \n    a.name\nORDER BY \n    total_distance DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\narea1 = alt.Chart(df).mark_area(\n    clip=True,\n    interpolate='monotone',\n    opacity=0.6\n).encode(\n    alt.X('aircraft_name:N').title('Aircraft Type'),\n    alt.Y('total_distance:Q').scale(domain=[0, 5000]).title('Distance (miles)'),\n).properties(\n    width=500,\n    height=75\n)\n\narea2 = area1.encode(\n    alt.Y('adjusted_distance:Q').scale(domain=[0, 5000])\n).transform_calculate(\n    \"adjusted_distance\", alt.datum.total_distance - 5000\n)\n\nfinal_chart = area1 + area2\nfinal_chart",
        "reference_path": "./vis_bench/code/matplotlib/Area Charts___horizon_graph.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "game_injury",
        "chart_category": "Area Charts",
        "chart_type": "normalized_stacked_area_chart",
        "NLQ": "Instead of using random data like in the example, can you create a stacked area chart showing the proportion of games for each competition across different seasons? I need to pull this data from my game_injury database. Make sure to label the x-axis as \"Season\", the y-axis as \"Proportion of Games\", and give the chart a title \"Proportion of Game Competitions Over Seasons\". Keep the same normalized stacking approach so we can see how the share of each competition changes over time.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/game_injury.sqlite')\n\nquery = \"\"\"\nSELECT\n  Season,\n  Competition,\n  COUNT(id) AS game_count\nFROM game\nGROUP BY Season, Competition\nORDER BY Season, Competition\n\"\"\"\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_area().encode(\n    x=alt.X('Season:O', title='Season'),\n    y=alt.Y('game_count:Q', stack='normalize', title='Proportion of Games'),\n    color='Competition:N'\n).properties(\n    title='Proportion of Game Competitions Over Seasons'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Area Charts___normalized_stacked_area_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "game_injury",
        "chart_category": "Area Charts",
        "chart_type": "normalized_stacked_area_chart",
        "NLQ": "Instead of using the Iowa electricity data, can you create a stacked area chart showing the proportion of games for each competition across different seasons? I need to pull this data from my game_injury SQLite database. Make sure to title it \"Proportion of Game Competitions Over Seasons\" and label the y-axis as \"Proportion of Games\" instead of \"Normalized Net Generation\". I'd prefer to use Altair for this visualization rather than matplotlib.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/game_injury.sqlite')\n\nquery = \"\"\"\nSELECT\n  Season,\n  Competition,\n  COUNT(id) AS game_count\nFROM game\nGROUP BY Season, Competition\nORDER BY Season, Competition\n\"\"\"\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_area().encode(\n    x=alt.X('Season:O', title='Season'),\n    y=alt.Y('game_count:Q', stack='normalize', title='Proportion of Games'),\n    color='Competition:N'\n).properties(\n    title='Proportion of Game Competitions Over Seasons'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Area Charts___normalized_stacked_area_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "gymnast",
        "chart_category": "Area Charts",
        "chart_type": "normalized_stacked_area_chart",
        "NLQ": "I have data about gymnasts' scores across different events like Floor Exercise, Pommel Horse, and Rings. Can you create a stacked area chart that shows how each gymnast's points are distributed across these different events? I'd like to see the proportion of points each gymnast earned in each event, with different colors representing different events. Please label the x-axis as \"Gymnast ID\" and give the chart a title like \"Normalized Distribution of Points Across Gymnastic Events\". The data is in my gymnast database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/gymnast.sqlite')\n\nquery = '''\nSELECT \n    Gymnast_ID,\n    Floor_Exercise_Points AS Floor,\n    Pommel_Horse_Points AS Pommel_Horse,\n    Rings_Points AS Rings,\n    Vault_Points AS Vault,\n    Parallel_Bars_Points AS Parallel_Bars,\n    Horizontal_Bar_Points AS Horizontal_Bar\nFROM \n    gymnast\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_long = df.melt(id_vars=['Gymnast_ID'], \n                  value_vars=['Floor', 'Pommel_Horse', 'Rings', 'Vault', 'Parallel_Bars', 'Horizontal_Bar'],\n                  var_name='Event', value_name='Points')\n\nchart = alt.Chart(df_long).mark_area().encode(\n    x=alt.X(\"Gymnast_ID:N\", title=\"Gymnast ID\"),\n    y=alt.Y(\"Points:Q\").stack(\"normalize\"),\n    color=\"Event:N\"\n).properties(\n    title=\"Normalized Distribution of Points Across Gymnastic Events\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Area Charts___normalized_stacked_area_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "gymnast",
        "chart_category": "Area Charts",
        "chart_type": "normalized_stacked_area_chart",
        "NLQ": "Instead of showing electricity generation by source over the years, can you create a similar stacked chart but for gymnasts? I'd like to see how each gymnast's total score is distributed across different events like Floor Exercise, Pommel Horse, Rings, Vault, Parallel Bars, and Horizontal Bar. Use the gymnast database and show each gymnast's ID on the x-axis instead of years. Make sure to normalize the data so we can see the proportion of points from each event, and give it a title that explains what we're looking at.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/gymnast.sqlite')\nquery = '''\nSELECT \n    Gymnast_ID,\n    Floor_Exercise_Points AS Floor,\n    Pommel_Horse_Points AS Pommel_Horse,\n    Rings_Points AS Rings,\n    Vault_Points AS Vault,\n    Parallel_Bars_Points AS Parallel_Bars,\n    Horizontal_Bar_Points AS Horizontal_Bar\nFROM \n    gymnast\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_long = df.melt(id_vars=['Gymnast_ID'], \n                  value_vars=['Floor', 'Pommel_Horse', 'Rings', 'Vault', 'Parallel_Bars', 'Horizontal_Bar'],\n                  var_name='Event', value_name='Points')\n\nchart = alt.Chart(df_long).mark_area().encode(\n    x=alt.X(\"Gymnast_ID:N\", title=\"Gymnast ID\"),\n    y=alt.Y(\"Points:Q\").stack(\"normalize\"),\n    color=\"Event:N\"\n).properties(\n    title=\"Normalized Distribution of Points Across Gymnastic Events\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Area Charts___normalized_stacked_area_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "gymnast",
        "chart_category": "Distributions",
        "chart_type": "repeated_density_estimates",
        "NLQ": "Can you create a visualization showing the distribution of gymnast scores across different events (Floor, Pommel Horse, Rings, Vault, Parallel Bars, and Horizontal Bar) from my database? I'd like to see smooth density curves for each event arranged in rows, with the x-axis showing scores between 8 and 10. Make the chart about 300 pixels wide with a height of 50 pixels for each event row. Please label the axes as \"Score\" and \"Density\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/gymnast.sqlite')\n\nquery = '''\nSELECT \n    Floor_Exercise_Points AS Floor,\n    Pommel_Horse_Points AS Pommel_Horse,\n    Rings_Points AS Rings,\n    Vault_Points AS Vault,\n    Parallel_Bars_Points AS Parallel_Bars,\n    Horizontal_Bar_Points AS Horizontal_Bar\nFROM gymnast\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_fold(\n    [\"Floor\", \"Pommel_Horse\", \"Rings\", \"Vault\", \"Parallel_Bars\", \"Horizontal_Bar\"],\n    as_=[\"Event\", \"Score\"]\n).transform_density(\n    density=\"Score\",\n    bandwidth=0.1,\n    groupby=[\"Event\"],\n    extent=[8, 10]\n).mark_area().encode(\n    alt.X(\"value:Q\", title=\"Score\"),\n    alt.Y(\"density:Q\", title=\"Density\"),\n    alt.Row(\"Event:N\")\n).properties(\n    width=300, height=50\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___repeated_density_estimates.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "gymnast",
        "chart_category": "Distributions",
        "chart_type": "repeated_density_estimates",
        "NLQ": "Can you create a visualization showing the distribution of gymnast scores from my database? I'd like to see density plots for each event (Floor, Pommel Horse, Rings, Vault, Parallel Bars, and Horizontal Bar) stacked vertically so I can compare them. Focus on the score range between 8 and 10, and organize them in separate rows by event type. Make the plots smooth and easy to read.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/gymnast.sqlite')\n\nquery = '''\nSELECT \n    Floor_Exercise_Points AS Floor,\n    Pommel_Horse_Points AS Pommel_Horse,\n    Rings_Points AS Rings,\n    Vault_Points AS Vault,\n    Parallel_Bars_Points AS Parallel_Bars,\n    Horizontal_Bar_Points AS Horizontal_Bar\nFROM gymnast\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).transform_fold(\n    [\"Floor\", \"Pommel_Horse\", \"Rings\", \"Vault\", \"Parallel_Bars\", \"Horizontal_Bar\"],\n    as_=[\"Event\", \"Score\"]\n).transform_density(\n    density=\"Score\",\n    bandwidth=0.1,\n    groupby=[\"Event\"],\n    extent=[8, 10]\n).mark_area().encode(\n    alt.X(\"value:Q\", title=\"Score\"),\n    alt.Y(\"density:Q\", title=\"Density\"),\n    alt.Row(\"Event:N\")\n).properties(\n    width=300, height=50\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___repeated_density_estimates.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "insurance_and_eClaims",
        "chart_category": "Bar Charts",
        "chart_type": "bar_and_tick_chart",
        "NLQ": "I like this chart showing projects with their scores and goals, but I need to create something similar for our insurance data. Could you modify it to show the total amounts claimed and average amounts paid for each claim type from our database? I'd like to keep the same style with bars for the total claimed amounts and marks for the average paid amounts, but make those marks red and a bit thicker so they stand out better. Also, please add proper titles to the axes so it's clear what we're looking at - \"Claim Type\" on the x-axis, \"Total Amount Claimed\" and \"Average Amount Paid\" for the y values.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_and_eClaims.sqlite')\n\nquery = '''\nSELECT \n    Claim_Type_Code AS claim_type,\n    SUM(Amount_Claimed) AS total_claimed,\n    AVG(Amount_Piad) AS avg_paid\nFROM \n    Claim_Headers\nGROUP BY \n    Claim_Type_Code\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x=alt.X('claim_type:N', title='Claim Type'),\n    y=alt.Y('total_claimed:Q', title='Total Amount Claimed')\n).properties(\n    width=alt.Step(40)\n)\n\ntick = alt.Chart(df).mark_tick(\n    color='red',\n    thickness=2,\n    size=40 * 0.9\n).encode(\n    x=alt.X('claim_type:N', title='Claim Type'),\n    y=alt.Y('avg_paid:Q', title='Average Amount Paid')\n)\n\nchart = bar + tick\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_and_tick_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "insurance_and_eClaims",
        "chart_category": "Bar Charts",
        "chart_type": "bar_and_tick_chart",
        "NLQ": "Can you create a chart that shows insurance claim data from our database? I'd like to see the total amounts claimed as bars for each claim type, with little red tick marks showing the average amount paid for each type. The bars should show the total claimed amounts, and the red marks should indicate the average paid amounts. Please pull this data directly from our insurance database, grouping everything by claim type.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_and_eClaims.sqlite')\nquery = '''\nSELECT \n    Claim_Type_Code AS claim_type,\n    SUM(Amount_Claimed) AS total_claimed,\n    AVG(Amount_Piad) AS avg_paid\nFROM \n    Claim_Headers\nGROUP BY \n    Claim_Type_Code\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x=alt.X('claim_type:N', title='Claim Type'),\n    y=alt.Y('total_claimed:Q', title='Total Amount Claimed')\n).properties(\n    width=alt.Step(40)\n)\n\ntick = alt.Chart(df).mark_tick(\n    color='red',\n    thickness=2,\n    size=40 * 0.9\n).encode(\n    x=alt.X('claim_type:N', title='Claim Type'),\n    y=alt.Y('avg_paid:Q', title='Average Amount Paid')\n)\n\nchart = bar + tick\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_and_tick_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "insurance_and_eClaims",
        "chart_category": "Distributions",
        "chart_type": "ridgeline_plot",
        "NLQ": "Can you create a visualization showing the distribution of claim amounts across different claim status codes from our insurance database? I'd like to see it as overlapping density curves like those wavy ridgeline plots, with each claim status as a separate row. Make each status a different color, add a title \"Distribution of Claim Amounts by Claim Status\", and label the x-axis as \"Claim Amount\". Keep it clean looking with no grid lines and make sure the labels for claim status codes are aligned to the left.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_and_eClaims.sqlite')\nquery = '''\nSELECT Claim_Status_Code, Amount_Claimed\nFROM Claim_Headers\nWHERE Amount_Claimed IS NOT NULL\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nstep = 20\noverlap = 1\n\nchart = alt.Chart(df, height=step).transform_density(\n    'Amount_Claimed',\n    groupby=['Claim_Status_Code'],\n    as_=['Amount_Claimed', 'density'],\n    extent=[0, df['Amount_Claimed'].max()],\n    bandwidth=50\n).mark_area(\n    interpolate='monotone',\n    fillOpacity=0.8,\n    stroke='lightgray',\n    strokeWidth=0.5\n).encode(\n    alt.X('Amount_Claimed:Q').title('Claim Amount'),\n    alt.Y('density:Q')\n        .axis(None)\n        .scale(range=[step, -step * overlap]),\n    alt.Fill('Claim_Status_Code:N')\n        .legend(None)\n        .scale(scheme='category10')\n).facet(\n    row=alt.Row('Claim_Status_Code:N')\n        .title(None)\n        .header(labelAngle=0, labelAlign='left')\n).properties(\n    title='Distribution of Claim Amounts by Claim Status',\n    bounds='flush'\n).configure_facet(\n    spacing=0\n).configure_view(\n    stroke=None\n).configure_title(\n    anchor='end'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___ridgeline_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "insurance_fnol",
        "chart_category": "Bar Charts",
        "chart_type": "bar_and_tick_chart",
        "NLQ": "I have a simple chart showing projects and their scores with goal markers. Could you change it to show insurance data instead? I need to see the total number of claims for each customer from our insurance database, with bars representing the claims. Also, add a red tick mark to show the average number of claims across all customers. Please label the axes properly with \"Customer Name\" and \"Total Claims\" and make sure the bars are nicely spaced.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_fnol.sqlite')\n\nquery = '''\nSELECT \n    C.Customer_name AS customer_name,\n    COUNT(Cl.Claim_ID) AS total_claims\nFROM \n    Customers AS C\nJOIN \n    First_Notification_of_Loss AS FNOL ON C.Customer_ID = FNOL.Customer_ID\nJOIN \n    Claims AS Cl ON FNOL.FNOL_ID = Cl.FNOL_ID\nGROUP BY \n    C.Customer_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\naverage_claims = df['total_claims'].mean()\n\ndf['average_claims'] = average_claims\n\nbar = alt.Chart(df).mark_bar().encode(\n    x=alt.X('customer_name:N', title='Customer Name'),\n    y=alt.Y('total_claims:Q', title='Total Claims')\n).properties(\n    width=alt.Step(40)\n)\n\ntick = alt.Chart(df).mark_tick(\n    color='red',\n    thickness=2,\n    size=40 * 0.9,\n).encode(\n    x=alt.X('customer_name:N', title='Customer Name'),\n    y=alt.Y('average_claims:Q', title='Average Claims')\n)\n\nchart = bar + tick\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_and_tick_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "insurance_fnol",
        "chart_category": "Bar Charts",
        "chart_type": "bar_and_tick_chart",
        "NLQ": "Could you help me create a chart that shows the total number of claims for each customer from our insurance database? I'd like to have bars showing the total claims for each customer, and also include a red tick mark to highlight the average number of claims across all customers. Please use customer names on the x-axis and make sure the chart looks clean and organized.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_fnol.sqlite')\n\nquery = '''\nSELECT \n    C.Customer_name AS customer_name,\n    COUNT(Cl.Claim_ID) AS total_claims\nFROM \n    Customers AS C\nJOIN \n    First_Notification_of_Loss AS FNOL ON C.Customer_ID = FNOL.Customer_ID\nJOIN \n    Claims AS Cl ON FNOL.FNOL_ID = Cl.FNOL_ID\nGROUP BY \n    C.Customer_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\naverage_claims = df['total_claims'].mean()\ndf['average_claims'] = average_claims\n\nbar = alt.Chart(df).mark_bar().encode(\n    x=alt.X('customer_name:N', title='Customer Name'),\n    y=alt.Y('total_claims:Q', title='Total Claims')\n).properties(\n    width=alt.Step(40)\n)\n\ntick = alt.Chart(df).mark_tick(\n    color='red',\n    thickness=2,\n    size=40 * 0.9,\n).encode(\n    x=alt.X('customer_name:N', title='Customer Name'),\n    y=alt.Y('average_claims:Q', title='Average Claims')\n)\n\nchart = bar + tick\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_and_tick_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "insurance_fnol",
        "chart_category": "Distributions",
        "chart_type": "ridgeline_plot",
        "NLQ": "Can you create a chart showing the distribution of settlement amounts for different insurance policy types? I'd like a ridgeline plot where each policy type has its own row with a smooth area chart. Instead of using the temperature data in the example, please use our insurance database to pull settlement amounts and policy types. Make the areas slightly transparent with light gray borders, remove the y-axis labels, and add a title \"Distribution of Settlement Amounts by Policy Type\" at the top. Also, can you align the policy type labels to the left and remove any spacing between the rows to make it look cleaner?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/insurance_fnol.sqlite')\n\nquery = '''\nSELECT\n    ap.policy_type_code,\n    s.Settlement_Amount\nFROM\n    Available_Policies AS ap\nJOIN\n    First_Notification_of_Loss AS fnol ON ap.Policy_ID = fnol.Policy_ID\nJOIN\n    Claims AS c ON fnol.FNOL_ID = c.FNOL_ID\nJOIN\n    Settlements AS s ON c.Claim_ID = s.Claim_ID;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nstep = 20\noverlap = 1\n\nchart = alt.Chart(df, height=step).transform_bin(\n    ['bin_amount_min', 'bin_amount_max'], 'Settlement_Amount'\n).transform_aggregate(\n    value='count()', groupby=['policy_type_code', 'bin_amount_min', 'bin_amount_max']\n).transform_impute(\n    impute='value', groupby=['policy_type_code'], key='bin_amount_min', value=0\n).mark_area(\n    interpolate='monotone',\n    fillOpacity=0.8,\n    stroke='lightgray',\n    strokeWidth=0.5\n).encode(\n    alt.X('bin_amount_min:Q')\n        .bin('binned')\n        .title('Settlement Amount'),\n    alt.Y('value:Q')\n        .axis(None)\n        .scale(range=[step, -step * overlap]),\n    alt.Fill('policy_type_code:N')\n        .legend(None)\n).facet(\n    row=alt.Row('policy_type_code:N')\n        .title(None)\n        .header(labelAngle=0, labelAlign='left')\n).properties(\n    title='Distribution of Settlement Amounts by Policy Type',\n    bounds='flush'\n).configure_facet(\n    spacing=0\n).configure_view(\n    stroke=None\n).configure_title(\n    anchor='end'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___ridgeline_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "insurance_policies",
        "chart_category": "Bar Charts",
        "chart_type": "bar_and_tick_chart",
        "NLQ": "I want to create a chart that shows insurance policy types and their claim amounts. Can you use the data from our insurance database to show the total amount claimed for each policy type as bars, and mark the total amount settled as red tick marks? I'd like the bars to be wide enough to easily compare the claimed amounts versus the settled amounts for each policy type.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_policies.sqlite')\n\nquery = '''\nSELECT \n    CP.Policy_Type_Code AS Policy_Type,\n    SUM(C.Amount_Claimed) AS Total_Amount_Claimed,\n    SUM(C.Amount_Settled) AS Total_Amount_Settled\nFROM \n    Customer_Policies AS CP\nJOIN \n    Claims AS C ON CP.Policy_ID = C.Policy_ID\nGROUP BY \n    CP.Policy_Type_Code\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x='Policy_Type',\n    y='Total_Amount_Claimed'\n).properties(\n    width=alt.Step(40)\n)\n\ntick = alt.Chart(df).mark_tick(\n    color='red',\n    thickness=2,\n    size=40 * 0.9\n).encode(\n    x='Policy_Type',\n    y='Total_Amount_Settled'\n)\n\nchart = bar + tick\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_and_tick_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "insurance_policies",
        "chart_category": "Bar Charts",
        "chart_type": "bar_and_tick_chart",
        "NLQ": "I want to create a chart that shows insurance policy types and their claim amounts. For each policy type, I'd like to see the total amount claimed as bars and the total amount settled as red tick marks across the bars. Can you pull this data from our insurance database and make it easy to compare how much was claimed versus how much was actually settled for each policy type?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_policies.sqlite')\nquery = '''\nSELECT \n    CP.Policy_Type_Code AS Policy_Type,\n    SUM(C.Amount_Claimed) AS Total_Amount_Claimed,\n    SUM(C.Amount_Settled) AS Total_Amount_Settled\nFROM \n    Customer_Policies AS CP\nJOIN \n    Claims AS C ON CP.Policy_ID = C.Policy_ID\nGROUP BY \n    CP.Policy_Type_Code\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x='Policy_Type',\n    y='Total_Amount_Claimed'\n).properties(\n    width=alt.Step(40)\n)\n\ntick = alt.Chart(df).mark_tick(\n    color='red',\n    thickness=2,\n    size=40 * 0.9\n).encode(\n    x='Policy_Type',\n    y='Total_Amount_Settled'\n)\n\nchart = bar + tick\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_and_tick_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "insurance_policies",
        "chart_category": "Distributions",
        "chart_type": "scatter_plot_with_faceted_marginal_histograms",
        "NLQ": "I have a scatter plot with histograms showing iris flower measurements, but I'd like to use it for our insurance data instead. Can you create a similar chart that shows the relationship between Amount Claimed and Amount Settled from our insurance database? Each point should represent a claim, colored by the Policy Type Code. Keep those histogram bars on the top and right sides to show the distribution of claimed and settled amounts. Also, make the histogram bars slightly transparent and remove any spacing between them. Can you pull this data directly from our insurance_policies database rather than using the sample data in the current chart?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/insurance_policies.sqlite')\n\nquery = '''\nSELECT\n    C.Amount_Claimed,\n    C.Amount_Settled,\n    CP.Policy_Type_Code\nFROM\n    Claims AS C\nJOIN\n    Customer_Policies AS CP ON C.Policy_ID = CP.Policy_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df)\nbase_bar = base.mark_bar(opacity=0.3, binSpacing=0)\n\npoints = base.mark_circle().encode(\n    alt.X(\"Amount_Claimed:Q\"),\n    alt.Y(\"Amount_Settled:Q\"),\n    color=\"Policy_Type_Code:N\",\n)\n\ntop_hist = (\n    base_bar\n    .encode(\n        alt.X(\"Amount_Claimed:Q\")\n            .bin(maxbins=20).stack(None).title(\"\"),\n        alt.Y(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"Policy_Type_Code:N\"),\n    )\n    .properties(height=60)\n)\n\nright_hist = (\n    base_bar\n    .encode(\n        alt.Y(\"Amount_Settled:Q\")\n            .bin(maxbins=20)\n            .stack(None)\n            .title(\"\"),\n        alt.X(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"Policy_Type_Code:N\"),\n    )\n    .properties(width=60)\n)\n\nchart = top_hist & (points | right_hist)\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___scatter_plot_with_faceted_marginal_histograms.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "insurance_policies",
        "chart_category": "Distributions",
        "chart_type": "scatter_plot_with_faceted_marginal_histograms",
        "NLQ": "I have a scatter plot with histograms on the sides showing some flower measurements, but I'd like to switch to our insurance claims data instead. Can you create a similar chart that shows the amount customers claimed versus what was settled, with different colors for each policy type? I need to pull this data from our insurance_policies database rather than using the flower dataset. Also, can you make the chart using Altair instead of matplotlib? I'd still like to keep those histograms on the top and right side that show the distribution of values.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/insurance_policies.sqlite')\nquery = '''\nSELECT\n    C.Amount_Claimed,\n    C.Amount_Settled,\n    CP.Policy_Type_Code\nFROM\n    Claims AS C\nJOIN\n    Customer_Policies AS CP ON C.Policy_ID = CP.Policy_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df)\nbase_bar = base.mark_bar(opacity=0.3, binSpacing=0)\n\npoints = base.mark_circle().encode(\n    alt.X(\"Amount_Claimed:Q\"),\n    alt.Y(\"Amount_Settled:Q\"),\n    color=\"Policy_Type_Code:N\",\n)\n\ntop_hist = (\n    base_bar\n    .encode(\n        alt.X(\"Amount_Claimed:Q\")\n            .bin(maxbins=20).stack(None).title(\"\"),\n        alt.Y(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"Policy_Type_Code:N\"),\n    )\n    .properties(height=60)\n)\n\nright_hist = (\n    base_bar\n    .encode(\n        alt.Y(\"Amount_Settled:Q\")\n            .bin(maxbins=20)\n            .stack(None)\n            .title(\"\"),\n        alt.X(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"Policy_Type_Code:N\"),\n    )\n    .properties(width=60)\n)\n\nchart = top_hist & (points | right_hist)\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___scatter_plot_with_faceted_marginal_histograms.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "journal_committee",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_highlighting_values_beyond_a_threshold",
        "NLQ": "Can you change my chart to show journal sales by theme instead of values by day? I'd like to connect to our journal committee database to get the sales data. Make the regular bars blue and highlight any themes with sales over 2000 in red. Add a dashed line at the threshold with a label that says \"High Sales Threshold\" on the right side. Also, please add a title \"Journal Sales by Theme with Highlighted High Performers\" and make the axis labels clearer by using \"Journal Theme\" and \"Total Sales\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/journal_committee.sqlite')\nquery = '''\nSELECT Theme, SUM(Sales) AS Total_Sales\nFROM journal\nGROUP BY Theme\nORDER BY Total_Sales DESC\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nthreshold = 2000\nbars = alt.Chart(df).mark_bar(color=\"steelblue\").encode(\n    x=alt.X(\"Theme:N\", title=\"Journal Theme\"),\n    y=alt.Y(\"Total_Sales:Q\", title=\"Total Sales\")\n)\nhighlight = bars.mark_bar(color=\"#e45755\").encode(\n    y2=alt.Y2(datum=threshold)\n).transform_filter(\n    alt.datum.Total_Sales > threshold\n)\nrule = alt.Chart().mark_rule(color=\"black\", strokeDash=[3, 5]).encode(\n    y=alt.Y(datum=threshold)\n)\nlabel = rule.mark_text(\n    x=\"width\",\n    dx=-2,\n    align=\"right\",\n    baseline=\"bottom\",\n    text=\"High Sales Threshold\"\n)\nchart = (bars + highlight + rule + label).properties(\n    title=\"Journal Sales by Theme with Highlighted High Performers\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_highlighting_values_beyond_a_threshold.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "journal_committee",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_highlighting_values_beyond_a_threshold",
        "NLQ": "I want to create a bar chart showing total sales for each journal theme from our database. Can you highlight the themes with sales over 2000 in red, but keep the other bars blue? Please add a dashed line at the 2000 mark with a label saying \"High Sales Threshold\". Title the chart \"Journal Sales by Theme with Highlighted High Performers\" and make sure the axes are properly labeled as \"Journal Theme\" and \"Total Sales\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/journal_committee.sqlite')\nquery = '''\nSELECT Theme, SUM(Sales) AS Total_Sales\nFROM journal\nGROUP BY Theme\nORDER BY Total_Sales DESC\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nthreshold = 2000\n\nbars = alt.Chart(df).mark_bar(color=\"steelblue\").encode(\n    x=alt.X(\"Theme:N\", title=\"Journal Theme\"),\n    y=alt.Y(\"Total_Sales:Q\", title=\"Total Sales\")\n)\n\nhighlight = bars.mark_bar(color=\"#e45755\").encode(\n    y2=alt.Y2(datum=threshold)\n).transform_filter(\n    alt.datum.Total_Sales > threshold\n)\n\nrule = alt.Chart().mark_rule(color=\"black\", strokeDash=[3, 5]).encode(\n    y=alt.Y(datum=threshold)\n)\n\nlabel = rule.mark_text(\n    x=\"width\",\n    dx=-2,\n    align=\"right\",\n    baseline=\"bottom\",\n    text=\"High Sales Threshold\"\n)\n\nchart = (bars + highlight + rule + label).properties(\n    title=\"Journal Sales by Theme with Highlighted High Performers\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_highlighting_values_beyond_a_threshold.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "journal_committee",
        "chart_category": "Distributions",
        "chart_type": "scatter_plot_with_faceted_marginal_histograms",
        "NLQ": "Can you create a chart showing the relationship between editor age and journal sales? I want to see how old our editors are and if that relates to how well their journals sell. Please color-code the points by work type so we can see if certain types of editors sell better. I'd like to keep those small histogram bars at the top and right sides like in the example, but make them a bit transparent. Also, can you pull this data directly from our journal committee database instead of using the sample data?",
        "code": "import altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/journal_committee.sqlite')\nquery = '''\nSELECT\n    e.Age,\n    j.Sales,\n    jc.Work_Type\nFROM\n    editor AS e\nJOIN\n    journal_committee AS jc ON e.Editor_ID = jc.Editor_ID\nJOIN\n    journal AS j ON jc.Journal_ID = j.Journal_ID;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df)\nbase_bar = base.mark_bar(opacity=0.3, binSpacing=0)\n\nxscale = alt.Scale(domain=(df['Age'].min() - 1, df['Age'].max() + 1))\nyscale = alt.Scale(domain=(df['Sales'].min() - 100, df['Sales'].max() + 100))\n\npoints = base.mark_circle().encode(\n    alt.X(\"Age:Q\").scale(xscale),\n    alt.Y(\"Sales:Q\").scale(yscale),\n    color=\"Work_Type:N\",\n)\n\ntop_hist = (\n    base_bar\n    .encode(\n        alt.X(\"Age:Q\")\n            .bin(maxbins=20, extent=xscale.domain).stack(None).title(\"\"),\n        alt.Y(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"Work_Type:N\"),\n    )\n    .properties(height=60)\n)\n\nright_hist = (\n    base_bar\n    .encode(\n        alt.Y(\"Sales:Q\")\n            .bin(maxbins=20, extent=yscale.domain)\n            .stack(None)\n            .title(\"\"),\n        alt.X(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"Work_Type:N\"),\n    )\n    .properties(width=60)\n)\n\nchart = top_hist & (points | right_hist)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___scatter_plot_with_faceted_marginal_histograms.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "journal_committee",
        "chart_category": "Distributions",
        "chart_type": "scatter_plot_with_faceted_marginal_histograms",
        "NLQ": "Can you create a scatter plot showing the relationship between editor age and journal sales from our database? I'd like to color-code the points by work type, and include histogram distributions along the top and right sides. Please use Altair instead of Matplotlib, and make sure to pull the data directly from our SQLite database instead of using the sample data in the original chart. The histograms should also be color-coded by work type to match the scatter plot.",
        "code": "import altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/journal_committee.sqlite')\nquery = '''\nSELECT\n    e.Age,\n    j.Sales,\n    jc.Work_Type\nFROM\n    editor AS e\nJOIN\n    journal_committee AS jc ON e.Editor_ID = jc.Editor_ID\nJOIN\n    journal AS j ON jc.Journal_ID = j.Journal_ID;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df)\nbase_bar = base.mark_bar(opacity=0.3, binSpacing=0)\n\nxscale = alt.Scale(domain=(df['Age'].min() - 1, df['Age'].max() + 1))\nyscale = alt.Scale(domain=(df['Sales'].min() - 100, df['Sales'].max() + 100))\n\npoints = base.mark_circle().encode(\n    alt.X(\"Age:Q\").scale(xscale),\n    alt.Y(\"Sales:Q\").scale(yscale),\n    color=\"Work_Type:N\",\n)\n\ntop_hist = (\n    base_bar\n    .encode(\n        alt.X(\"Age:Q\")\n            .bin(maxbins=20, extent=xscale.domain).stack(None).title(\"\"),\n        alt.Y(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"Work_Type:N\"),\n    )\n    .properties(height=60)\n)\n\nright_hist = (\n    base_bar\n    .encode(\n        alt.Y(\"Sales:Q\")\n            .bin(maxbins=20, extent=yscale.domain)\n            .stack(None)\n            .title(\"\"),\n        alt.X(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"Work_Type:N\"),\n    )\n    .properties(width=60)\n)\n\nchart = top_hist & (points | right_hist)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___scatter_plot_with_faceted_marginal_histograms.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "journal_committee",
        "chart_category": "Scatter Plots",
        "chart_type": "bubble_plot",
        "NLQ": "Can you help me create a chart that looks like the one in my code, but instead of showing car details, it focuses on the age of editors and how many sales their journals have? I'd also like the size of the bubbles to show how much each editor has contributed, just like in the example I provided. Instead of using random data, can you pull this information from my journal committee database?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/journal_committee.sqlite')\n\nquery = '''\nSELECT \n    e.Age AS Editor_Age,\n    j.Sales AS Journal_Sales,\n    COUNT(jc.Work_Type) AS Contribution_Count\nFROM \n    editor AS e\nJOIN \n    journal_committee AS jc ON e.Editor_ID = jc.Editor_ID\nJOIN \n    journal AS j ON jc.Journal_ID = j.Journal_ID\nGROUP BY \n    e.Editor_ID, j.Journal_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_point().encode(\n    x='Editor_Age:Q',\n    y='Journal_Sales:Q',\n    size='Contribution_Count:Q'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___bubble_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "journal_committee",
        "chart_category": "Scatter Plots",
        "chart_type": "bubble_plot",
        "NLQ": "Can you help me create a chart that looks like the one in my code, but instead of showing car details, it focuses on the age of editors and how many sales their journals have? I'd also like the size of the bubbles to show how much each editor has contributed, just like in the example I provided. I need to pull this data from my journal committee database instead of using random numbers.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/journal_committee.sqlite')\n\nquery = '''\nSELECT \n    e.Age AS Editor_Age,\n    j.Sales AS Journal_Sales,\n    COUNT(jc.Work_Type) AS Contribution_Count\nFROM \n    editor AS e\nJOIN \n    journal_committee AS jc ON e.Editor_ID = jc.Editor_ID\nJOIN \n    journal AS j ON jc.Journal_ID = j.Journal_ID\nGROUP BY \n    e.Editor_ID, j.Journal_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_point().encode(\n    x='Editor_Age:Q',\n    y='Journal_Sales:Q',\n    size='Contribution_Count:Q'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___bubble_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "loan_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_highlighting_values_beyond_a_threshold",
        "NLQ": "Can you change my chart to show branch names and their number of customers from our loan database? I'd like the bars to be blue, with any branch that has more than 300 customers highlighted in red. Please add a horizontal line at the 300 mark and label it as \"Threshold (300)\" on the right side. Also, add a title that says \"Branches with More Than 300 Customers\" and make sure the axes have proper labels like \"Branch Name\" and \"Number of Customers\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/loan_1.sqlite')\nquery = '''\nSELECT branch_ID, bname, no_of_customers\nFROM bank\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nthreshold = 300\n\nbars = alt.Chart(df).mark_bar(color=\"steelblue\").encode(\n    x=alt.X(\"bname:N\", title=\"Branch Name\"),\n    y=alt.Y(\"no_of_customers:Q\", title=\"Number of Customers\"),\n)\n\nhighlight = bars.mark_bar(color=\"#e45755\").encode(\n    y2=alt.Y2(datum=threshold)\n).transform_filter(\n    alt.datum.no_of_customers > threshold\n)\n\nrule = alt.Chart().mark_rule().encode(\n    y=alt.Y(datum=threshold)\n)\n\nlabel = rule.mark_text(\n    x=\"width\",\n    dx=-2,\n    align=\"right\",\n    baseline=\"bottom\",\n    text=\"Threshold (300)\"\n)\n\nchart = (bars + highlight + rule + label).properties(\n    title=\"Branches with More Than 300 Customers\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_highlighting_values_beyond_a_threshold.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "loan_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_highlighting_values_beyond_a_threshold",
        "NLQ": "Can you change my bar chart to show branch names and their number of customers from our loan database? I'd like to keep the blue bars with red highlighting for values above a threshold of 300, and include that threshold line. Also, please add a title \"Branches with More Than 300 Customers\" and label the threshold line as \"Threshold (300)\". Can you use Altair instead of matplotlib for this visualization?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/loan_1.sqlite')\nquery = '''\nSELECT branch_ID, bname, no_of_customers\nFROM bank\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nthreshold = 300\n\nbars = alt.Chart(df).mark_bar(color=\"steelblue\").encode(\n    x=alt.X(\"bname:N\", title=\"Branch Name\"),\n    y=alt.Y(\"no_of_customers:Q\", title=\"Number of Customers\"),\n)\n\nhighlight = bars.mark_bar(color=\"#e45755\").encode(\n    y2=alt.Y2(datum=threshold)\n).transform_filter(\n    alt.datum.no_of_customers > threshold\n)\n\nrule = alt.Chart().mark_rule().encode(\n    y=alt.Y(datum=threshold)\n)\n\nlabel = rule.mark_text(\n    x=\"width\",\n    dx=-2,\n    align=\"right\",\n    baseline=\"bottom\",\n    text=\"Threshold (300)\"\n)\n\nchart = (bars + highlight + rule + label).properties(\n    title=\"Branches with More Than 300 Customers\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_highlighting_values_beyond_a_threshold.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "loan_1",
        "chart_category": "Distributions",
        "chart_type": "scatter_plot_with_faceted_marginal_histograms",
        "NLQ": "I want to create a chart like this one, but instead of using the iris dataset with sepal length and width, I'd like to use my loan database to show account balance and credit score. Can you make it with the same layout, where there's a main scatter plot with small bar charts on the top and right sides? Also, could the colors represent different account types instead of species? And please add proper titles to the axes like \"Account Balance\" and \"Credit Score\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/loan_1.sqlite')\n\nquery = '''\nSELECT cust_ID, acc_type, acc_bal, credit_score\nFROM customer\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df)\nbase_bar = base.mark_bar(opacity=0.3, binSpacing=0)\n\nxscale = alt.Scale(domain=(df['acc_bal'].min(), df['acc_bal'].max()))\nyscale = alt.Scale(domain=(df['credit_score'].min(), df['credit_score'].max()))\n\npoints = base.mark_circle().encode(\n    alt.X(\"acc_bal:Q\").scale(xscale),\n    alt.Y(\"credit_score:Q\").scale(yscale),\n    color=\"acc_type:N\",\n)\n\ntop_hist = (\n    base_bar\n    .encode(\n        alt.X(\"acc_bal:Q\")\n        .bin(maxbins=20, extent=xscale.domain)\n        .stack(None)\n        .title(\"Account Balance\"),\n        alt.Y(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"acc_type:N\"),\n    )\n    .properties(height=60)\n)\n\nright_hist = (\n    base_bar\n    .encode(\n        alt.Y(\"credit_score:Q\")\n        .bin(maxbins=20, extent=yscale.domain)\n        .stack(None)\n        .title(\"Credit Score\"),\n        alt.X(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"acc_type:N\"),\n    )\n    .properties(width=60)\n)\n\ntop_hist & (points | right_hist)",
        "reference_path": "./vis_bench/code/altair/Distributions___scatter_plot_with_faceted_marginal_histograms.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "loan_1",
        "chart_category": "Distributions",
        "chart_type": "scatter_plot_with_faceted_marginal_histograms",
        "NLQ": "I have this visualization showing iris flower measurements with sepal length and width, but I'd like to change it to show financial data instead. Can you create a similar layout with a scatter plot and histograms on the top and right, but use account balance and credit score data from my loan database? I want to color-code the points by account type instead of flower species. Also, could you switch from matplotlib to Altair for a more interactive visualization? Make sure to label the axes properly with \"Account Balance\" and \"Credit Score\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/loan_1.sqlite')\nquery = '''\nSELECT cust_ID, acc_type, acc_bal, credit_score\nFROM customer\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df)\nbase_bar = base.mark_bar(opacity=0.3, binSpacing=0)\n\nxscale = alt.Scale(domain=(df['acc_bal'].min(), df['acc_bal'].max()))\nyscale = alt.Scale(domain=(df['credit_score'].min(), df['credit_score'].max()))\n\npoints = base.mark_circle().encode(\n    alt.X(\"acc_bal:Q\").scale(xscale),\n    alt.Y(\"credit_score:Q\").scale(yscale),\n    color=\"acc_type:N\",\n)\n\ntop_hist = (\n    base_bar\n    .encode(\n        alt.X(\"acc_bal:Q\")\n        .bin(maxbins=20, extent=xscale.domain)\n        .stack(None)\n        .title(\"Account Balance\"),\n        alt.Y(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"acc_type:N\"),\n    )\n    .properties(height=60)\n)\n\nright_hist = (\n    base_bar\n    .encode(\n        alt.Y(\"credit_score:Q\")\n        .bin(maxbins=20, extent=yscale.domain)\n        .stack(None)\n        .title(\"Credit Score\"),\n        alt.X(\"count()\").stack(None).title(\"\"),\n        alt.Color(\"acc_type:N\"),\n    )\n    .properties(width=60)\n)\n\ntop_hist & (points | right_hist)",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___scatter_plot_with_faceted_marginal_histograms.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "loan_1",
        "chart_category": "Scatter Plots",
        "chart_type": "faceted_scatter_plot",
        "NLQ": "Can you change my car performance scatter plot to show customer loan data instead? I need a scatter plot that shows the relationship between number of loans and credit scores, with separate rows for each state. The data should come from my loan database rather than the random data I'm currently using. Keep the same basic layout with rows of small scatter plots, but use the loan count on the x-axis and credit score on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/loan_1.sqlite')\n\nquery = '''\nSELECT c.no_of_loans, c.credit_score, c.state\nFROM customer AS c\nWHERE c.no_of_loans IS NOT NULL AND c.credit_score IS NOT NULL\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df, width=100, height=100).mark_point().encode(\n    x=\"no_of_loans:Q\",\n    y=\"credit_score:Q\",\n    row=\"state:N\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___faceted_scatter_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "loan_1",
        "chart_category": "Scatter Plots",
        "chart_type": "faceted_scatter_plot",
        "NLQ": "I have a visualization showing car data with horsepower and miles per gallon for different origins (USA, Europe, Japan) in separate panels. Could you change this to show customer loan data instead? I need a scatter plot that shows the relationship between number of loans and credit scores, with separate panels for each state. Instead of using matplotlib, could you use Altair and pull the data from my SQLite database called 'loan_1'? Each state should have its own small graph stacked vertically.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/loan_1.sqlite')\n\nquery = '''\nSELECT c.no_of_loans, c.credit_score, c.state\nFROM customer AS c\nWHERE c.no_of_loans IS NOT NULL AND c.credit_score IS NOT NULL\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df, width=100, height=100).mark_point().encode(\n    x=\"no_of_loans:Q\",\n    y=\"credit_score:Q\",\n    row=\"state:N\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___faceted_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "local_govt_in_alabama",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_highlighted_bar",
        "NLQ": "Using the local government database for Alabama, can you create a bar chart showing how many events each organizer has handled? I want to see the organizers on the x-axis and the number of events they organized on the y-axis. Make the bar for the organizer with the most events orange, and keep the rest steelblue. Also, please add a title \"Number of Events Organized by Each Organizer\" and make the chart wider, about 600 pixels. Label the axes as \"Organizer\" and \"Number of Events Organized\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/local_govt_in_alabama.sqlite')\n\nquery = '''\nSELECT \n    P.Participant_Details AS Organizer,\n    COUNT(E.Event_ID) AS Event_Count\nFROM \n    Participants AS P\nJOIN \n    Participants_in_Events AS PE ON P.Participant_ID = PE.Participant_ID\nJOIN \n    Events AS E ON PE.Event_ID = E.Event_ID\nWHERE \n    P.Participant_Type_Code = 'Organizer'\nGROUP BY \n    P.Participant_Details\nORDER BY \n    Event_Count DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nhighlighted_organizer = df.loc[df['Event_Count'].idxmax(), 'Organizer']\n\ncolor = alt.when(alt.datum.Organizer == highlighted_organizer).then(alt.value(\"orange\")).otherwise(alt.value(\"steelblue\"))\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Organizer:N', title='Organizer'),\n    y=alt.Y('Event_Count:Q', title='Number of Events Organized'),\n    color=color\n).properties(width=600, title=\"Number of Events Organized by Each Organizer\")\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_highlighted_bar.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "local_govt_in_alabama",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_highlighted_bar",
        "NLQ": "Using the local government database for Alabama, can you create a bar chart that shows how many events each organizer has handled? I want to see the organizers on the x-axis and the number of events they organized on the y-axis. Make the bar for the organizer with the most events orange, and the rest of the bars blue. Also, please add a title that says \"Number of Events Organized by Each Organizer\" and make the chart wider so it's easier to read all the organizer names.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/local_govt_in_alabama.sqlite')\n\nquery = '''\nSELECT \n    P.Participant_Details AS Organizer,\n    COUNT(E.Event_ID) AS Event_Count\nFROM \n    Participants AS P\nJOIN \n    Participants_in_Events AS PE ON P.Participant_ID = PE.Participant_ID\nJOIN \n    Events AS E ON PE.Event_ID = E.Event_ID\nWHERE \n    P.Participant_Type_Code = 'Organizer'\nGROUP BY \n    P.Participant_Details\nORDER BY \n    Event_Count DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nhighlighted_organizer = df.loc[df['Event_Count'].idxmax(), 'Organizer']\n\ncolor = alt.when(alt.datum.Organizer == highlighted_organizer).then(alt.value(\"orange\")).otherwise(alt.value(\"steelblue\"))\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Organizer:N', title='Organizer'),\n    y=alt.Y('Event_Count:Q', title='Number of Events Organized'),\n    color=color\n).properties(width=600, title=\"Number of Events Organized by Each Organizer\")\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_highlighted_bar.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "local_govt_in_alabama",
        "chart_category": "Distributions",
        "chart_type": "stacked_density_estimates",
        "NLQ": "Can you create a density chart showing the distribution of Service IDs grouped by Service Type Code from our Alabama local government database? I'd like it to have the same stacked area style as my example, with different colors for each service type. Make it a bit wider but not as tall, around 400 pixels wide and 100 pixels high.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/local_govt_in_alabama.sqlite')\nquery = '''\nSELECT Service_ID, Service_Type_Code\nFROM Services\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_fold(\n    fold=['Service_ID'],\n    as_ = ['Measurement_type', 'value']\n).transform_density(\n    density='value',\n    bandwidth=0.3,\n    groupby=['Service_Type_Code'],\n    extent= [0, 10],\n    counts = True,\n    steps=200\n).mark_area().encode(\n    alt.X('value:Q'),\n    alt.Y('density:Q').stack('zero'),\n    alt.Color('Service_Type_Code:N')\n).properties(width=400, height=100)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___stacked_density_estimates.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "local_govt_in_alabama",
        "chart_category": "Distributions",
        "chart_type": "stacked_density_estimates",
        "NLQ": "Can you create a density chart showing the distribution of Service IDs grouped by Service Type Code from my Alabama local government database? I'd like it to have a similar stacked area style as my example chart, but use the Service Type Code for coloring instead of measurement types. Make it a bit wider but not as tall as my example, around 400 by 100 pixels.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/local_govt_in_alabama.sqlite')\nquery = '''\nSELECT Service_ID, Service_Type_Code\nFROM Services\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_fold(\n    fold=['Service_ID'],\n    as_ = ['Measurement_type', 'value']\n).transform_density(\n    density='value',\n    bandwidth=0.3,\n    groupby=['Service_Type_Code'],\n    extent= [0, 10],\n    counts = True,\n    steps=200\n).mark_area().encode(\n    alt.X('value:Q'),\n    alt.Y('density:Q').stack('zero'),\n    alt.Color('Service_Type_Code:N')\n).properties(width=400, height=100)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___stacked_density_estimates.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "local_govt_in_alabama",
        "chart_category": "Scatter Plots",
        "chart_type": "faceted_scatter_plot",
        "NLQ": "I'd like to create a chart that shows data from our Alabama local government database instead of using random data. Can you make a faceted scatter plot that groups by service type code, with each service type in its own row? For each point, I want to see the number of participants on the x-axis and the success rate percentage on the y-axis. Please label the axes clearly as \"Number of Participants\" and \"Success Rate (%)\" and make each chart 200x200 in size. The data should come from our events, services, and participants tables, counting unique participants and calculating the average success rate for each service type.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/local_govt_in_alabama.sqlite')\n\nquery = '''\nSELECT \n    S.Service_Type_Code,\n    COUNT(DISTINCT P.Participant_ID) AS Participant_Count,\n    AVG(CASE WHEN E.Event_Details = 'Success' THEN 1 ELSE 0 END) * 100 AS Success_Rate\nFROM \n    Events AS E\nJOIN \n    Services AS S ON E.Service_ID = S.Service_ID\nJOIN \n    Participants_in_Events AS PE ON E.Event_ID = PE.Event_ID\nJOIN \n    Participants AS P ON PE.Participant_ID = P.Participant_ID\nGROUP BY \n    S.Service_Type_Code\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_point().encode(\n    x=alt.X(\"Participant_Count:Q\", title=\"Number of Participants\"),\n    y=alt.Y(\"Success_Rate:Q\", title=\"Success Rate (%)\"),\n    row=alt.Row(\"Service_Type_Code:N\", title=\"Service Type\")\n).properties(\n    width=200,\n    height=200\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___faceted_scatter_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "local_govt_in_alabama",
        "chart_category": "Scatter Plots",
        "chart_type": "faceted_scatter_plot",
        "NLQ": "Instead of the car data visualization with horsepower and MPG, I'd like to create a chart using our Alabama local government database. Can you make a faceted scatter plot that shows the number of participants and success rates for different service types? I need to pull this data from our SQLite database, with each service type in its own row. Make sure to label the x-axis as \"Number of Participants\" and the y-axis as \"Success Rate (%)\" and give each small chart equal dimensions.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/local_govt_in_alabama.sqlite')\nquery = '''\nSELECT \n    S.Service_Type_Code,\n    COUNT(DISTINCT P.Participant_ID) AS Participant_Count,\n    AVG(CASE WHEN E.Event_Details = 'Success' THEN 1 ELSE 0 END) * 100 AS Success_Rate\nFROM \n    Events AS E\nJOIN \n    Services AS S ON E.Service_ID = S.Service_ID\nJOIN \n    Participants_in_Events AS PE ON E.Event_ID = PE.Event_ID\nJOIN \n    Participants AS P ON PE.Participant_ID = P.Participant_ID\nGROUP BY \n    S.Service_Type_Code\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\nchart = alt.Chart(df).mark_point().encode(\n    x=alt.X(\"Participant_Count:Q\", title=\"Number of Participants\"),\n    y=alt.Y(\"Success_Rate:Q\", title=\"Success Rate (%)\"),\n    row=alt.Row(\"Service_Type_Code:N\", title=\"Service Type\")\n).properties(\n    width=200,\n    height=200\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___faceted_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "local_govt_mdm",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_highlighted_bar",
        "NLQ": "I have this bar chart showing wheat production by year, but I need to create a similar chart using my customer database instead. Can you make a bar chart that shows how many customers we have in each source system? Use the same blue color scheme but highlight the 'Rent' source system in orange like how 1810 is highlighted in my current chart. Please add a proper title \"Number of Customers by Source System\" and label the axes as \"Source System\" and \"Number of Customers\". Make the chart a bit wider too.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/local_govt_mdm.sqlite')\n\nquery = '''\nSELECT \n    source_system_code, \n    COUNT(master_customer_id) AS customer_count\nFROM \n    CMI_Cross_References\nGROUP BY \n    source_system_code\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ncolor = alt.condition(\n    alt.datum.source_system_code == 'Rent',\n    alt.value('orange'),\n    alt.value('steelblue')\n)\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('source_system_code:N', title='Source System'),\n    y=alt.Y('customer_count:Q', title='Number of Customers'),\n    color=color\n).properties(\n    width=600,\n    title='Number of Customers by Source System'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_highlighted_bar.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "local_govt_mdm",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_highlighted_bar",
        "NLQ": "Can you create a bar chart showing the number of customers for each source system from our database? I'd like to use blue bars for most systems, but highlight the 'Rent' system in orange to make it stand out. Please label the x-axis as \"Source System\" and the y-axis as \"Number of Customers\", and give the chart a title \"Number of Customers by Source System\". Make the chart a good width so it's easy to read.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/local_govt_mdm.sqlite')\nquery = '''\nSELECT \n    source_system_code, \n    COUNT(master_customer_id) AS customer_count\nFROM \n    CMI_Cross_References\nGROUP BY \n    source_system_code\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ncolor = alt.condition(\n    alt.datum.source_system_code == 'Rent',\n    alt.value('orange'),\n    alt.value('steelblue')\n)\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('source_system_code:N', title='Source System'),\n    y=alt.Y('customer_count:Q', title='Number of Customers'),\n    color=color\n).properties(\n    width=600,\n    title='Number of Customers by Source System'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_highlighted_bar.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "local_govt_mdm",
        "chart_category": "Distributions",
        "chart_type": "stacked_density_estimates",
        "NLQ": "Can you create a stacked density chart showing the distribution of customer cross-reference IDs across our different local government services? I need to see how customer records are spread across Council Tax, Business Rates, Benefits Overpayments, Parking Fines, Rent Arrears, and Electoral Register. Please pull this data directly from our local government database instead of using random numbers. Make the chart colorful with each service type having its own color, and add a clear title that explains what we're looking at. Can you also adjust the width and height to make it more compact?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/local_govt_mdm.sqlite')\n\nqueries = {\n    'CouncilTax': 'SELECT cmi_cross_ref_id FROM Council_Tax',\n    'BusinessRates': 'SELECT cmi_cross_ref_id FROM Business_Rates',\n    'BenefitsOverpayments': 'SELECT cmi_cross_ref_id FROM Benefits_Overpayments',\n    'ParkingFines': 'SELECT cmi_cross_ref_id FROM Parking_Fines',\n    'RentArrears': 'SELECT cmi_cross_ref_id FROM Rent_Arrears',\n    'ElectoralRegister': 'SELECT cmi_cross_ref_id FROM Electoral_Register'\n}\n\ndataframes = []\nfor measurement_type, query in queries.items():\n    df = pd.read_sql_query(query, conn)\n    df['Measurement_type'] = measurement_type\n    dataframes.append(df)\n\nsource = pd.concat(dataframes)\nsource = source.rename(columns={'cmi_cross_ref_id': 'value'})\n\nconn.close()\n\nchart = alt.Chart(source).transform_fold(\n    ['value'],\n    as_ = ['Measurement_type_fold', 'value']\n).transform_density(\n    density='value',\n    bandwidth=5,\n    groupby=['Measurement_type'],\n    extent= [0, 110],\n    counts = True,\n    steps=200\n).mark_area().encode(\n    alt.X('value:Q'),\n    alt.Y('density:Q').stack('zero'),\n    alt.Color('Measurement_type:N')\n).properties(\n    width=400,\n    height=200,\n    title='Stacked Density Estimates of Customer Cross-Reference IDs by Service Type'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___stacked_density_estimates.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "local_govt_mdm",
        "chart_category": "Distributions",
        "chart_type": "stacked_density_estimates",
        "NLQ": "Can you create a stacked density chart showing the distribution of customer cross-reference IDs across our different local government services? I need to see data from Council Tax, Business Rates, Benefits Overpayments, Parking Fines, Rent Arrears, and Electoral Register. Pull the data directly from our SQLite database instead of using random numbers. Make the chart colorful with each service type stacked on top of each other, and add a clear title that explains what we're looking at. The x-axis should go from 0 to 110 to cover our ID range.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/local_govt_mdm.sqlite')\n\nqueries = {\n    'CouncilTax': 'SELECT cmi_cross_ref_id FROM Council_Tax',\n    'BusinessRates': 'SELECT cmi_cross_ref_id FROM Business_Rates',\n    'BenefitsOverpayments': 'SELECT cmi_cross_ref_id FROM Benefits_Overpayments',\n    'ParkingFines': 'SELECT cmi_cross_ref_id FROM Parking_Fines',\n    'RentArrears': 'SELECT cmi_cross_ref_id FROM Rent_Arrears',\n    'ElectoralRegister': 'SELECT cmi_cross_ref_id FROM Electoral_Register'\n}\n\ndataframes = []\nfor measurement_type, query in queries.items():\n    df = pd.read_sql_query(query, conn)\n    df['Measurement_type'] = measurement_type\n    dataframes.append(df)\n\nsource = pd.concat(dataframes)\nsource = source.rename(columns={'cmi_cross_ref_id': 'value'})\n\nconn.close()\n\nchart = alt.Chart(source).transform_fold(\n    ['value'],\n    as_=['Measurement_type_fold', 'value']\n).transform_density(\n    density='value',\n    bandwidth=5,\n    groupby=['Measurement_type'],\n    extent=[0, 110],\n    counts=True,\n    steps=200\n).mark_area().encode(\n    alt.X('value:Q'),\n    alt.Y('density:Q').stack('zero'),\n    alt.Color('Measurement_type:N')\n).properties(\n    width=400,\n    height=200,\n    title='Stacked Density Estimates of Customer Cross-Reference IDs by Service Type'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___stacked_density_estimates.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "local_govt_mdm",
        "chart_category": "Scatter Plots",
        "chart_type": "multifeature_scatter_plot",
        "NLQ": "Can you help me make a chart like the one in my code, but instead of using flower data, I want to use our local government database? I need to show how many council tax records and rent arrears are linked to each customer. I'd like the chart to use different colors for each source system and adjust the size of the dots based on the total number of cross-references. Make sure the axes don't start at zero so we can see the differences better.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/local_govt_mdm.sqlite')\n\nquery = '''\nSELECT \n    T1.master_customer_id,\n    COUNT(DISTINCT T2.council_tax_id) AS council_tax_count,\n    COUNT(DISTINCT T3.council_tax_id) AS rent_arrears_count,\n    T4.source_system_code,\n    COUNT(T4.cmi_cross_ref_id) AS total_cross_refs\nFROM \n    Customer_Master_Index AS T1\nLEFT JOIN \n    Council_Tax AS T2 ON T2.cmi_cross_ref_id IN (\n        SELECT cmi_cross_ref_id FROM CMI_Cross_References WHERE master_customer_id = T1.master_customer_id\n    )\nLEFT JOIN \n    Rent_Arrears AS T3 ON T3.cmi_cross_ref_id IN (\n        SELECT cmi_cross_ref_id FROM CMI_Cross_References WHERE master_customer_id = T1.master_customer_id\n    )\nLEFT JOIN \n    CMI_Cross_References AS T4 ON T4.master_customer_id = T1.master_customer_id\nGROUP BY \n    T1.master_customer_id, T4.source_system_code\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    alt.X('council_tax_count').scale(zero=False),\n    alt.Y('rent_arrears_count').scale(zero=False, padding=1),\n    color='source_system_code',\n    size='total_cross_refs'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___multifeature_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "manufactory_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_highlighted_segment",
        "NLQ": "I have a chart showing wheat production over different years, but I'd like to change it to show manufacturer revenue data instead. Can you create a bar chart where each bar represents a different manufacturer's revenue? Please highlight any manufacturers that earn more than $100 billion in a different color (red would be nice), and add a dashed line across the chart to mark that $100 billion threshold. Also, could you add a proper title like \"Manufacturer Revenue with Highlighted Threshold\" and make the chart a bit wider, around 600 pixels? The data should come from our manufacturers database instead of the random data in the current chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/manufactory_1.sqlite')\n\nquery = '''\nSELECT Name, Revenue\nFROM Manufacturers\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nthreshold_value = 100\nthreshold_df = pd.DataFrame([{\"threshold\": threshold_value}])\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"Name:N\", title=\"Manufacturer\"),\n    y=alt.Y(\"Revenue:Q\", title=\"Revenue (in billions)\")\n)\n\nhighlight = alt.Chart(df).mark_bar(color=\"#e45755\").encode(\n    x=alt.X(\"Name:N\", title=\"Manufacturer\"),\n    y=alt.Y(\"baseline:Q\", title=\"Revenue (in billions)\"),\n    y2=alt.Y2(\"Revenue:Q\")\n).transform_filter(\n    alt.datum.Revenue > threshold_value\n).transform_calculate(\n    baseline=f\"{threshold_value}\"\n)\n\nrule = alt.Chart(threshold_df).mark_rule(color=\"black\", strokeDash=[3, 5]).encode(\n    y=\"threshold:Q\"\n)\n\nchart = (bars + highlight + rule).properties(width=600, title=\"Manufacturer Revenue with Highlighted Threshold\")\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_highlighted_segment.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "manufactory_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_highlighted_segment",
        "NLQ": "Can you create a bar chart showing the revenue of different manufacturers? I'd like the bars for companies with revenue above 100 billion to be highlighted in red, while the others remain in the default color. Please add a black dashed line across the chart at the 100 billion threshold. Label the x-axis as \"Manufacturer\" and the y-axis as \"Revenue (in billions)\" and title the chart \"Manufacturer Revenue with Highlighted Threshold\". Make the chart about 600 pixels wide.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/manufactory_1.sqlite')\n\nquery = '''\nSELECT Name, Revenue\nFROM Manufacturers\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nthreshold_value = 100\nthreshold_df = pd.DataFrame([{\"threshold\": threshold_value}])\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"Name:N\", title=\"Manufacturer\"),\n    y=alt.Y(\"Revenue:Q\", title=\"Revenue (in billions)\")\n)\n\nhighlight = alt.Chart(df).mark_bar(color=\"#e45755\").encode(\n    x=alt.X(\"Name:N\", title=\"Manufacturer\"),\n    y=alt.Y(\"baseline:Q\", title=\"Revenue (in billions)\"),\n    y2=alt.Y2(\"Revenue:Q\")\n).transform_filter(\n    alt.datum.Revenue > threshold_value\n).transform_calculate(\n    baseline=f\"{threshold_value}\"\n)\n\nrule = alt.Chart(threshold_df).mark_rule(color=\"black\", strokeDash=[3, 5]).encode(\n    y=\"threshold:Q\"\n)\n\nchart = (bars + highlight + rule).properties(width=600, title=\"Manufacturer Revenue with Highlighted Threshold\")\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_highlighted_segment.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "manufactory_1",
        "chart_category": "Scatter Plots",
        "chart_type": "multifeature_scatter_plot",
        "NLQ": "Instead of using the flower dataset, could you create a chart that shows how manufacturers' earnings relate to the average cost of their products? I'd like to use data from our manufacturing database. Please use colors to group manufacturers by their headquarters location and adjust the circle sizes based on how many products they make. Also, add a title that says \"Manufacturer Revenue vs. Average Product Price\" and make sure the axis labels are clear. Don't start the axes at zero since that might squish the data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/manufactory_1.sqlite')\n\nquery = '''\nSELECT \n    M.Revenue AS Revenue,\n    AVG(P.Price) AS AvgProductPrice,\n    COUNT(P.Code) AS ProductCount,\n    M.Headquarter AS Headquarter\nFROM \n    Manufacturers AS M\nJOIN \n    Products AS P ON M.Code = P.Manufacturer\nGROUP BY \n    M.Code\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    alt.X('Revenue').scale(zero=False).title('Manufacturer Revenue'),\n    alt.Y('AvgProductPrice').scale(zero=False, padding=1).title('Average Product Price'),\n    color='Headquarter',\n    size='ProductCount'\n).properties(\n    title='Manufacturer Revenue vs. Average Product Price'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___multifeature_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "manufacturer",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_highlighted_segment",
        "NLQ": "I want to create a bar chart showing the number of factories each manufacturer has, using data from our manufacturer database instead of the wheat data. Can you highlight manufacturers that have more than 20 factories with a red color? Also, add a dashed black line at the 20-factory threshold. Please label the x-axis as \"Manufacturer\" and the y-axis as \"Number of Factories\" and give the chart a title \"Number of Factories by Manufacturer\". Make the chart wider, about 600 pixels.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/manufacturer.sqlite')\nquery = '''\nSELECT Name, Num_of_Factories\nFROM manufacturer\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nthreshold_value = 20\nthreshold_df = pd.DataFrame([{\"threshold\": threshold_value}])\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Name:N', title='Manufacturer'),\n    y=alt.Y('Num_of_Factories:Q', title='Number of Factories')\n)\n\nhighlight = alt.Chart(df).mark_bar(color=\"#e45755\").encode(\n    x='Name:N',\n    y='baseline:Q',\n    y2='Num_of_Factories:Q'\n).transform_filter(\n    alt.datum.Num_of_Factories > threshold_value\n).transform_calculate(\"baseline\", str(threshold_value))\n\nrule = alt.Chart(threshold_df).mark_rule(color=\"black\", strokeDash=[3, 5]).encode(\n    y='threshold:Q'\n)\n\nchart = (bars + highlight + rule).properties(width=600, title=\"Number of Factories by Manufacturer\")\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_highlighted_segment.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "manufacturer",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_highlighted_segment",
        "NLQ": "Can you create a bar chart showing the number of factories for each manufacturer? I'd like to highlight manufacturers with more than 20 factories in red, and add a dashed black line at the 20-factory threshold. Please title the chart \"Number of Factories by Manufacturer\" and make it about 600 pixels wide. Label the x-axis \"Manufacturer\" and the y-axis \"Number of Factories\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/manufacturer.sqlite')\nquery = '''\nSELECT Name, Num_of_Factories\nFROM manufacturer\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nthreshold_value = 20\nthreshold_df = pd.DataFrame([{\"threshold\": threshold_value}])\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Name:N', title='Manufacturer'),\n    y=alt.Y('Num_of_Factories:Q', title='Number of Factories')\n)\n\nhighlight = alt.Chart(df).mark_bar(color=\"#e45755\").encode(\n    x='Name:N',\n    y='baseline:Q',\n    y2='Num_of_Factories:Q'\n).transform_filter(\n    alt.datum.Num_of_Factories > threshold_value\n).transform_calculate(\"baseline\", str(threshold_value))\n\nrule = alt.Chart(threshold_df).mark_rule(color=\"black\", strokeDash=[3, 5]).encode(\n    y='threshold:Q'\n)\n\nchart = (bars + highlight + rule).properties(width=600, title=\"Number of Factories by Manufacturer\")\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_highlighted_segment.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "manufacturer",
        "chart_category": "Scatter Plots",
        "chart_type": "scatter_matrix",
        "NLQ": "I really like how this visualization creates a grid of plots with different combinations of data. Could you make something similar that shows the relationship between the year a manufacturer opened, the number of factories they have, and the number of shops, using colors to group them by the manufacturer's name? Also, can you make the plots a bit smaller and add interactivity so I can explore the data better? Instead of using random data, please pull the information from our manufacturer database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/manufacturer.sqlite')\nquery = '''\nSELECT Manufacturer_ID, Open_Year, Num_of_Factories, Num_of_Shops, Name\nFROM manufacturer\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nscatter_matrix = alt.Chart(df).mark_circle().encode(\n    alt.X(alt.repeat(\"column\"), type='quantitative'),\n    alt.Y(alt.repeat(\"row\"), type='quantitative'),\n    color='Name:N'\n).properties(\n    width=150,\n    height=150\n).repeat(\n    row=['Num_of_Factories', 'Num_of_Shops', 'Open_Year'],\n    column=['Open_Year', 'Num_of_Shops', 'Num_of_Factories']\n).interactive()\n\nscatter_matrix",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___scatter_matrix.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "manufacturer",
        "chart_category": "Scatter Plots",
        "chart_type": "scatter_matrix",
        "NLQ": "I like this scatter plot matrix showing car data, but could you create a similar one using our manufacturer database instead? I'd like to see the relationships between when manufacturers opened, how many factories they have, and how many shops they operate. Please color-code the points by manufacturer name and make it interactive so I can explore the data better.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/manufacturer.sqlite')\n\nquery = '''\nSELECT Manufacturer_ID, Open_Year, Num_of_Factories, Num_of_Shops, Name\nFROM manufacturer\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nscatter_matrix = alt.Chart(df).mark_circle().encode(\n    alt.X(alt.repeat(\"column\"), type='quantitative'),\n    alt.Y(alt.repeat(\"row\"), type='quantitative'),\n    color='Name:N'\n).properties(\n    width=150,\n    height=150\n).repeat(\n    row=['Num_of_Factories', 'Num_of_Shops', 'Open_Year'],\n    column=['Open_Year', 'Num_of_Shops', 'Num_of_Factories']\n).interactive()\n\nscatter_matrix",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___scatter_matrix.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "match_season",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_highlighted_segment",
        "NLQ": "I have this chart showing wheat values by year with bars that go above a threshold highlighted differently. Could you change this to show the number of players drafted per season instead? I'd like to use data from my match_season database, counting players grouped by season. Keep the threshold concept, but set it at 10 players, and highlight bars that exceed this threshold in red. Also, add a black dashed line at the threshold value. Please give the chart a proper title \"Players Drafted Per Season with Highlighted Threshold\" and label the axes as \"Season\" and \"Number of Players Drafted\". Make the chart a bit wider too, around 600 pixels.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/match_season.sqlite')\n\nquery = '''\nSELECT Season, COUNT(Player) AS Player_Count\nFROM match_season\nGROUP BY Season\nORDER BY Season\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nthreshold = pd.DataFrame([{\"threshold\": 10}])\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"Season:O\", title=\"Season\"),\n    y=alt.Y(\"Player_Count:Q\", title=\"Number of Players Drafted\")\n)\n\nhighlight = alt.Chart(df).mark_bar(color=\"#e45755\").encode(\n    x='Season:O',\n    y='baseline:Q',\n    y2='Player_Count:Q'\n).transform_filter(\n    alt.datum.Player_Count > 10\n).transform_calculate(\"baseline\", \"10\")\n\nrule = alt.Chart(threshold).mark_rule(color=\"black\", strokeDash=[3, 5]).encode(\n    y='threshold:Q'\n)\n\nchart = (bars + highlight + rule).properties(width=600, title=\"Players Drafted Per Season with Highlighted Threshold\")\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_highlighted_segment.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "match_season",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_highlighted_segment",
        "NLQ": "Can you create a bar chart showing the number of players drafted per season? I'd like seasons on the x-axis and the player count on the y-axis. Please highlight in red any bars where more than 10 players were drafted, and add a black dashed line at the 10-player threshold. Title the chart \"Players Drafted Per Season with Highlighted Threshold\" and make it about 600 pixels wide.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/match_season.sqlite')\n\nquery = '''\nSELECT Season, COUNT(Player) AS Player_Count\nFROM match_season\nGROUP BY Season\nORDER BY Season\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nthreshold = pd.DataFrame([{\"threshold\": 10}])\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"Season:O\", title=\"Season\"),\n    y=alt.Y(\"Player_Count:Q\", title=\"Number of Players Drafted\")\n)\n\nhighlight = alt.Chart(df).mark_bar(color=\"#e45755\").encode(\n    x='Season:O',\n    y='baseline:Q',\n    y2='Player_Count:Q'\n).transform_filter(\n    alt.datum.Player_Count > 10\n).transform_calculate(\"baseline\", \"10\")\n\nrule = alt.Chart(threshold).mark_rule(color=\"black\", strokeDash=[3, 5]).encode(\n    y='threshold:Q'\n)\n\nchart = (bars + highlight + rule).properties(width=600, title=\"Players Drafted Per Season with Highlighted Threshold\")\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_highlighted_segment.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "match_season",
        "chart_category": "Distributions",
        "chart_type": "table_bubble_plot_github_punch_card",
        "NLQ": "Instead of using random data, can you create a chart that shows how many players are on each team for every season using my database? I need to pull this information from my match_season.sqlite database. The chart should have Team IDs on the x-axis and Seasons on the y-axis, with circles sized based on the player count. Please add proper titles to the axes too.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/match_season.sqlite')\n\nquery = '''\nSELECT \n    Season AS season,\n    Team AS team_id,\n    COUNT(Player) AS player_count\nFROM match_season\nGROUP BY Season, Team\nORDER BY Season, Team\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    x=alt.X('team_id:O', title='Team ID'),\n    y=alt.Y('season:O', title='Season'),\n    size=alt.Size('player_count:Q', title='Player Count')\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___table_bubble_plot_github_punch_card.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "match_season",
        "chart_category": "Distributions",
        "chart_type": "table_bubble_plot_github_punch_card",
        "NLQ": "Instead of using random data with hours and days of the week, could you create a chart that shows how many players are on each team for every season? I'd like to pull this data from our match_season database. Keep the bubble chart style where the size of the circles represents the count, but put team IDs on the x-axis and seasons on the y-axis. Also, can you switch from matplotlib to Altair for this visualization?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/match_season.sqlite')\n\nquery = '''\nSELECT \n    Season AS season,\n    Team AS team_id,\n    COUNT(Player) AS player_count\nFROM match_season\nGROUP BY Season, Team\nORDER BY Season, Team\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    x=alt.X('team_id:O', title='Team ID'),\n    y=alt.Y('season:O', title='Season'),\n    size=alt.Size('player_count:Q', title='Player Count')\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___table_bubble_plot_github_punch_card.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "medicine_enzyme_interaction",
        "chart_category": "Distributions",
        "chart_type": "table_bubble_plot_github_punch_card",
        "NLQ": "Can you create a chart showing how many medicines interact with enzymes at different locations? I'd like to see the interaction types on the y-axis and enzyme locations on the x-axis. Please use circles where the size represents the medicine count, and add a blue color gradient to highlight the differences in counts. Also, add a title that explains what the chart is showing, and proper labels for the axes.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/medicine_enzyme_interaction.sqlite')\n\nquery = '''\nSELECT \n    e.Location AS enzyme_location,\n    mei.interaction_type,\n    COUNT(m.id) AS medicine_count\nFROM \n    medicine_enzyme_interaction AS mei\nJOIN \n    enzyme AS e ON mei.enzyme_id = e.id\nJOIN \n    medicine AS m ON mei.medicine_id = m.id\nGROUP BY \n    e.Location, mei.interaction_type\nORDER BY \n    e.Location, mei.interaction_type;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    x=alt.X('enzyme_location:N', title='Enzyme Location'),\n    y=alt.Y('interaction_type:N', title='Interaction Type'),\n    size=alt.Size('medicine_count:Q', title='Medicine Count'),\n    color=alt.Color('medicine_count:Q', scale=alt.Scale(scheme='blues'))\n).properties(\n    title='Count of Medicines Interacting with Enzymes by Location and Interaction Type'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___table_bubble_plot_github_punch_card.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "medicine_enzyme_interaction",
        "chart_category": "Distributions",
        "chart_type": "table_bubble_plot_github_punch_card",
        "NLQ": "Can you create a bubble chart showing how many medicines interact with enzymes? I'd like to see enzyme locations on the x-axis and interaction types on the y-axis, with the size of each bubble representing the medicine count. Please use a blue color gradient for the bubbles based on count values, and add a title that explains what the chart is showing. I need this data pulled from our medicine-enzyme interaction database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/medicine_enzyme_interaction.sqlite')\n\nquery = '''\nSELECT \n    e.Location AS enzyme_location,\n    mei.interaction_type,\n    COUNT(m.id) AS medicine_count\nFROM \n    medicine_enzyme_interaction AS mei\nJOIN \n    enzyme AS e ON mei.enzyme_id = e.id\nJOIN \n    medicine AS m ON mei.medicine_id = m.id\nGROUP BY \n    e.Location, mei.interaction_type\nORDER BY \n    e.Location, mei.interaction_type;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    x=alt.X('enzyme_location:N', title='Enzyme Location'),\n    y=alt.Y('interaction_type:N', title='Interaction Type'),\n    size=alt.Size('medicine_count:Q', title='Medicine Count'),\n    color=alt.Color('medicine_count:Q', scale=alt.Scale(scheme='blues'))\n).properties(\n    title='Count of Medicines Interacting with Enzymes by Location and Interaction Type'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___table_bubble_plot_github_punch_card.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "medicine_enzyme_interaction",
        "chart_category": "Scatter Plots",
        "chart_type": "scatter_matrix",
        "NLQ": "I need to create a visualization showing the relationships between enzymes and medicines from my database. Can you make a grid-like chart where I can see enzyme names and medicine names on both axes? I want different interaction types to be shown in different colors, and when I hover over a point, I'd like to see details like the enzyme name, medicine name, whether it's FDA-approved, and what type of interaction it is. Make the chart interactive so I can explore the data better. Each small chart in the grid should be a reasonable size, not too big or too small.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/medicine_enzyme_interaction.sqlite')\n\nquery = '''\nSELECT \n    e.name AS enzyme_name, \n    m.name AS medicine_name, \n    m.FDA_approved, \n    mei.interaction_type\nFROM \n    medicine_enzyme_interaction AS mei\nJOIN \n    enzyme AS e ON mei.enzyme_id = e.id\nJOIN \n    medicine AS m ON mei.medicine_id = m.id\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    alt.X(alt.repeat(\"column\"), type='nominal'),\n    alt.Y(alt.repeat(\"row\"), type='nominal'),\n    color='interaction_type:N',\n    tooltip=['enzyme_name', 'medicine_name', 'FDA_approved', 'interaction_type']\n).properties(\n    width=150,\n    height=150\n).repeat(\n    row=['enzyme_name', 'medicine_name'],\n    column=['medicine_name', 'enzyme_name']\n).interactive()\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___scatter_matrix.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "medicine_enzyme_interaction",
        "chart_category": "Scatter Plots",
        "chart_type": "scatter_matrix",
        "NLQ": "I have this car performance visualization showing horsepower, acceleration, and miles per gallon for different car origins, but I'd like to switch to a different dataset about medicine and enzyme interactions. Can you create a grid-like chart showing relationships between enzyme names and medicine names instead? Please use different colors to represent interaction types, and when I hover over a point, I want to see details like the enzyme name, medicine name, FDA approval status, and interaction type. Also, can you make it interactive and pull the data from my SQLite database instead of using random numbers?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/medicine_enzyme_interaction.sqlite')\nquery = '''\nSELECT \n    e.name AS enzyme_name, \n    m.name AS medicine_name, \n    m.FDA_approved, \n    mei.interaction_type\nFROM \n    medicine_enzyme_interaction AS mei\nJOIN \n    enzyme AS e ON mei.enzyme_id = e.id\nJOIN \n    medicine AS m ON mei.medicine_id = m.id\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    alt.X(alt.repeat(\"column\"), type='nominal'),\n    alt.Y(alt.repeat(\"row\"), type='nominal'),\n    color='interaction_type:N',\n    tooltip=['enzyme_name', 'medicine_name', 'FDA_approved', 'interaction_type']\n).properties(\n    width=150,\n    height=150\n).repeat(\n    row=['enzyme_name', 'medicine_name'],\n    column=['medicine_name', 'enzyme_name']\n).interactive()\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___scatter_matrix.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "mountain_photos",
        "chart_category": "Distributions",
        "chart_type": "table_bubble_plot_github_punch_card",
        "NLQ": "Could you help me create a chart that shows how many photos were taken at different times of the day and on different days of the week for each mountain? I'd like to pull this data from my mountain_photos database instead of using random data. I want the circles to vary in size based on the number of photos, and I'd like to use different colors to represent the photo colors. Please add proper titles to the axes like \"Hour of Day\" and \"Day of Week\", and give the chart a title \"Photos Taken by Mountain, Day, and Hour\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/mountain_photos.sqlite')\n\nquery = '''\nSELECT \n    m.name AS mountain_name,\n    strftime('%w', p.id) AS day_of_week,\n    strftime('%H', p.id) AS hour_of_day,\n    p.color AS photo_color,\n    COUNT(*) AS photo_count\nFROM photos AS p\nJOIN mountain AS m ON p.mountain_id = m.id\nGROUP BY m.name, day_of_week, hour_of_day, p.color\nORDER BY m.name, day_of_week, hour_of_day\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    x=alt.X('hour_of_day:O', title='Hour of Day'),\n    y=alt.Y('day_of_week:O', title='Day of Week', sort=['0', '1', '2', '3', '4', '5', '6']),\n    size=alt.Size('photo_count:Q', title='Number of Photos'),\n    color=alt.Color('photo_color:N', title='Photo Color')\n).properties(\n    title='Photos Taken by Mountain, Day, and Hour'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___table_bubble_plot_github_punch_card.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "mountain_photos",
        "chart_category": "Distributions",
        "chart_type": "table_bubble_plot_github_punch_card",
        "NLQ": "Could you change my chart to show real data from my mountain photos database instead of using random numbers? I'd like to see how many photos were taken at different times of the day and on different days of the week for each mountain. Please make the circles different sizes based on the number of photos and use different colors to represent the photo colors. Also, could you add a title that says \"Photos Taken by Mountain, Day, and Hour\"? I'd prefer if you could use Altair instead of Matplotlib for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/mountain_photos.sqlite')\nquery = '''\nSELECT \n    m.name AS mountain_name,\n    strftime('%w', p.id) AS day_of_week,\n    strftime('%H', p.id) AS hour_of_day,\n    p.color AS photo_color,\n    COUNT(*) AS photo_count\nFROM photos AS p\nJOIN mountain AS m ON p.mountain_id = m.id\nGROUP BY m.name, day_of_week, hour_of_day, p.color\nORDER BY m.name, day_of_week, hour_of_day\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\nchart = alt.Chart(df).mark_circle().encode(\n    x=alt.X('hour_of_day:O', title='Hour of Day'),\n    y=alt.Y('day_of_week:O', title='Day of Week', sort=['0', '1', '2', '3', '4', '5', '6']),\n    size=alt.Size('photo_count:Q', title='Number of Photos'),\n    color=alt.Color('photo_color:N', title='Photo Color')\n).properties(\n    title='Photos Taken by Mountain, Day, and Hour'\n)\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___table_bubble_plot_github_punch_card.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "movie_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels",
        "NLQ": "Instead of showing wheat prices by year, can you create a horizontal bar chart showing average movie ratings from our movie database? I'd like to see the movie titles listed vertically on the left and their average ratings displayed as horizontal bars extending to the right, with the actual rating values shown next to each bar. Please sort the movies from highest to lowest rating and add a title \"Average Movie Ratings\" at the top. Make sure the axis labels clearly show \"Movie Title\" and \"Average Rating\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/movie_1.sqlite')\n\nquery = '''\nSELECT \n    M.title AS MovieTitle,\n    AVG(R.stars) AS AverageRating\nFROM \n    Rating AS R\nJOIN \n    Movie AS M ON R.mID = M.mID\nGROUP BY \n    M.mID, M.title\nORDER BY \n    AverageRating DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('AverageRating:Q', title='Average Rating'),\n    y=alt.Y('MovieTitle:N', sort='-x', title='Movie Title'),\n    text=alt.Text('AverageRating:Q', format='.2f')\n)\n\nchart = base.mark_bar() + base.mark_text(align='left', dx=2)\nchart.properties(title=\"Average Movie Ratings\")",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_labels.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "movie_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels",
        "NLQ": "Instead of showing wheat prices by year, can you create a horizontal bar chart showing average movie ratings from our database? I'd like to see movie titles on the y-axis with their average ratings displayed as bars extending to the right. Please sort the movies from highest to lowest rating, include the exact rating value next to each bar, and add a title \"Average Movie Ratings\" at the top. Make sure the axes are properly labeled as \"Movie Title\" and \"Average Rating\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/movie_1.sqlite')\nquery = '''\nSELECT \n    M.title AS MovieTitle,\n    AVG(R.stars) AS AverageRating\nFROM \n    Rating AS R\nJOIN \n    Movie AS M ON R.mID = M.mID\nGROUP BY \n    M.mID, M.title\nORDER BY \n    AverageRating DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('AverageRating:Q', title='Average Rating'),\n    y=alt.Y('MovieTitle:N', sort='-x', title='Movie Title'),\n    text=alt.Text('AverageRating:Q', format='.2f')\n)\n\nchart = base.mark_bar() + base.mark_text(align='left', dx=2)\nchart.properties(title=\"Average Movie Ratings\")",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_labels.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "movie_1",
        "chart_category": "Distributions",
        "chart_type": "violin_plot",
        "NLQ": "Can you create a chart showing the distribution of movie ratings across different years? I'd like to see how star ratings (from 1 to 5) are spread out, with each year having its own column. Make it look like those smooth density plots that are stacked horizontally. Please pull the data from our movie database instead of using random numbers. Keep the layout clean by removing grid lines and unnecessary axis labels, and put the year labels at the bottom. Also, label the y-axis as \"Rating Stars\" and use the year for coloring.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/movie_1.sqlite')\nquery = '''\nSELECT \n    Movie.year AS year, \n    Rating.stars AS stars\nFROM \n    Rating\nJOIN \n    Movie ON Rating.mID = Movie.mID\nWHERE \n    Rating.stars IS NOT NULL\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_density(\n    'stars',\n    as_=['stars', 'density'],\n    extent=[1, 5],\n    groupby=['year']\n).mark_area(orient='horizontal').encode(\n    alt.X('density:Q')\n        .stack('center')\n        .impute(None)\n        .title(None)\n        .axis(labels=False, values=[0], grid=False, ticks=True),\n    alt.Y('stars:Q', title='Rating Stars'),\n    alt.Color('year:N', title='Year'),\n    alt.Column('year:N')\n        .spacing(0)\n        .header(titleOrient='bottom', labelOrient='bottom', labelPadding=0)\n).configure_view(\n    stroke=None\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___violin_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "movie_1",
        "chart_category": "Distributions",
        "chart_type": "violin_plot",
        "NLQ": "Instead of showing car fuel efficiency by country, can you create a chart that shows how movie ratings are distributed across different years? I'd like to see the spread of star ratings for movies, with each year having its own column. Use a horizontal layout with smooth density curves rather than vertical violins, and color-code by year. Get the data from our movie database instead of using random numbers. Also, can you remove the grid lines and unnecessary axis labels to make it cleaner?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/movie_1.sqlite')\n\nquery = '''\nSELECT \n    Movie.year AS year, \n    Rating.stars AS stars\nFROM \n    Rating\nJOIN \n    Movie ON Rating.mID = Movie.mID\nWHERE \n    Rating.stars IS NOT NULL\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).transform_density(\n    'stars',\n    as_=['stars', 'density'],\n    extent=[1, 5],\n    groupby=['year']\n).mark_area(orient='horizontal').encode(\n    alt.X('density:Q')\n        .stack('center')\n        .impute(None)\n        .title(None)\n        .axis(labels=False, values=[0], grid=False, ticks=True),\n    alt.Y('stars:Q', title='Rating Stars'),\n    alt.Color('year:N', title='Year'),\n    alt.Column('year:N')\n        .spacing(0)\n        .header(titleOrient='bottom', labelOrient='bottom', labelPadding=0)\n).configure_view(\n    stroke=None\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___violin_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "museum_visit",
        "chart_category": "Distributions",
        "chart_type": "violin_plot",
        "NLQ": "Could you create a chart showing how much money visitors spend at different museums? I'd like to use my museum visit database instead of the car mileage data in the example. Keep the same style with those smooth density curves for each museum, but make it cleaner by removing unnecessary labels and grid lines. I want to see the total amount spent on the y-axis, with different museums shown in different colors. Also, could you put the museum names at the bottom instead of on top?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/museum_visit.sqlite')\n\nquery = '''\nSELECT \n    m.Name AS Museum_Name,\n    v.Total_spent\nFROM \n    visit AS v\nJOIN \n    museum AS m\nON \n    v.Museum_ID = m.Museum_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_density(\n    'Total_spent',\n    as_=['Total_spent', 'density'],\n    extent=[0, df['Total_spent'].max()],\n    groupby=['Museum_Name']\n).mark_area(orient='horizontal').encode(\n    alt.X('density:Q')\n        .stack('center')\n        .impute(None)\n        .title(None)\n        .axis(labels=False, values=[0], grid=False, ticks=True),\n    alt.Y('Total_spent:Q', title='Total Spent'),\n    alt.Color('Museum_Name:N', title='Museum'),\n    alt.Column('Museum_Name:N')\n        .spacing(0)\n        .header(titleOrient='bottom', labelOrient='bottom', labelPadding=0)\n).configure_view(\n    stroke=None\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___violin_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "museum_visit",
        "chart_category": "Distributions",
        "chart_type": "violin_plot",
        "NLQ": "Can you change my car fuel efficiency violin plot to show museum visitor spending data instead? I'd like to see how much money visitors spend at different museums using those smooth wavy shapes, but make them horizontal instead of vertical. Get the data from my museum database and use different colors for each museum. Also, can you arrange them side by side in columns with the museum names at the bottom? I want to see the spending distribution for each museum clearly labeled.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/museum_visit.sqlite')\n\nquery = '''\nSELECT \n    m.Name AS Museum_Name,\n    v.Total_spent\nFROM \n    visit AS v\nJOIN \n    museum AS m\nON \n    v.Museum_ID = m.Museum_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_density(\n    'Total_spent',\n    as_=['Total_spent', 'density'],\n    extent=[0, df['Total_spent'].max()],\n    groupby=['Museum_Name']\n).mark_area(orient='horizontal').encode(\n    alt.X('density:Q')\n        .stack('center')\n        .impute(None)\n        .title(None)\n        .axis(labels=False, values=[0], grid=False, ticks=True),\n    alt.Y('Total_spent:Q', title='Total Spent'),\n    alt.Color('Museum_Name:N', title='Museum'),\n    alt.Column('Museum_Name:N')\n        .spacing(0)\n        .header(titleOrient='bottom', labelOrient='bottom', labelPadding=0)\n).configure_view(\n    stroke=None\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___violin_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "musical",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels_based_on_measured_luminance",
        "NLQ": "Can you create a chart showing how many times each musical nominee has been nominated? I'd like to see the nominees sorted by their nomination count in descending order with horizontal bars. Please add the actual count numbers as labels inside the bars, positioned on the right side. Also, could you color-code the bars based on the nomination count and make sure the text labels are either black or white depending on how dark the bar color is so they're always readable?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/musical.sqlite')\nquery = '''\nSELECT Nominee, COUNT(*) AS NominationCount\nFROM musical\nGROUP BY Nominee\nORDER BY NominationCount DESC;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('NominationCount:Q').stack('zero'),\n    y=alt.Y('Nominee:O').sort('-x'),\n    text=alt.Text('NominationCount:Q', format='.0f')\n)\n\nbars = base.mark_bar(\n    tooltip=alt.expr(\"luminance(scale('color', datum.NominationCount))\")\n).encode(\n    color='NominationCount:Q'\n)\n\ntext = base.mark_text(\n    align='right',\n    dx=-3,\n    color=alt.expr(\"luminance(scale('color', datum.NominationCount)) > 0.5 ? 'black' : 'white'\")\n)\n\nbars + text",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_labels_based_on_measured_luminance.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "musical",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels_based_on_measured_luminance",
        "NLQ": "Can you change my chart to show how many times each musical nominee has been nominated? I'd like to use data from my musical database instead of the crop yield data. Keep the horizontal bar chart style with the nominees sorted by their nomination count, and make sure the text labels inside the bars are still visible with appropriate colors based on the bar darkness. I want to keep the same color-coding approach where the bars get darker as the values increase.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/musical.sqlite')\n\nquery = '''\nSELECT Nominee, COUNT(*) AS NominationCount\nFROM musical\nGROUP BY Nominee\nORDER BY NominationCount DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('NominationCount:Q').stack('zero'),\n    y=alt.Y('Nominee:O').sort('-x'),\n    text=alt.Text('NominationCount:Q', format='.0f')\n)\n\nbars = base.mark_bar(\n    tooltip=alt.expr(\"luminance(scale('color', datum.NominationCount))\")\n).encode(\n    color='NominationCount:Q'\n)\n\ntext = base.mark_text(\n    align='right',\n    dx=-3,\n    color=alt.expr(\"luminance(scale('color', datum.NominationCount)) > 0.5 ? 'black' : 'white'\")\n)\n\nbars + text",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_labels_based_on_measured_luminance.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "musical",
        "chart_category": "Distributions",
        "chart_type": "violin_plot",
        "NLQ": "Can you create a chart showing the age distribution of actors in Tony Award-nominated musicals? I'd like to see a side-by-side comparison with a violin plot or something similar. Please pull the data from our musical database, use different colors for each musical, and make it look clean by removing unnecessary grid lines and labels. I want to focus on the age ranges from about 15 to 70 years old, and have the musical names displayed at the bottom of each section.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/musical.sqlite')\n\nquery = '''\nSELECT m.Name AS Musical_Name, a.age AS Actor_Age\nFROM musical AS m\nJOIN actor AS a ON m.Musical_ID = a.Musical_ID\nWHERE m.Award = 'Tony Award' AND m.Result = 'Nominated'\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_density(\n    'Actor_Age',\n    as_=['Actor_Age', 'density'],\n    extent=[15, 70],\n    groupby=['Musical_Name']\n).mark_area(orient='horizontal').encode(\n    alt.X('density:Q')\n        .stack('center')\n        .impute(None)\n        .title(None)\n        .axis(labels=False, values=[0], grid=False, ticks=True),\n    alt.Y('Actor_Age:Q', title='Actor Age'),\n    alt.Color('Musical_Name:N', legend=alt.Legend(title=\"Musical\")),\n    alt.Column('Musical_Name:N')\n        .spacing(0)\n        .header(titleOrient='bottom', labelOrient='bottom', labelPadding=0)\n).configure_view(\n    stroke=None\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___violin_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "musical",
        "chart_category": "Distributions",
        "chart_type": "violin_plot",
        "NLQ": "I'd like to change my chart to show the age distribution of actors in Tony Award-nominated musicals. Instead of using the violin plots with MPG data for different countries, can you create a horizontal density plot using real data from a database? I want each musical to have its own column with a different color, and I'd like to show the actor ages on the y-axis instead of MPG. Also, can you remove the grid lines and unnecessary axis labels to make it cleaner?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/musical.sqlite')\nquery = '''\nSELECT m.Name AS Musical_Name, a.age AS Actor_Age\nFROM musical AS m\nJOIN actor AS a ON m.Musical_ID = a.Musical_ID\nWHERE m.Award = 'Tony Award' AND m.Result = 'Nominated'\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_density(\n    'Actor_Age',\n    as_=['Actor_Age', 'density'],\n    extent=[15, 70],\n    groupby=['Musical_Name']\n).mark_area(orient='horizontal').encode(\n    alt.X('density:Q')\n        .stack('center')\n        .impute(None)\n        .title(None)\n        .axis(labels=False, values=[0], grid=False, ticks=True),\n    alt.Y('Actor_Age:Q', title='Actor Age'),\n    alt.Color('Musical_Name:N', legend=alt.Legend(title=\"Musical\")),\n    alt.Column('Musical_Name:N')\n        .spacing(0)\n        .header(titleOrient='bottom', labelOrient='bottom', labelPadding=0)\n).configure_view(\n    stroke=None\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___violin_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "music_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels_based_on_measured_luminance",
        "NLQ": "Can you create a bar chart showing the total number of songs per genre from my music database? I'd like to see the genres sorted with the highest count at the top, and I want each bar to be colored based on the song count. Please add the actual count numbers as labels inside the bars, making sure they're visible by using black or white text depending on the bar color. Also, add a title \"Total Number of Songs per Genre\" and make sure the x-axis is labeled \"Total Number of Songs\" and the y-axis is labeled \"Genre\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/music_1.sqlite')\n\nquery = '''\nSELECT \n    g.g_name AS genre_name, \n    COUNT(s.song_name) AS song_count\nFROM \n    genre AS g\nLEFT JOIN \n    song AS s ON g.g_name = s.genre_is\nGROUP BY \n    g.g_name\nORDER BY \n    song_count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('song_count:Q', title='Total Number of Songs'),\n    y=alt.Y('genre_name:O', title='Genre', sort='-x'),\n    text=alt.Text('song_count:Q', format='.0f')\n)\n\nbars = base.mark_bar(\n    tooltip=alt.expr(\"luminance(scale('color', datum.song_count))\")\n).encode(\n    color='song_count:Q'\n)\n\ntext = base.mark_text(\n    align='right',\n    dx=-3,\n    color=alt.expr(\"luminance(scale('color', datum.song_count)) > 0.5 ? 'black' : 'white'\")\n)\n\nchart = bars + text\nchart.properties(title=\"Total Number of Songs per Genre\")",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_labels_based_on_measured_luminance.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "music_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels_based_on_measured_luminance",
        "NLQ": "Could you create a horizontal bar chart showing the number of songs per genre from my music database? I'd like to see the genres sorted with the highest count at the top, and I want each bar to be labeled with its value. Please use a color gradient for the bars where the text color adjusts to be either black or white depending on the background darkness. Also, add a title that says \"Total Number of Songs per Genre\" and make sure the x-axis is labeled \"Total Number of Songs\" and the y-axis is labeled \"Genre\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/music_1.sqlite')\n\nquery = '''\nSELECT \n    g.g_name AS genre_name, \n    COUNT(s.song_name) AS song_count\nFROM \n    genre AS g\nLEFT JOIN \n    song AS s ON g.g_name = s.genre_is\nGROUP BY \n    g.g_name\nORDER BY \n    song_count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('song_count:Q', title='Total Number of Songs'),\n    y=alt.Y('genre_name:O', title='Genre', sort='-x'),\n    text=alt.Text('song_count:Q', format='.0f')\n)\n\nbars = base.mark_bar(\n    tooltip=alt.expr(\"luminance(scale('color', datum.song_count))\")\n).encode(\n    color='song_count:Q'\n)\n\ntext = base.mark_text(\n    align='right',\n    dx=-3,\n    color=alt.expr(\"luminance(scale('color', datum.song_count)) > 0.5 ? 'black' : 'white'\")\n)\n\nchart = bars + text\nchart.properties(title=\"Total Number of Songs per Genre\")",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_labels_based_on_measured_luminance.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "music_1",
        "chart_category": "Interactive Charts",
        "chart_type": "bar_chart_with_highlighting_on_hover_and_selection_on_click",
        "NLQ": "Can you create a bar chart showing the number of songs for each music genre, but only include genres with ratings above 7? I'd like to use data from my music database instead of the sample data. Make the bars blue with black outlines and add a tooltip that shows the genre name, total songs, and genre rating when I hover over a bar. Keep the interactive features where bars highlight when I hover over them and stay darker when I click on them. Also, can you set the chart height to 200 pixels and add proper titles for the axes - \"Genre\" for the x-axis and \"Total Songs\" for the y-axis?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/music_1.sqlite')\nquery = '''\nSELECT \n    g.g_name AS genre_name,\n    COUNT(s.song_name) AS total_songs,\n    g.rating AS genre_rating\nFROM \n    genre AS g\nLEFT JOIN \n    song AS s ON g.g_name = s.genre_is\nGROUP BY \n    g.g_name\nORDER BY \n    total_songs DESC;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nselect = alt.selection_point(name=\"select\", on=\"click\")\nhighlight = alt.selection_point(name=\"highlight\", on=\"pointerover\", empty=False)\n\nstroke_width = (\n    alt.when(select).then(alt.value(2))\n    .when(highlight).then(alt.value(1))\n    .otherwise(alt.value(0))\n)\n\nchart = alt.Chart(df, height=200).mark_bar(\n    fill=\"#4C78A8\", stroke=\"black\", cursor=\"pointer\"\n).encode(\n    x=alt.X(\"genre_name:N\", title=\"Genre\"),\n    y=alt.Y(\"total_songs:Q\", title=\"Total Songs\"),\n    fillOpacity=alt.when(select).then(alt.value(1)).otherwise(alt.value(0.3)),\n    strokeWidth=stroke_width,\n    tooltip=[\"genre_name\", \"total_songs\", \"genre_rating\"]\n).transform_filter(\n    alt.datum.genre_rating > 7\n).add_params(\n    select, highlight\n).configure_scale(\n    bandPaddingInner=0.2\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___bar_chart_with_highlighting_on_hover_and_selection_on_click.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "music_4",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_at_mean",
        "NLQ": "Instead of showing wheat production by year, can you create a bar chart that shows the number of songs each artist has on the top charts? I'd like to see the artist names on the x-axis and the song count on the y-axis. Also, could you add a red line across the chart showing the average number of songs? Make the chart a bit wider too, around 600 pixels.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/music_4.sqlite')\n\nquery = '''\nSELECT \n    a.Artist, COUNT(v.Song) AS Song_Count\nFROM \n    artist AS a\nJOIN \n    volume AS v ON a.Artist_ID = v.Artist_ID\nGROUP BY \n    a.Artist\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Artist:N', title='Artist'),\n    y=alt.Y('Song_Count:Q', title='Number of Songs on Top')\n)\n\nrule = alt.Chart(df).mark_rule(color='red').encode(\n    y='mean(Song_Count):Q'\n)\n\n(bar + rule).properties(width=600)",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_line_at_mean.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "music_4",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_at_mean",
        "NLQ": "I have this bar chart showing wheat production over the years with a red line for the average. Could you change it to show music data instead? I'd like to see a bar chart of artists and how many songs each one has on the top charts, but still keep that red line showing the average number of songs across all artists.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/music_4.sqlite')\n\nquery = '''\nSELECT \n    a.Artist, COUNT(v.Song) AS Song_Count\nFROM \n    artist AS a\nJOIN \n    volume AS v ON a.Artist_ID = v.Artist_ID\nGROUP BY \n    a.Artist\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Artist:N', title='Artist'),\n    y=alt.Y('Song_Count:Q', title='Number of Songs on Top')\n)\n\nrule = alt.Chart(df).mark_rule(color='red').encode(\n    y='mean(Song_Count):Q'\n)\n\n(bar + rule).properties(width=600)",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_line_at_mean.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "music_4",
        "chart_category": "Interactive Charts",
        "chart_type": "bar_chart_with_highlighting_on_hover_and_selection_on_click",
        "NLQ": "Can you create a bar chart showing the total number of weeks each artist has spent at the top of the charts? I need to pull this data from my music database instead of using the sample data. Make the bars blue with black outlines, and keep the interactive features where I can hover over or click on bars to highlight them. Also, add proper titles for the x-axis (\"Artist\") and y-axis (\"Total Weeks on Top\"), and adjust the spacing between the bars to make it look cleaner. The chart should be about 200 pixels tall.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/music_4.sqlite')\nquery = '''\nSELECT \n    a.Artist AS Artist_Name,\n    SUM(v.Weeks_on_Top) AS Total_Weeks_on_Top\nFROM \n    artist AS a\nJOIN \n    volume AS v ON a.Artist_ID = v.Artist_ID\nGROUP BY \n    a.Artist\nORDER BY \n    Total_Weeks_on_Top DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nselect = alt.selection_point(name=\"select\", on=\"click\")\nhighlight = alt.selection_point(name=\"highlight\", on=\"pointerover\", empty=False)\n\nstroke_width = (\n    alt.when(select).then(alt.value(2, empty=False))\n    .when(highlight).then(alt.value(1))\n    .otherwise(alt.value(0))\n)\n\nchart = alt.Chart(df, height=200).mark_bar(\n    fill=\"#4C78A8\", stroke=\"black\", cursor=\"pointer\"\n).encode(\n    x=alt.X(\"Artist_Name:N\", title=\"Artist\"),\n    y=alt.Y(\"Total_Weeks_on_Top:Q\", title=\"Total Weeks on Top\"),\n    fillOpacity=alt.when(select).then(alt.value(1)).otherwise(alt.value(0.3)),\n    strokeWidth=stroke_width,\n).configure_scale(bandPaddingInner=0.2).add_params(select, highlight)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___bar_chart_with_highlighting_on_hover_and_selection_on_click.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "network_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_at_mean",
        "NLQ": "Can you create a bar chart showing the number of friends each high school student has? I need to pull this data from my SQLite database called 'network_1.sqlite' using the Highschooler and Friend tables. Put the student names on the x-axis and the number of friends on the y-axis. Also, add a red line across the chart to show the average number of friends. Please make the chart wider (about 600 pixels) and add a title that says \"Number of Friends per Student with Average Line\". Make sure the axis labels are clear too - \"Student Name\" and \"Number of Friends\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/network_1.sqlite')\nquery = '''\nSELECT \n    T1.ID AS student_id, \n    T1.name AS student_name, \n    COUNT(T2.friend_id) AS friend_count\nFROM \n    Highschooler AS T1\nLEFT JOIN \n    Friend AS T2 ON T1.ID = T2.student_id\nGROUP BY \n    T1.ID, T1.name\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x=alt.X('student_name:N', title='Student Name'),\n    y=alt.Y('friend_count:Q', title='Number of Friends')\n)\nrule = alt.Chart(df).mark_rule(color='red').encode(\n    y='mean(friend_count):Q'\n)\nchart = (bar + rule).properties(\n    width=600,\n    title='Number of Friends per Student with Average Line'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_line_at_mean.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "network_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_at_mean",
        "NLQ": "I have a bar chart showing wheat production by year, but I'd like to change it to show the number of friends each high school student has instead. Can you create a new chart that pulls data from my student database, showing student names on the x-axis and their friend count on the y-axis? Please keep the red line showing the average like in my original chart, and add a proper title that explains what the visualization is showing.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/network_1.sqlite')\n\nquery = '''\nSELECT \n    T1.ID AS student_id, \n    T1.name AS student_name, \n    COUNT(T2.friend_id) AS friend_count\nFROM \n    Highschooler AS T1\nLEFT JOIN \n    Friend AS T2 ON T1.ID = T2.student_id\nGROUP BY \n    T1.ID, T1.name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x=alt.X('student_name:N', title='Student Name'),\n    y=alt.Y('friend_count:Q', title='Number of Friends')\n)\n\nrule = alt.Chart(df).mark_rule(color='red').encode(\n    y='mean(friend_count):Q'\n)\n\nchart = (bar + rule).properties(\n    width=600,\n    title='Number of Friends per Student with Average Line'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_line_at_mean.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "network_1",
        "chart_category": "Interactive Charts",
        "chart_type": "bar_chart_with_highlighting_on_hover_and_selection_on_click",
        "NLQ": "Can you create a bar chart that shows how many friends each high school student has from my database? I'd like the bars to be blue with black outlines, and I want them to highlight when I hover over them and stay highlighted when I click on them. Please label the x-axis as \"Student Name\" and the y-axis as \"Number of Friends\", and sort the chart to show students with the most friends first. Also, can you add some spacing between the bars and make the chart height 200 pixels?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/network_1.sqlite')\n\nquery = '''\nSELECT \n    h.name AS student_name,\n    COUNT(f.friend_id) AS friend_count\nFROM \n    Highschooler AS h\nLEFT JOIN \n    Friend AS f ON h.ID = f.student_id\nGROUP BY \n    h.ID, h.name\nORDER BY \n    friend_count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nselect = alt.selection_point(name=\"select\", on=\"click\")\nhighlight = alt.selection_point(name=\"highlight\", on=\"pointerover\", empty=False)\n\nstroke_width = (\n    alt.when(select).then(alt.value(2))\n    .when(highlight).then(alt.value(1))\n    .otherwise(alt.value(0))\n)\n\nchart = alt.Chart(df, height=200).mark_bar(\n    fill=\"#4C78A8\", stroke=\"black\", cursor=\"pointer\"\n).encode(\n    x=alt.X(\"student_name:N\", title=\"Student Name\"),\n    y=alt.Y(\"friend_count:Q\", title=\"Number of Friends\"),\n    fillOpacity=alt.when(select).then(alt.value(1)).otherwise(alt.value(0.3)),\n    strokeWidth=stroke_width,\n).configure_scale(bandPaddingInner=0.2).add_params(select, highlight)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___bar_chart_with_highlighting_on_hover_and_selection_on_click.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "network_2",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_at_mean",
        "NLQ": "Could you help me create a chart that shows the average number of years people have been friends, grouped by their job titles? I'd like to see bars for each job title and a red line showing the overall average across all jobs. Please make the chart wider (about 600 pixels) and add a title \"Average Friendship Duration by Job Title\". Also, can you label the x-axis as \"Job Title\" and the y-axis as \"Average Friendship Duration (Years)\"? I need this data to come from my database that has information about people and their friendships.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/network_2.sqlite')\n\nquery = '''\nSELECT \n    P.job AS job_title,\n    AVG(PF.year) AS avg_friendship_years\nFROM \n    PersonFriend AS PF\nJOIN \n    Person AS P ON PF.name = P.name\nGROUP BY \n    P.job\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x=alt.X('job_title:N', title='Job Title'),\n    y=alt.Y('avg_friendship_years:Q', title='Average Friendship Duration (Years)')\n)\n\nmean_value = df['avg_friendship_years'].mean()\nrule = alt.Chart(df).mark_rule(color='red').encode(\n    y=alt.Y(f'{mean_value}:Q', title='Overall Average')\n)\n\nchart = (bar + rule).properties(\n    width=600,\n    title='Average Friendship Duration by Job Title'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_line_at_mean.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "network_2",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_at_mean",
        "NLQ": "I have this chart showing wheat production by year from 1810 to 1940, but I need something completely different. Could you help me create a chart that shows the average number of years people have been friends, grouped by their job titles? I need to pull this data from my SQLite database called 'network_2.sqlite'. I'd like to see bars for each job title and a red line showing the overall average friendship duration across all jobs. Also, please add a proper title 'Average Friendship Duration by Job Title' and label the axes clearly with 'Job Title' and 'Average Friendship Duration (Years)'.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/network_2.sqlite')\n\nquery = '''\nSELECT \n    P.job AS job_title,\n    AVG(PF.year) AS avg_friendship_years\nFROM \n    PersonFriend AS PF\nJOIN \n    Person AS P ON PF.name = P.name\nGROUP BY \n    P.job\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x=alt.X('job_title:N', title='Job Title'),\n    y=alt.Y('avg_friendship_years:Q', title='Average Friendship Duration (Years)')\n)\n\nmean_value = df['avg_friendship_years'].mean()\nrule = alt.Chart(df).mark_rule(color='red').encode(\n    y=alt.Y(f'{mean_value}:Q', title='Overall Average')\n)\n\nchart = (bar + rule).properties(\n    width=600,\n    title='Average Friendship Duration by Job Title'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_line_at_mean.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "network_2",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_average",
        "NLQ": "Can you change this precipitation chart to show average years of friendship by city instead? I'd like to keep the bar chart format with the same interactive selection feature, but replace the monthly precipitation data with city data from our network database. Please label the x-axis as \"City\" and the y-axis as \"Average Years of Friendship\". Also, could you make the horizontal line red and a bit thicker to better highlight the overall average across cities?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/network_2.sqlite')\n\nquery = '''\nSELECT \n    P.city AS city, \n    AVG(PF.year) AS avg_years\nFROM \n    PersonFriend AS PF\nJOIN \n    Person AS P ON PF.name = P.name\nGROUP BY \n    P.city\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval(encodings=['x'])\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X('city:N', title='City'),\n    y=alt.Y('avg_years:Q', title='Average Years of Friendship'),\n    opacity=alt.condition(brush, alt.value(1), alt.value(0.7)),\n).add_params(\n    brush\n)\n\nline = alt.Chart(df).mark_rule(color='firebrick').encode(\n    y='mean(avg_years):Q',\n    size=alt.SizeValue(3)\n).transform_filter(\n    brush\n)\n\nchart = alt.layer(bars, line)\nchart.display()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_average.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "news_report",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_on_dual_axis",
        "NLQ": "I'd like to create a chart showing the number of events per year and the average experience of journalists covering those events. Can you pull this data from our news_report database? I want to see event counts as bars and journalist experience as a red line on the same graph, but with separate scales so both are clearly visible. Please label the axes properly and add a title that explains what we're looking at.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/news_report.sqlite')\n\nquery = '''\nSELECT\n    CAST(SUBSTR(T1.Date, LENGTH(T1.Date) - 3) AS INTEGER) AS EventYear,\n    COUNT(T1.Event_ID) AS NumberOfEvents,\n    AVG(T3.Years_working) AS AverageJournalistExperience\nFROM\n    event AS T1\nJOIN\n    news_report AS T2 ON T1.Event_ID = T2.Event_ID\nJOIN\n    journalist AS T3 ON T2.journalist_ID = T3.journalist_ID\nGROUP BY\n    EventYear\nORDER BY\n    EventYear;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('EventYear:O', title='Event Year')\n)\n\nbars = base.mark_bar().encode(\n    y=alt.Y('NumberOfEvents:Q', title='Number of Events')\n)\n\nline = base.mark_line(color='red').encode(\n    y=alt.Y('AverageJournalistExperience:Q', title='Average Journalist Experience')\n)\n\nchart = (bars + line).resolve_scale(\n    y='independent'\n).properties(\n    title='Events per Year and Average Journalist Experience'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_line_on_dual_axis.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "news_report",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_on_dual_axis",
        "NLQ": "I'd like to create a chart showing the number of events per year and the average experience of journalists covering those events. Can you pull this data from our news_report database? I want to see bars representing the event counts and a red line showing journalist experience on the same graph, but with separate scales so both are clearly visible. Please label the axes properly and add a title that explains what we're looking at.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/news_report.sqlite')\n\nquery = '''\nSELECT\n    CAST(SUBSTR(T1.Date, LENGTH(T1.Date) - 3) AS INTEGER) AS EventYear,\n    COUNT(T1.Event_ID) AS NumberOfEvents,\n    AVG(T3.Years_working) AS AverageJournalistExperience\nFROM\n    event AS T1\nJOIN\n    news_report AS T2 ON T1.Event_ID = T2.Event_ID\nJOIN\n    journalist AS T3 ON T2.journalist_ID = T3.journalist_ID\nGROUP BY\n    EventYear\nORDER BY\n    EventYear;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('EventYear:O', title='Event Year')\n)\n\nbars = base.mark_bar().encode(\n    y=alt.Y('NumberOfEvents:Q', title='Number of Events')\n)\n\nline = base.mark_line(color='red').encode(\n    y=alt.Y('AverageJournalistExperience:Q', title='Average Journalist Experience')\n)\n\nchart = (bars + line).resolve_scale(\n    y='independent'\n).properties(\n    title='Events per Year and Average Journalist Experience'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_line_on_dual_axis.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "news_report",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_average",
        "NLQ": "I have a database with event information including venues, dates, and attendance numbers. Can you create a bar chart showing the average attendance for each venue? I'd like to be able to select a date range to filter the data. Please add a red horizontal line showing the overall average attendance across all venues. Make the chart wider (about 600px) and taller (about 400px), and give it a title \"Average Event Attendance by Venue with Date Range Selection\". Also, can you add tooltips so when I hover over a bar I can see the venue name and its average attendance, and when I hover over the line I can see the overall average attendance value?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/news_report.sqlite')\nquery = '''\nSELECT Venue, Date, Event_Attendance\nFROM event\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\ndf['Date'] = pd.to_datetime(df['Date'], format='%d %B %Y')\nbrush = alt.selection_interval(encodings=['x'])\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Venue:N', title='Venue'),\n    y=alt.Y('mean(Event_Attendance):Q', title='Average Attendance'),\n    opacity=alt.condition(brush, alt.value(1), alt.value(0.7)),\n    tooltip=['Venue:N', alt.Tooltip('mean(Event_Attendance):Q', title='Avg Attendance')]\n).add_params(\n    brush\n)\nline = alt.Chart(df).mark_rule(color='firebrick').encode(\n    y='mean(Event_Attendance):Q',\n    size=alt.SizeValue(3),\n    tooltip=[alt.Tooltip('mean(Event_Attendance):Q', title='Overall Avg Attendance')]\n).transform_filter(\n    brush\n)\nchart = alt.layer(bars, line).properties(\n    width=600,\n    height=400,\n    title='Average Event Attendance by Venue with Date Range Selection'\n)\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_average.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "orchestra",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_on_dual_axis",
        "NLQ": "I have some data about orchestra performances in a database. Could you create a chart that shows the different types of performances and compares their average attendance with their average official ratings? I'd like the attendance shown as bars and the ratings as a red line running across. Make sure the scales for attendance and ratings are independent since they measure different things. Can you make the chart a bit wider, around 600 pixels, so it's easier to read?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/orchestra.sqlite')\n\nquery = \"\"\"\nSELECT\n    P.Type,\n    AVG(S.Attendance) AS Average_Attendance,\n    AVG(P.\"Official_ratings_(millions)\") AS Average_Official_Ratings\nFROM Performance AS P\nJOIN Show AS S\n    ON P.Performance_ID = S.Performance_ID\nGROUP BY\n    P.Type;\n\"\"\"\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x='Type:N'\n).properties(\n    width=600\n)\n\nbar = base.mark_bar().encode(\n    y='Average_Attendance:Q'\n)\n\nline = base.mark_line(color='red').encode(\n    y='Average_Official_Ratings:Q'\n)\n\n(bar + line).resolve_scale(\n    y='independent'\n)",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_line_on_dual_axis.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "orchestra",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_on_dual_axis",
        "NLQ": "I have this chart showing wheat and wages data over time from 1810 to 1940, but I'd like to create something completely different. Could you help me create a chart that shows the different types of performances from my orchestra database and compares their average attendance with their average official ratings? I'd like the attendance as bars and the ratings as a red line running across, with everything organized neatly side by side. The data should be pulled directly from my SQLite database instead of using random numbers.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/orchestra.sqlite')\n\nquery = \"\"\"\nSELECT\n    P.Type,\n    AVG(S.Attendance) AS Average_Attendance,\n    AVG(P.\"Official_ratings_(millions)\") AS Average_Official_Ratings\nFROM Performance AS P\nJOIN Show AS S\n    ON P.Performance_ID = S.Performance_ID\nGROUP BY\n    P.Type;\n\"\"\"\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x='Type:N'\n).properties(\n    width=600\n)\n\nbar = base.mark_bar().encode(\n    y='Average_Attendance:Q'\n)\n\nline = base.mark_line(color='red').encode(\n    y='Average_Official_Ratings:Q'\n)\n\n(bar + line).resolve_scale(\n    y='independent'\n)",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_line_on_dual_axis.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "orchestra",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_average",
        "NLQ": "I want to create a chart showing official ratings of different performance types over time from my orchestra database. Can you make a bar chart where each performance type has its own color? I'd like to keep the interactive brushing feature, but instead of precipitation data, use the official ratings in millions from my database. Also, please add a red line showing the average rating and make it a bit thicker. Finally, add a title that explains what the chart is showing.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/orchestra.sqlite')\nquery = '''\nSELECT Date, Type, `Official_ratings_(millions)` AS Official_ratings\nFROM performance;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval(encodings=['x'])\n\nbars = alt.Chart(df).mark_bar().encode(\n    x='Date:O',\n    y='Official_ratings:Q',\n    color='Type:N',\n    opacity=alt.condition(brush, alt.value(1), alt.value(0.7))\n).add_params(brush)\n\nline = alt.Chart(df).mark_rule(color='firebrick').encode(\n    y='mean(Official_ratings):Q',\n    size=alt.SizeValue(3)\n).transform_filter(brush)\n\nchart = alt.layer(bars, line).properties(\n    title='Official Ratings of Performance Types Over Time with Average Line (Interactive)'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_average.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "party_host",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_on_dual_axis",
        "NLQ": "Can you create a chart showing the total number of hosts for each party theme as bars and the average active years as a red line? I need the data to come from my party_host database, specifically showing party themes on the x-axis. Make sure the bars and line are on separate scales so both are clearly visible. Also, please make the chart wider - about 600 pixels should work well.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/party_host.sqlite')\nquery = '''\nSELECT \n    p.Party_Theme,\n    SUM(p.Number_of_hosts) AS Total_Hosts,\n    AVG(CAST(p.Last_year AS INT) - CAST(p.First_year AS INT)) AS Avg_Active_Years\nFROM \n    party AS p\nGROUP BY \n    p.Party_Theme\nORDER BY \n    Total_Hosts DESC;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(x=alt.X('Party_Theme:N', title='Party Theme'))\nbar = base.mark_bar().encode(\n    y=alt.Y('Total_Hosts:Q', title='Total Number of Hosts')\n)\nline = base.mark_line(color='red').encode(\n    y=alt.Y('Avg_Active_Years:Q', title='Average Active Years')\n)\nchart = (bar + line).resolve_scale(y='independent').properties(width=600)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_line_on_dual_axis.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "party_host",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_line_on_dual_axis",
        "NLQ": "Can you create a chart showing party themes on the x-axis with two different metrics: the total number of hosts for each theme as bars, and the average number of active years as a red line? I'd like to pull this data from my party_host database, sort the themes by the number of hosts in descending order, and make sure the bar chart and line chart have independent scales. Please make it wider than the default size.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/party_host.sqlite')\n\nquery = '''\nSELECT \n    p.Party_Theme,\n    SUM(p.Number_of_hosts) AS Total_Hosts,\n    AVG(CAST(p.Last_year AS INT) - CAST(p.First_year AS INT)) AS Avg_Active_Years\nFROM \n    party AS p\nGROUP BY \n    p.Party_Theme\nORDER BY \n    Total_Hosts DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(x=alt.X('Party_Theme:N', title='Party Theme'))\n\nbar = base.mark_bar().encode(\n    y=alt.Y('Total_Hosts:Q', title='Total Number of Hosts')\n)\n\nline = base.mark_line(color='red').encode(\n    y=alt.Y('Avg_Active_Years:Q', title='Average Active Years')\n)\n\nchart = (bar + line).resolve_scale(y='independent').properties(width=600)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_line_on_dual_axis.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "party_people",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_negative_values",
        "NLQ": "I want to create a bar chart showing the net change in political party membership over time. Instead of using random data like in the example, can you pull the actual membership data from our party_people database? Make the bars blue when membership increases and orange when it decreases. Also, add a clear title \"Net Change in Political Party Membership Over Time\" and proper axis labels. Can you make the chart wider too, about 600 pixels?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/party_people.sqlite')\n\nquery = '''\nWITH MembershipYears AS (\n    SELECT \n        CAST(SUBSTR(In_office, 1, 4) AS INTEGER) AS StartYear,\n        CASE \n            WHEN Instr(In_office, '–') > 0 THEN \n                CASE \n                    WHEN SUBSTR(In_office, Instr(In_office, '–') + 1) = 'present' THEN strftime('%Y', 'now')\n                    ELSE CAST(SUBSTR(In_office, Instr(In_office, '–') + 1) AS INTEGER)\n                END\n            ELSE CAST(SUBSTR(In_office, 1, 4) AS INTEGER)\n        END AS EndYear\n    FROM member\n),\nYearlyMembership AS (\n    SELECT \n        Year,\n        SUM(CASE WHEN Year BETWEEN StartYear AND EndYear THEN 1 ELSE -1 END) AS NetChange\n    FROM MembershipYears,\n         (SELECT DISTINCT CAST(SUBSTR(In_office, 1, 4) AS INTEGER) AS Year FROM member)\n    GROUP BY Year\n)\nSELECT Year, NetChange\nFROM YearlyMembership\nORDER BY Year;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\npredicate = alt.datum.NetChange > 0\ncolor = alt.when(predicate).then(alt.value(\"steelblue\")).otherwise(alt.value(\"orange\"))\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"Year:O\", title=\"Year\"),\n    y=alt.Y(\"NetChange:Q\", title=\"Net Change in Membership\"),\n    color=color\n).properties(width=600, title=\"Net Change in Political Party Membership Over Time\")\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_negative_values.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "party_people",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_negative_values",
        "NLQ": "I want to create a chart that shows the net change in political party membership over time. Instead of using the random data in my example, can you pull the real membership data from our SQLite database? I'd like to keep the same color scheme with blue bars for positive changes and orange bars for negative changes. Make sure to label the x-axis as \"Year\" and the y-axis as \"Net Change in Membership\" and add a title that says \"Net Change in Political Party Membership Over Time\". Can you make the chart wider too, around 600 pixels?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/party_people.sqlite')\n\nquery = '''\nWITH MembershipYears AS (\n    SELECT \n        CAST(SUBSTR(In_office, 1, 4) AS INTEGER) AS StartYear,\n        CASE \n            WHEN Instr(In_office, '–') > 0 THEN \n                CASE \n                    WHEN SUBSTR(In_office, Instr(In_office, '–') + 1) = 'present' THEN strftime('%Y', 'now')\n                    ELSE CAST(SUBSTR(In_office, Instr(In_office, '–') + 1) AS INTEGER)\n                END\n            ELSE CAST(SUBSTR(In_office, 1, 4) AS INTEGER)\n        END AS EndYear\n    FROM member\n),\nYearlyMembership AS (\n    SELECT \n        Year,\n        SUM(CASE WHEN Year BETWEEN StartYear AND EndYear THEN 1 ELSE -1 END) AS NetChange\n    FROM MembershipYears,\n         (SELECT DISTINCT CAST(SUBSTR(In_office, 1, 4) AS INTEGER) AS Year FROM member)\n    GROUP BY Year\n)\nSELECT Year, NetChange\nFROM YearlyMembership\nORDER BY Year;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\npredicate = alt.datum.NetChange > 0\ncolor = alt.when(predicate).then(alt.value(\"steelblue\")).otherwise(alt.value(\"orange\"))\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"Year:O\", title=\"Year\"),\n    y=alt.Y(\"NetChange:Q\", title=\"Net Change in Membership\"),\n    color=color\n).properties(width=600, title=\"Net Change in Political Party Membership Over Time\")\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_negative_values.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "party_people",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_chart_with_aggregation",
        "NLQ": "Can you create a bar chart showing the number of political parties in each region? I'd like to use my party_people database to pull this information. The chart should have regions on the x-axis and the count of parties on the y-axis. Please add a slider that lets me filter by the year they took office, with bars for years above the threshold showing in blue and earlier years in light gray. Also, give the chart a title \"Number of Political Parties per Region by Office Year\" and make sure the axes are properly labeled.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/party_people.sqlite')\nquery = '''\nSELECT\n    r.Region_name,\n    COUNT(p.Party_ID) AS NumberOfParties,\n    CAST(SUBSTR(p.Took_office, 1, 4) AS INTEGER) AS OfficeYear\nFROM region AS r\nJOIN party AS p ON r.Region_ID = p.Region_ID\nGROUP BY r.Region_name, OfficeYear\nORDER BY r.Region_name, OfficeYear\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nslider = alt.binding_range(min=df['OfficeYear'].min(), max=df['OfficeYear'].max(), step=1, name='Office Year Threshold:')\nthreshold = alt.param(name=\"year_threshold\", value=df['OfficeYear'].min(), bind=slider)\n\nchart = alt.layer(\n    alt.Chart(df).mark_bar().encode(\n        x=alt.X('Region_name:N', title='Region'),\n        y=alt.Y('NumberOfParties:Q', title='Number of Parties'),\n        color=alt.condition(\n            alt.datum.OfficeYear >= threshold,\n            alt.value('steelblue'),\n            alt.value('lightgray')\n        )\n    ).transform_filter(\n        alt.datum.OfficeYear >= threshold\n    ),\n    alt.Chart(df).mark_bar().encode(\n        x=alt.X('Region_name:N', title='Region'),\n        y=alt.Y('NumberOfParties:Q', title='Number of Parties'),\n        color=alt.value('lightgray')\n    ).transform_filter(\n        alt.datum.OfficeYear < threshold\n    )\n).add_params(\n    threshold\n).properties(\n    title='Number of Political Parties per Region by Office Year'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_chart_with_aggregation.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "pets_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_range",
        "NLQ": "Can you create a chart showing the weight ranges for different types of pets from our database? I'd like horizontal bars with rounded corners instead of the temperature chart. Make the bars thinner and add a title \"Weight Range by Pet Type\" with a subtitle explaining it shows minimum and maximum weights. Please label both the minimum and maximum weight values directly on the bars - put the minimum weight on the left side and the maximum on the right side. Also, rename the x-axis to \"Weight Range (kg)\" and the y-axis to \"Pet Type\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/pets_1.sqlite')\nquery = '''\nSELECT \n    Pets.PetType,\n    MIN(Pets.weight) AS min_weight,\n    MAX(Pets.weight) AS max_weight\nFROM \n    Pets\nGROUP BY \n    Pets.PetType\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar(cornerRadius=10, height=15).encode(\n    x=alt.X('min_weight:Q').scale(domain=[0, df['max_weight'].max() + 2]).title('Weight Range (kg)'),\n    x2='max_weight:Q',\n    y=alt.Y('PetType:O').title('Pet Type')\n)\n\ntext_min = alt.Chart(df).mark_text(align='right', dx=-5).encode(\n    x='min_weight:Q',\n    y=alt.Y('PetType:O'),\n    text='min_weight:Q'\n)\n\ntext_max = alt.Chart(df).mark_text(align='left', dx=5).encode(\n    x='max_weight:Q',\n    y=alt.Y('PetType:O'),\n    text='max_weight:Q'\n)\n\n(bar + text_min + text_max).properties(\n    title=alt.Title(text='Weight Range by Pet Type', subtitle='Minimum and Maximum Weight for Each Pet Type')\n)",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_range.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "pets_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_range",
        "NLQ": "Can you create a chart showing the weight ranges for different pet types from our database? I'd like horizontal bars showing the minimum to maximum weight for each type of pet, with rounded corners on the bars. Please add the actual minimum and maximum weight values as labels at each end of the bars. Also, give it a title \"Weight Range by Pet Type\" with a subtitle explaining it shows minimum and maximum weights for each pet type.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/pets_1.sqlite')\nquery = '''\nSELECT \n    Pets.PetType,\n    MIN(Pets.weight) AS min_weight,\n    MAX(Pets.weight) AS max_weight\nFROM \n    Pets\nGROUP BY \n    Pets.PetType\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar(cornerRadius=10, height=15).encode(\n    x=alt.X('min_weight:Q').scale(domain=[0, df['max_weight'].max() + 2]).title('Weight Range (kg)'),\n    x2='max_weight:Q',\n    y=alt.Y('PetType:O').title('Pet Type')\n)\n\ntext_min = alt.Chart(df).mark_text(align='right', dx=-5).encode(\n    x='min_weight:Q',\n    y=alt.Y('PetType:O'),\n    text='min_weight:Q'\n)\n\ntext_max = alt.Chart(df).mark_text(align='left', dx=5).encode(\n    x='max_weight:Q',\n    y=alt.Y('PetType:O'),\n    text='max_weight:Q'\n)\n\n(bar + text_min + text_max).properties(\n    title=alt.Title(text='Weight Range by Pet Type', subtitle='Minimum and Maximum Weight for Each Pet Type')\n)",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_range.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "pets_1",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_chart_with_cross-highlight",
        "NLQ": "Can you change my movie ratings visualization to show the relationship between student ages and pet types? I'd like a heatmap showing student age groups on the x-axis and different pet types on the y-axis, with color intensity showing the total number of pets in each group. Use a greenblue color scheme for the heatmap. When I select an age group, I want to see points overlaid on the heatmap showing the pet counts, and I'd like a bar chart below that shows the total count for each pet type. The bars should highlight in blue when I select their corresponding age group in the heatmap. Can you pull this data from my pets database instead of using random data?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/pets_1.sqlite')\n\nquery = '''\nSELECT \n    S.Age AS Student_Age, \n    P.PetType AS Pet_Type, \n    COUNT(*) AS Pet_Count\nFROM \n    Student AS S\nJOIN \n    Has_Pet AS HP ON S.StuID = HP.StuID\nJOIN \n    Pets AS P ON HP.PetID = P.PetID\nGROUP BY \n    S.Age, P.PetType\nORDER BY \n    S.Age, P.PetType\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\npts = alt.selection_point(encodings=['x'])\n\nrect = alt.Chart(df).mark_rect().encode(\n    alt.X('Student_Age:Q').bin(),\n    alt.Y('Pet_Type:N'),\n    alt.Color('sum(Pet_Count):Q').scale(scheme='greenblue').title('Total Pets')\n)\n\ncirc = rect.mark_point().encode(\n    alt.ColorValue('grey'),\n    alt.Size('sum(Pet_Count):Q').title('Pets in Selection')\n).transform_filter(pts)\n\nbar = alt.Chart(df, width=550, height=200).mark_bar().encode(\n    x='Pet_Type:N',\n    y='sum(Pet_Count):Q',\n    color=alt.when(pts).then(alt.ColorValue(\"steelblue\")).otherwise(alt.ColorValue(\"grey\"))\n).add_params(pts)\n\nchart = alt.vconcat(\n    rect + circ,\n    bar\n).resolve_legend(\n    color=\"independent\",\n    size=\"independent\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_chart_with_cross-highlight.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "pets_1",
        "chart_category": "Scatter Plots",
        "chart_type": "simple_scatter_plot_with_labels",
        "NLQ": "Can you create a scatter plot showing the relationship between pet age and weight using data from my pets database? I'd like each point to represent a pet, with the pet's ID displayed as a label next to each point. Make sure the labels are positioned slightly to the right of each point so they're easy to read.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/pets_1.sqlite')\n\nquery = '''\nSELECT pet_age, weight, PetID\nFROM Pets\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ndf['PetID'] = df['PetID'].astype(str)\n\npoints = alt.Chart(df).mark_point().encode(\n    x='pet_age:Q',\n    y='weight:Q'\n)\n\ntext = points.mark_text(\n    align='left',\n    baseline='middle',\n    dx=7\n).encode(\n    text='PetID:N'\n)\n\npoints + text",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___simple_scatter_plot_with_labels.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "pets_1",
        "chart_category": "Scatter Plots",
        "chart_type": "simple_scatter_plot_with_labels",
        "NLQ": "Instead of using my sample data, could you create a scatter plot that shows the age and weight of pets from my database? I need to connect to my pets database, get the pet age, weight, and their IDs, and then display them as points on the chart with each pet's ID labeled next to its point. Can you use Altair instead of Matplotlib for this?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/pets_1.sqlite')\nquery = '''\nSELECT pet_age, weight, PetID\nFROM Pets\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf['PetID'] = df['PetID'].astype(str)\n\npoints = alt.Chart(df).mark_point().encode(\n    x='pet_age:Q',\n    y='weight:Q'\n)\n\ntext = points.mark_text(\n    align='left',\n    baseline='middle',\n    dx=7\n).encode(\n    text='PetID:N'\n)\n\npoints + text",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___simple_scatter_plot_with_labels.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "phone_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_range",
        "NLQ": "Can you create a chart showing the range of RAM sizes for each launch year from our database? I'd like a horizontal bar chart where each bar spans from the minimum to maximum RAM for that year. Make the bars thinner with rounded corners, and add labels at both ends showing the exact values. Please include a proper title like \"RAM Range by Launch Year\" with a subtitle explaining it shows minimum and maximum RAM. Also, make sure the x-axis is labeled \"RAM Range (MiB)\" and the y-axis shows \"Launch Year\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/phone_1.sqlite')\nquery = '''\nSELECT \n    Launch_year, \n    MIN(RAM_MiB) AS min_ram, \n    MAX(RAM_MiB) AS max_ram\nFROM chip_model\nGROUP BY Launch_year\nORDER BY Launch_year\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar(cornerRadius=10, height=10).encode(\n    x=alt.X('min_ram:Q').scale(domain=[0, df['max_ram'].max() + 10]).title('RAM Range (MiB)'),\n    x2='max_ram:Q',\n    y=alt.Y('Launch_year:O').title('Launch Year')\n)\n\ntext_min = alt.Chart(df).mark_text(align='right', dx=-5).encode(\n    x='min_ram:Q',\n    y=alt.Y('Launch_year:O'),\n    text='min_ram:Q'\n)\n\ntext_max = alt.Chart(df).mark_text(align='left', dx=5).encode(\n    x='max_ram:Q',\n    y=alt.Y('Launch_year:O'),\n    text='max_ram:Q'\n)\n\n(bar + text_min + text_max).properties(\n    title=alt.Title(text='RAM Range by Launch Year', subtitle='Minimum and Maximum RAM for Each Year')\n)",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_range.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "phone_1",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_range",
        "NLQ": "Can you create a horizontal bar chart showing the range of RAM sizes for mobile phones by launch year? I'd like to see the minimum and maximum RAM for each year, with the bars spanning from the minimum to maximum values. Please add labels at both ends of each bar showing the exact RAM values, and give the chart a title \"RAM Range by Launch Year\" with a subtitle \"Minimum and Maximum RAM for Each Year\". Make the bars look nice with rounded corners, and pull the data from our phone database instead of using the temperature data in the example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/phone_1.sqlite')\n\nquery = '''\nSELECT \n    Launch_year, \n    MIN(RAM_MiB) AS min_ram, \n    MAX(RAM_MiB) AS max_ram\nFROM chip_model\nGROUP BY Launch_year\nORDER BY Launch_year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar(cornerRadius=10, height=10).encode(\n    x=alt.X('min_ram:Q').scale(domain=[0, df['max_ram'].max() + 10]).title('RAM Range (MiB)'),\n    x2='max_ram:Q',\n    y=alt.Y('Launch_year:O').title('Launch Year')\n)\n\ntext_min = alt.Chart(df).mark_text(align='right', dx=-5).encode(\n    x='min_ram:Q',\n    y=alt.Y('Launch_year:O'),\n    text='min_ram:Q'\n)\n\ntext_max = alt.Chart(df).mark_text(align='left', dx=5).encode(\n    x='max_ram:Q',\n    y=alt.Y('Launch_year:O'),\n    text='max_ram:Q'\n)\n\n(bar + text_min + text_max).properties(\n    title=alt.Title(text='RAM Range by Launch Year', subtitle='Minimum and Maximum RAM for Each Year')\n)",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_range.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "phone_1",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_chart_with_cross-highlight",
        "NLQ": "Can you create a visualization that shows the relationship between phone launch years and RAM sizes? I'd like to see a heatmap showing how many phone models were released in each year with different RAM sizes, using a green-blue color scheme. Below that, add a bar chart showing the count of models by company name. Make it interactive so when I click on a specific year range in the heatmap, it highlights which companies were releasing phones during that period. Also, please use my phone database to get this information instead of random data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/phone_1.sqlite')\n\nquery = '''\nSELECT \n    cm.Model_name AS Hardware_Model,\n    cm.Launch_year,\n    cm.RAM_MiB,\n    p.Company_name\nFROM \n    chip_model AS cm\nJOIN \n    phone AS p\nON \n    cm.Model_name = p.chip_model\nWHERE \n    cm.Launch_year IS NOT NULL AND cm.RAM_MiB IS NOT NULL\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\npts = alt.selection_point(encodings=['x'])\n\nrect = alt.Chart(df).mark_rect().encode(\n    alt.X('Launch_year:Q').bin(),\n    alt.Y('RAM_MiB:Q').bin(),\n    alt.Color('count()').scale(scheme='greenblue').title('Total Models')\n)\n\ncirc = rect.mark_point().encode(\n    alt.ColorValue('grey'),\n    alt.Size('count()').title('Models in Selection')\n).transform_filter(\n    pts\n)\n\nbar = alt.Chart(df, width=550, height=200).mark_bar().encode(\n    x='Company_name:N',\n    y='count()',\n    color=alt.when(pts).then(alt.ColorValue(\"steelblue\")).otherwise(alt.ColorValue(\"grey\"))\n).add_params(pts)\n\nchart = alt.vconcat(\n    rect + circ,\n    bar\n).resolve_legend(\n    color=\"independent\",\n    size=\"independent\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_chart_with_cross-highlight.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "phone_market",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_range",
        "NLQ": "Can you create a chart showing the price range for different phone memory sizes? I want to see the minimum and maximum prices for each memory size in GB. Make the bars horizontal with rounded corners and thinner than normal. Add the actual price values at both ends of each bar. Please include a title \"Price Range by Memory Size\" with a subtitle \"Phone Market Analysis\", and label the axes as \"Memory Size (GB)\" and \"Price Range ($)\". Get the data from our phone market database instead of using random numbers.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/phone_market.sqlite')\n\nquery = '''\nSELECT \n    Memory_in_G, \n    MIN(Price) AS min_price, \n    MAX(Price) AS max_price\nFROM phone\nGROUP BY Memory_in_G\nORDER BY Memory_in_G\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbar = alt.Chart(df).mark_bar(cornerRadius=10, height=10).encode(\n    x=alt.X('min_price:Q').scale(domain=[0, df['max_price'].max() + 100]).title('Price Range ($)'),\n    x2='max_price:Q',\n    y=alt.Y('Memory_in_G:O').title('Memory Size (GB)')\n)\n\ntext_min = alt.Chart(df).mark_text(align='right', dx=-5).encode(\n    x='min_price:Q',\n    y=alt.Y('Memory_in_G:O'),\n    text='min_price:Q'\n)\n\ntext_max = alt.Chart(df).mark_text(align='left', dx=5).encode(\n    x='max_price:Q',\n    y=alt.Y('Memory_in_G:O'),\n    text='max_price:Q'\n)\n\n(bar + text_min + text_max).properties(\n    title=alt.Title(text='Price Range by Memory Size', subtitle='Phone Market Analysis')\n)",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_range.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "phone_market",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_range",
        "NLQ": "Can you create a chart showing the price range for different phone memory sizes? I'd like horizontal bars with rounded corners showing the minimum and maximum prices for each memory size. Please display the actual min and max price values next to each bar, add a title \"Price Range by Memory Size\" with a subtitle \"Phone Market Analysis\", and label the axes as \"Memory Size (GB)\" and \"Price Range ($)\". Get the data from our phone market database instead of using the temperature data from the example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/phone_market.sqlite')\n\nquery = '''\nSELECT \n    Memory_in_G, \n    MIN(Price) AS min_price, \n    MAX(Price) AS max_price\nFROM phone\nGROUP BY Memory_in_G\nORDER BY Memory_in_G\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar(cornerRadius=10, height=10).encode(\n    x=alt.X('min_price:Q').scale(domain=[0, df['max_price'].max() + 100]).title('Price Range ($)'),\n    x2='max_price:Q',\n    y=alt.Y('Memory_in_G:O').title('Memory Size (GB)')\n)\n\ntext_min = alt.Chart(df).mark_text(align='right', dx=-5).encode(\n    x='min_price:Q',\n    y=alt.Y('Memory_in_G:O'),\n    text='min_price:Q'\n)\n\ntext_max = alt.Chart(df).mark_text(align='left', dx=5).encode(\n    x='max_price:Q',\n    y=alt.Y('Memory_in_G:O'),\n    text='max_price:Q'\n)\n\n(bar + text_min + text_max).properties(\n    title=alt.Title(text='Price Range by Memory Size', subtitle='Phone Market Analysis')\n)",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_range.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "poker_player",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_rolling_mean",
        "NLQ": "Can you create a chart showing poker player earnings from our database instead of the wheat production data? I'd like to see each player's earnings as bars with their IDs on the x-axis, and add a red line showing the rolling average of earnings. Please give it a clear title \"Poker Player Earnings with Rolling Mean\" and make the chart wider (about 600 pixels) so it's easier to read.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/poker_player.sqlite')\nquery = '''\nSELECT Poker_Player_ID, Earnings\nFROM poker_player\nORDER BY Poker_Player_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x='Poker_Player_ID:O',\n    y='Earnings:Q'\n)\n\nline = alt.Chart(df).mark_line(color='red').transform_window(\n    rolling_mean='mean(Earnings)',\n    frame=[-9, 0]\n).encode(\n    x='Poker_Player_ID:O',\n    y='rolling_mean:Q'\n)\n\nchart = (bar + line).properties(\n    title='Poker Player Earnings with Rolling Mean',\n    width=600\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_rolling_mean.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "poker_player",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_rolling_mean",
        "NLQ": "Can you create a chart showing poker player earnings from our database instead of wheat production? I'd like to see each player's earnings as bars with their IDs on the x-axis, and add a red line showing the rolling average across players. Please title it \"Poker Player Earnings with Rolling Mean\" and make the chart wider - about 600 pixels should work well.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/poker_player.sqlite')\nquery = '''\nSELECT Poker_Player_ID, Earnings\nFROM poker_player\nORDER BY Poker_Player_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbar = alt.Chart(df).mark_bar().encode(\n    x='Poker_Player_ID:O',\n    y='Earnings:Q'\n)\n\nline = alt.Chart(df).mark_line(color='red').transform_window(\n    rolling_mean='mean(Earnings)',\n    frame=[-9, 0]\n).encode(\n    x='Poker_Player_ID:O',\n    y='rolling_mean:Q'\n)\n\nchart = (bar + line).properties(\n    title='Poker Player Earnings with Rolling Mean',\n    width=600\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_rolling_mean.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "poker_player",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_crossfilter",
        "NLQ": "Can you change my flight data visualization to show poker player statistics instead? I'd like to see the distribution of how often players make it to final tables, their best finishes, and their earnings, all grouped into ranges. Keep the interactive brushing feature where I can select parts of the data, but make the unselected bars gray and the selected ones blue. Also, can you make the charts a bit smaller, around 160 pixels wide and 130 pixels tall? Instead of generating random data like in my example, please pull the information from my poker_player database.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/poker_player.sqlite')\n\nquery = '''\nSELECT Final_Table_Made, Best_Finish, Earnings\nFROM poker_player;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval(encodings=['x'])\n\nbase = alt.Chart(df, width=160, height=130).mark_bar().encode(\n    alt.X(alt.repeat('column'), bin=alt.Bin(maxbins=20)),\n    y='count()',\n)\n\nbackground = base.encode(\n    color=alt.value('#ddd')\n).add_params(brush)\n\nhighlight = base.transform_filter(brush)\n\nchart = alt.layer(\n    background,\n    highlight\n).repeat(column=[\"Final_Table_Made\", \"Best_Finish\", \"Earnings\"])\n\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_crossfilter.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "products_gen_characteristics",
        "chart_category": "Simple Charts",
        "chart_type": "simple_heatmap",
        "NLQ": "Can you create a heatmap showing the distribution of our products across different color codes and product categories? I'd like to see how many products we have for each color-category combination, with the count represented by color intensity. Please label the axes as \"Color Code\" and \"Product Category\", and give the chart a title \"Distribution of Product Categories by Color\". The data should come from our products database, not the sample data in the current chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/products_gen_characteristics.sqlite')\n\nquery = '''\nSELECT \n    Ref_Colors.color_code,\n    Ref_Product_Categories.product_category_description,\n    COUNT(Products.product_id) AS product_count\nFROM Products\nJOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code\nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code\nGROUP BY Ref_Colors.color_code, Ref_Product_Categories.product_category_description\nORDER BY Ref_Colors.color_code, Ref_Product_Categories.product_category_description;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nheatmap = alt.Chart(df).mark_rect().encode(\n    x=alt.X('color_code:N', title='Color Code'),\n    y=alt.Y('product_category_description:N', title='Product Category'),\n    color=alt.Color('product_count:Q', title='Product Count')\n).properties(\n    title='Distribution of Product Categories by Color'\n)\n\nheatmap",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "products_gen_characteristics",
        "chart_category": "Simple Charts",
        "chart_type": "simple_heatmap",
        "NLQ": "Instead of that abstract mathematical heatmap, can you create a business-focused visualization that shows the distribution of our products? I'd like to see how many products we have for each combination of color code and product category. Please pull this data from our products database, organize it as a heatmap where color codes are on the x-axis, product categories on the y-axis, and use color intensity to represent the product count. Also, add a clear title like \"Distribution of Product Categories by Color\" and make sure the axes are properly labeled.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/products_gen_characteristics.sqlite')\n\nquery = '''\nSELECT \n    Ref_Colors.color_code,\n    Ref_Product_Categories.product_category_description,\n    COUNT(Products.product_id) AS product_count\nFROM Products\nJOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code\nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code\nGROUP BY Ref_Colors.color_code, Ref_Product_Categories.product_category_description\nORDER BY Ref_Colors.color_code, Ref_Product_Categories.product_category_description;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nheatmap = alt.Chart(df).mark_rect().encode(\n    x=alt.X('color_code:N', title='Color Code'),\n    y=alt.Y('product_category_description:N', title='Product Category'),\n    color=alt.Color('product_count:Q', title='Product Count')\n).properties(\n    title='Distribution of Product Categories by Color'\n)\n\nheatmap",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "product_catalog",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_rounded_edges",
        "NLQ": "Can you create a bar chart showing the total number of products for each catalog in our database? I'd like to see the catalog names on the x-axis and the product count on the y-axis. Please use different colors to represent the different catalog levels, and add a title that says \"Total Number of Products by Catalog and Level\". Also, could you make the bars have rounded corners at the top to make it look nicer? I need to pull this data from our product_catalog database using SQL.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/product_catalog.sqlite')\n\nquery = '''\nSELECT \n    T1.catalog_id,\n    T2.catalog_name,\n    T1.catalog_level_number,\n    COUNT(T3.catalog_entry_id) AS product_count\nFROM \n    Catalog_Structure AS T1\nJOIN \n    Catalogs AS T2 ON T1.catalog_id = T2.catalog_id\nLEFT JOIN \n    Catalog_Contents AS T3 ON T1.catalog_id = T3.catalog_level_number\nGROUP BY \n    T1.catalog_id, T1.catalog_level_number\nORDER BY \n    T1.catalog_id, T1.catalog_level_number;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar(\n    cornerRadiusTopLeft=3,\n    cornerRadiusTopRight=3\n).encode(\n    x=alt.X('catalog_name:N', title='Catalog Name'),\n    y=alt.Y('product_count:Q', title='Number of Products'),\n    color=alt.Color('catalog_level_number:N', title='Catalog Level')\n).properties(\n    title='Total Number of Products by Catalog and Level'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_rounded_edges.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "product_catalog",
        "chart_category": "Simple Charts",
        "chart_type": "simple_histogram",
        "NLQ": "I like this chart showing the distribution of IMDB ratings, but could you create a similar one that shows the distribution of product prices from our catalog database instead? I'd like to see how many products fall into different price ranges, with the x-axis clearly labeled as \"Price in Dollars\" and the title changed to \"Distribution of Product Prices in Dollars\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/product_catalog.sqlite')\nquery = '''\nSELECT price_in_dollars\nFROM Catalog_Contents\nWHERE price_in_dollars IS NOT NULL\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"price_in_dollars:Q\", bin=True, title=\"Price in Dollars\"),\n    y='count()', \n    tooltip=['count()']\n).properties(\n    title=\"Distribution of Product Prices in Dollars\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_histogram.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "product_catalog",
        "chart_category": "Simple Charts",
        "chart_type": "simple_histogram",
        "NLQ": "I have this simple histogram showing some IMDb ratings data, but I'd like to create something similar for my product catalog instead. Could you make a histogram that shows the distribution of product prices from my SQLite database? I want to see how many products fall into different price ranges. Please add a clear title like \"Distribution of Product Prices in Dollars\" and make sure the x-axis is labeled properly. It would also be nice if I could hover over the bars to see the exact count.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/product_catalog.sqlite')\nquery = '''\nSELECT price_in_dollars\nFROM Catalog_Contents\nWHERE price_in_dollars IS NOT NULL\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"price_in_dollars:Q\", bin=True, title=\"Price in Dollars\"),\n    y='count()', \n    tooltip=['count()']\n).properties(\n    title=\"Distribution of Product Prices in Dollars\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "program_share",
        "chart_category": "Simple Charts",
        "chart_type": "simple_histogram",
        "NLQ": "Instead of using random IMDB ratings data, can you create a histogram showing the distribution of share percentages from my broadcast database? I need it to pull data from the broadcast_share table, connecting it with the channel and program tables. Keep the same bar chart style, but change the x-axis title to \"Share Percentage\" and update the main title to \"Distribution of Share Percentages Across Programs and Channels\". No need for the bin information in the tooltip.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/program_share.sqlite')\nquery = '''\nSELECT bs.Share_in_percent\nFROM broadcast_share AS bs\nJOIN channel AS c ON bs.Channel_ID = c.Channel_ID\nJOIN program AS p ON bs.Program_ID = p.Program_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"Share_in_percent:Q\", bin=True, title=\"Share Percentage\"),\n    y='count()', \n    tooltip=['count()']\n).properties(\n    title=\"Distribution of Share Percentages Across Programs and Channels\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_histogram.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "program_share",
        "chart_category": "Simple Charts",
        "chart_type": "simple_histogram",
        "NLQ": "I'd like to create a histogram showing the distribution of share percentages from our program database instead of using random IMDB ratings. Can you connect to our SQLite database, pull the share percentages across programs and channels, and create a bar chart with proper binning? Please add a clear title like \"Distribution of Share Percentages Across Programs and Channels\" and include tooltips that show the count when hovering over each bar. I'd prefer to use Altair instead of Matplotlib for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/program_share.sqlite')\nquery = '''\nSELECT bs.Share_in_percent\nFROM broadcast_share AS bs\nJOIN channel AS c ON bs.Channel_ID = c.Channel_ID\nJOIN program AS p ON bs.Program_ID = p.Program_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"Share_in_percent:Q\", bin=True, title=\"Share Percentage\"),\n    y='count()', \n    tooltip=['count()']\n).properties(\n    title=\"Distribution of Share Percentages Across Programs and Channels\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "protein_institute",
        "chart_category": "Simple Charts",
        "chart_type": "simple_histogram",
        "NLQ": "Instead of showing the distribution of IMDB ratings, can you create a similar histogram but for building data? I want to see how many buildings have different numbers of floors, but only include buildings that were once the tallest. Label the x-axis as \"Number of Floors\" and give it a title that explains we're looking at the distribution of floors for buildings that were once the tallest.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/protein_institute.sqlite')\n\nquery = '''\nSELECT Floors\nFROM building\nWHERE Years_as_tallest IS NOT NULL AND Years_as_tallest != ''\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"Floors:Q\", bin=True, title=\"Number of Floors\"),\n    y='count()',\n    tooltip=['Floors:Q', 'count()']\n).properties(\n    title=\"Distribution of Building Floors That Were Once the Tallest\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_histogram.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "protein_institute",
        "chart_category": "Simple Charts",
        "chart_type": "simple_histogram",
        "NLQ": "Instead of showing the IMDb ratings distribution, can you create a histogram showing how many buildings have a certain number of floors, but only include buildings that were once the tallest? I'd like to use real data from our protein institute database rather than random numbers. Please add tooltips so I can see the exact floor count and number of buildings when I hover over each bar, and make sure to include a clear title that explains what we're looking at.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/protein_institute.sqlite')\nquery = '''\nSELECT Floors\nFROM building\nWHERE Years_as_tallest IS NOT NULL AND Years_as_tallest != ''\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"Floors:Q\", bin=True, title=\"Number of Floors\"),\n    y='count()',\n    tooltip=['Floors:Q', 'count()']\n).properties(\n    title=\"Distribution of Building Floors That Were Once the Tallest\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "race_track",
        "chart_category": "Simple Charts",
        "chart_type": "simple_line_chart",
        "NLQ": "I want to create a line chart that shows how many races each track has hosted. Can you pull this data from our race_track database? I need the track names on the x-axis and the number of races on the y-axis. The tracks should be ordered by their Track_ID. Keep it simple like the example chart I showed you earlier.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/race_track.sqlite')\n\nquery = '''\nSELECT \n    t.Name AS Track_Name,\n    COUNT(r.Race_ID) AS Race_Count\nFROM \n    track AS t\nLEFT JOIN \n    race AS r ON t.Track_ID = r.Track_ID\nGROUP BY \n    t.Track_ID\nORDER BY \n    t.Track_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line().encode(\n    x='Track_Name:N',\n    y='Race_Count:Q'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_line_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "race_track",
        "chart_category": "Simple Charts",
        "chart_type": "simple_line_chart",
        "NLQ": "I want to create a chart that shows how many races each track has hosted. Can you pull this data from our race_track database? I'd like to see the track names along the x-axis and the number of races on the y-axis, with a line connecting the points. Instead of using matplotlib like in my example, could you use Altair for this visualization?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/race_track.sqlite')\n\nquery = '''\nSELECT \n    t.Name AS Track_Name,\n    COUNT(r.Race_ID) AS Race_Count\nFROM \n    track AS t\nLEFT JOIN \n    race AS r ON t.Track_ID = r.Track_ID\nGROUP BY \n    t.Track_ID\nORDER BY \n    t.Track_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line().encode(\n    x='Track_Name:N',\n    y='Race_Count:Q'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_line_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "railway",
        "chart_category": "Bar Charts",
        "chart_type": "calculating_percentage_of_total",
        "NLQ": "Can you help me create a bar chart that shows the percentage of trains in each location? I need to pull data from my railway database instead of using the activity data. The chart should show each location and what percentage of the total trains it has. Also, can you format the x-axis to show percentages with the % symbol?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/railway.sqlite')\n\nquery = '''\nSELECT \n    T1.Location AS Location,\n    COUNT(T2.Train_ID) AS Train_Count\nFROM \n    railway AS T1\nJOIN \n    train AS T2 ON T1.Railway_ID = T2.Railway_ID\nGROUP BY \n    T1.Location\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_joinaggregate(\n    TotalTrains='sum(Train_Count)',\n).transform_calculate(\n    PercentOfTotal=\"datum.Train_Count / datum.TotalTrains\"\n).mark_bar().encode(\n    alt.X('PercentOfTotal:Q').axis(format='.0%'),\n    y='Location:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___calculating_percentage_of_total.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "railway",
        "chart_category": "Bar Charts",
        "chart_type": "calculating_percentage_of_total",
        "NLQ": "Can you change my visualization to show train counts by location instead of activities and time? I need to pull this data from my railway database instead of using the sample data. Keep the horizontal bar chart showing percentages of the total, but use the train locations on the y-axis. Also, can we switch from matplotlib to Altair for creating the chart?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/railway.sqlite')\n\nquery = '''\nSELECT \n    T1.Location AS Location,\n    COUNT(T2.Train_ID) AS Train_Count\nFROM \n    railway AS T1\nJOIN \n    train AS T2 ON T1.Railway_ID = T2.Railway_ID\nGROUP BY \n    T1.Location\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_joinaggregate(\n    TotalTrains='sum(Train_Count)',\n).transform_calculate(\n    PercentOfTotal=\"datum.Train_Count / datum.TotalTrains\"\n).mark_bar().encode(\n    alt.X('PercentOfTotal:Q').axis(format='.0%'),\n    y='Location:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___calculating_percentage_of_total.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "railway",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_scatter_plot_and_linked_layered_histogram",
        "NLQ": "Can you change my visualization to show manager data from our railway database instead of the gender height/weight data? I'd like to see how managers' working years relate to their age, with colors representing different countries. Make the points bigger and filled, and use a custom color palette with teal, purple, and orange instead of the default colors. Also, set the x-axis to go from 0 to 40 years and the y-axis from 0 to 100 for age. For the histogram, can you make it show working years instead of age, with semi-transparent bars? Keep the interactive feature where clicking on a country highlights its data in both charts.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/railway.sqlite')\n\nquery = '''\nSELECT \n    m.Name AS Manager_Name,\n    m.Country,\n    (strftime('%Y', 'now') - CAST(m.Working_year_starts AS INT)) AS Working_Years,\n    m.Age\nFROM \n    manager AS m\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nselector = alt.selection_point(fields=['Country'])\n\ncolor_scale = alt.Scale(domain=df['Country'].unique(), range=['#1FC3AA', '#8624F5', '#FF5733'])\ncolor = (\n    alt.when(selector)\n    .then(alt.Color(\"Country:N\").scale(color_scale))\n    .otherwise(alt.value(\"lightgray\"))\n)\n\nbase = alt.Chart(df).properties(\n    width=250,\n    height=250\n).add_params(selector)\n\npoints = base.mark_point(filled=True, size=200).encode(\n    alt.X('mean(Working_Years):Q').scale(domain=[0, 40]),\n    alt.Y('mean(Age):Q').scale(domain=[0, 100]),\n    color=color,\n)\n\nhists = base.mark_bar(opacity=0.5, thickness=100).encode(\n    alt.X('Working_Years')\n        .bin(step=5)\n        .scale(domain=[0, 40]),\n    alt.Y('count()')\n        .stack(None)\n        .scale(domain=[0, df['Country'].value_counts().max() + 10]),\n    alt.Color('Country:N').scale(color_scale)\n).transform_filter(\n    selector\n)\n\npoints | hists",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_scatter_plot_and_linked_layered_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "railway",
        "chart_category": "Simple Charts",
        "chart_type": "simple_line_chart",
        "NLQ": "Can you create a line chart showing the number of trains managed by railways over time? I need to pull data from my railway database instead of using the sample data. The x-axis should show the year each railway was built, and the y-axis should show the count of trains. Please add a clear title like \"Number of Trains Managed by Railways Over Time\" and make sure the axis labels are descriptive too.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/railway.sqlite')\n\nquery = '''\nSELECT \n    r.Built AS Year,\n    COUNT(t.Train_ID) AS Train_Count\nFROM \n    railway AS r\nLEFT JOIN \n    train AS t ON r.Railway_ID = t.Railway_ID\nWHERE \n    r.Built != '' AND r.Built != 'Unknown'\nGROUP BY \n    r.Built\nORDER BY \n    CAST(r.Built AS INTEGER)\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line().encode(\n    x=alt.X('Year:N', title='Year Built'),\n    y=alt.Y('Train_Count:Q', title='Number of Trains')\n).properties(\n    title=\"Number of Trains Managed by Railways Over Time\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_line_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "railway",
        "chart_category": "Simple Charts",
        "chart_type": "simple_line_chart",
        "NLQ": "I need to create a line chart showing the number of trains managed by railways over time. Instead of using the sample data in my current code, could you pull the actual data from our railway database? I'd like the x-axis to show the year each railway was built, and the y-axis to show the count of trains. Please add a clear title like \"Number of Trains Managed by Railways Over Time\" and make sure the axis labels are descriptive too. I want to see how train counts have changed across different construction years.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/railway.sqlite')\n\nquery = '''\nSELECT \n    r.Built AS Year,\n    COUNT(t.Train_ID) AS Train_Count\nFROM \n    railway AS r\nLEFT JOIN \n    train AS t ON r.Railway_ID = t.Railway_ID\nWHERE \n    r.Built != '' AND r.Built != 'Unknown'\nGROUP BY \n    r.Built\nORDER BY \n    CAST(r.Built AS INTEGER)\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line().encode(\n    x=alt.X('Year:N', title='Year Built'),\n    y=alt.Y('Train_Count:Q', title='Number of Trains')\n).properties(\n    title=\"Number of Trains Managed by Railways Over Time\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_line_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "riding_club",
        "chart_category": "Simple Charts",
        "chart_type": "simple_scatter_plot_with_tooltips",
        "NLQ": "Instead of using the car dataset with horsepower and miles per gallon, can you create a scatter plot using our riding club database? I want to see how gold medals relate to points earned by each club, with different colors for each region. Make the circles a bit bigger and let me hover over them to see the club name, region, gold medals, and points. Also, can you make the chart interactive?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/riding_club.sqlite')\n\nquery = '''\nSELECT \n    c.Club_name, \n    c.Region, \n    m.Gold, \n    m.Points\nFROM \n    club AS c\nJOIN \n    match_result AS m\nON \n    c.Club_ID = m.Club_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nscatter_plot = alt.Chart(df).mark_circle(size=60).encode(\n    x='Gold:Q',\n    y='Points:Q',\n    color='Region:N',\n    tooltip=['Club_name:N', 'Region:N', 'Gold:Q', 'Points:Q']\n).interactive()\n\nscatter_plot",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_scatter_plot_with_tooltips.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "riding_club",
        "chart_category": "Simple Charts",
        "chart_type": "simple_scatter_plot_with_tooltips",
        "NLQ": "Can you change this car performance scatter plot to show data from our riding club database instead? I'd like to see how gold medals relate to points for different clubs, with the dots colored by region. Also, could you make it interactive so I can hover over each point to see the club name, region, gold medals, and points? Please use Altair instead of Matplotlib for this.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/riding_club.sqlite')\nquery = '''\nSELECT \n    c.Club_name, \n    c.Region, \n    m.Gold, \n    m.Points\nFROM \n    club AS c\nJOIN \n    match_result AS m\nON \n    c.Club_ID = m.Club_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nscatter_plot = alt.Chart(df).mark_circle(size=60).encode(\n    x='Gold:Q',\n    y='Points:Q',\n    color='Region:N',\n    tooltip=['Club_name:N', 'Region:N', 'Gold:Q', 'Points:Q']\n).interactive()\n\nscatter_plot",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_scatter_plot_with_tooltips.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "sakila_1",
        "chart_category": "Bar Charts",
        "chart_type": "diverging_stacked_bar_chart",
        "NLQ": "Can you create a chart showing how movie ratings (G, PG, PG-13, R, NC-17) are distributed across different film categories? I'd like to see the percentage breakdown for each category using horizontal stacked bars. Use a color scheme with red, gray, and blue colors for the different ratings. Put the film categories along the y-axis and make sure to label the x-axis as \"Percentage\". The data should come from our movie database instead of the survey data in the current chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/sakila_1.sqlite')\n\nquery = '''\nSELECT \n    c.name AS category_name,\n    f.rating,\n    COUNT(*) AS count\nFROM \n    film AS f\nJOIN \n    film_category AS fc ON f.film_id = fc.film_id\nJOIN \n    category AS c ON fc.category_id = c.category_id\nGROUP BY \n    c.name, f.rating\nORDER BY \n    c.name, f.rating\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nrating_order = {'G': -2, 'PG': -1, 'PG-13': 0, 'R': 1, 'NC-17': 2}\ndf['type_code'] = df['rating'].map(rating_order)\n\ndef compute_percentages(group):\n    group = group.set_index('type_code').sort_index()\n    perc = (group['count'] / group['count'].sum()) * 100\n    group['percentage'] = perc\n    group['percentage_end'] = perc.cumsum() - (perc[-2] + perc[-1] + perc[0] / 2)\n    group['percentage_start'] = group['percentage_end'] - perc\n    return group\n\ndf = df.groupby('category_name').apply(compute_percentages).reset_index(drop=True)\n\ncolor_scale = alt.Scale(\n    domain=['G', 'PG', 'PG-13', 'R', 'NC-17'],\n    range=[\"#c30d24\", \"#f3a583\", \"#cccccc\", \"#94c6da\", \"#1770ab\"]\n)\n\ny_axis = alt.Axis(title=\"Film Category\", offset=5, ticks=False, minExtent=60, domain=False)\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"percentage_start:Q\", title=\"Percentage\"),\n    x2=\"percentage_end:Q\",\n    y=alt.Y(\"category_name:N\").axis(y_axis),\n    color=alt.Color(\"rating:N\").title(\"Rating\").scale(color_scale)\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___diverging_stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "sakila_1",
        "chart_category": "Bar Charts",
        "chart_type": "diverging_stacked_bar_chart",
        "NLQ": "Can you create a chart showing how movie ratings (G, PG, PG-13, R, NC-17) are distributed across different film categories? I'd like to use a diverging color scheme with red on one end, gray in the middle, and blue on the other end. Make it a horizontal bar chart with film categories listed vertically on the left side. Instead of using the survey data from my original chart, please pull the movie data from the Sakila database and calculate the percentage distribution of ratings within each category.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/sakila_1.sqlite')\n\nquery = '''\nSELECT \n    c.name AS category_name,\n    f.rating,\n    COUNT(*) AS count\nFROM \n    film AS f\nJOIN \n    film_category AS fc ON f.film_id = fc.film_id\nJOIN \n    category AS c ON fc.category_id = c.category_id\nGROUP BY \n    c.name, f.rating\nORDER BY \n    c.name, f.rating\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nrating_order = {'G': -2, 'PG': -1, 'PG-13': 0, 'R': 1, 'NC-17': 2}\ndf['type_code'] = df['rating'].map(rating_order)\n\ndef compute_percentages(group):\n    group = group.set_index('type_code').sort_index()\n    perc = (group['count'] / group['count'].sum()) * 100\n    group['percentage'] = perc\n    group['percentage_end'] = perc.cumsum() - (perc[-2] + perc[-1] + perc[0] / 2)\n    group['percentage_start'] = group['percentage_end'] - perc\n    return group\n\ndf = df.groupby('category_name').apply(compute_percentages).reset_index(drop=True)\n\ncolor_scale = alt.Scale(\n    domain=['G', 'PG', 'PG-13', 'R', 'NC-17'],\n    range=[\"#c30d24\", \"#f3a583\", \"#cccccc\", \"#94c6da\", \"#1770ab\"]\n)\n\ny_axis = alt.Axis(title=\"Film Category\", offset=5, ticks=False, minExtent=60, domain=False)\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"percentage_start:Q\", title=\"Percentage\"),\n    x2=\"percentage_end:Q\",\n    y=alt.Y(\"category_name:N\").axis(y_axis),\n    color=alt.Color(\"rating:N\").title(\"Rating\").scale(color_scale)\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___diverging_stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "shop_membership",
        "chart_category": "Interactive Charts",
        "chart_type": "multi-line_tooltip",
        "NLQ": "Could you help me create a chart that shows how much money customers at different membership levels have spent over the years? I want to use our shop membership database to get the actual purchase data by membership level for each year. Make the lines smoother with curved connections between points, and add a clear title like \"Total Purchase Amounts by Membership Level Over Years\". I'd like the chart to be a good size - maybe about 600 by 300 pixels - and I still want to be able to hover over points to see the exact purchase amounts. Also, can you make the vertical line that appears when hovering gray instead of black?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/shop_membership.sqlite')\n\nquery = '''\nSELECT \n    m.Level AS Membership_Level,\n    p.Year AS Purchase_Year,\n    SUM(p.Total_pounds) AS Total_Purchase_Amount\nFROM \n    purchase AS p\nJOIN \n    member AS m ON p.Member_ID = m.Member_ID\nGROUP BY \n    m.Level, p.Year\nORDER BY \n    m.Level, p.Year\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nnearest = alt.selection_point(nearest=True, on=\"pointerover\",\n                              fields=[\"Purchase_Year\"], empty=False)\n\nline = alt.Chart(df).mark_line(interpolate=\"basis\").encode(\n    x=\"Purchase_Year:O\",\n    y=\"Total_Purchase_Amount:Q\",\n    color=\"Membership_Level:N\"\n)\n\nselectors = alt.Chart(df).mark_point().encode(\n    x=\"Purchase_Year:O\",\n    opacity=alt.value(0),\n).add_params(\n    nearest\n)\nwhen_near = alt.when(nearest)\n\npoints = line.mark_point().encode(\n    opacity=when_near.then(alt.value(1)).otherwise(alt.value(0))\n)\n\ntext = line.mark_text(align=\"left\", dx=5, dy=-5).encode(\n    text=when_near.then(\"Total_Purchase_Amount:Q\").otherwise(alt.value(\" \"))\n)\n\nrules = alt.Chart(df).mark_rule(color=\"gray\").encode(\n    x=\"Purchase_Year:O\",\n).transform_filter(\n    nearest\n)\n\nchart = alt.layer(\n    line, selectors, points, rules, text\n).properties(\n    width=600, height=300, title=\"Total Purchase Amounts by Membership Level Over Years\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multi-line_tooltip.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "soccer_1",
        "chart_category": "Interactive Charts",
        "chart_type": "multi-line_tooltip_(standard)",
        "NLQ": "Can you create a line chart that shows a soccer player's progression over time? I want to track their overall rating and potential from our soccer database. I need the chart to display dates on the x-axis and ratings on the y-axis, with different colored lines for each metric. When I hover over a point, I'd like to see a vertical line and all the player's stats for that date in a tooltip - not just the ratings but also their skills like crossing, finishing, dribbling, acceleration, and strength. Please add a title \"Player Progression Over Time\" and make the chart 600x300 in size.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/soccer_1.sqlite')\n\nquery = '''\nSELECT \n    date,\n    overall_rating,\n    potential,\n    crossing,\n    finishing,\n    short_passing,\n    dribbling,\n    ball_control,\n    acceleration,\n    sprint_speed,\n    strength,\n    aggression\nFROM \n    Player_Attributes\nWHERE \n    player_api_id = 505942\nORDER BY \n    date ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['date'], \n                    value_vars=['overall_rating', 'potential'], \n                    var_name='metric', value_name='value')\n\nnearest = alt.selection_point(nearest=True, on=\"pointerover\",\n                              fields=[\"date\"], empty=False)\n\nline = alt.Chart(df_melted).mark_line(interpolate=\"basis\").encode(\n    x=alt.X(\"date:T\", title=\"Date\"),\n    y=alt.Y(\"value:Q\", title=\"Rating\"),\n    color=alt.Color(\"metric:N\", title=\"Metric\")\n)\n\nwhen_near = alt.when(nearest)\n\npoints = line.mark_point().encode(\n    opacity=when_near.then(alt.value(1)).otherwise(alt.value(0))\n)\n\nrules = alt.Chart(df_melted).transform_pivot(\n    \"metric\",\n    value=\"value\",\n    groupby=[\"date\"]\n).mark_rule(color=\"gray\").encode(\n    x=\"date:T\",\n    opacity=when_near.then(alt.value(0.3)).otherwise(alt.value(0)),\n    tooltip=[\n        alt.Tooltip(\"date:T\", title=\"Date\"),\n        alt.Tooltip(\"overall_rating:Q\", title=\"Overall Rating\"),\n        alt.Tooltip(\"potential:Q\", title=\"Potential\"),\n        alt.Tooltip(\"crossing:Q\", title=\"Crossing\"),\n        alt.Tooltip(\"finishing:Q\", title=\"Finishing\"),\n        alt.Tooltip(\"short_passing:Q\", title=\"Short Passing\"),\n        alt.Tooltip(\"dribbling:Q\", title=\"Dribbling\"),\n        alt.Tooltip(\"ball_control:Q\", title=\"Ball Control\"),\n        alt.Tooltip(\"acceleration:Q\", title=\"Acceleration\"),\n        alt.Tooltip(\"sprint_speed:Q\", title=\"Sprint Speed\"),\n        alt.Tooltip(\"strength:Q\", title=\"Strength\"),\n        alt.Tooltip(\"aggression:Q\", title=\"Aggression\")\n    ]\n).add_params(nearest)\n\nchart = alt.layer(\n    line, points, rules\n).properties(\n    width=600, height=300, title=\"Player Progression Over Time\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multi-line_tooltip_(standard).py"
    },
    {
        "type": "type_C_altair",
        "db_id": "soccer_2",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_xoffset",
        "NLQ": "Can you create a chart showing how many players are associated with each college and position? I want to see the colleges on the x-axis, with bars grouped by position. Please color the bars based on the decision status of the players. I need this data to come from our soccer database, specifically from the Tryout table.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/soccer_2.sqlite')\n\nquery = '''\nSELECT \n    T.cName AS College,\n    T.pPos AS Position,\n    T.decision AS Decision,\n    COUNT(T.pID) AS PlayerCount\nFROM Tryout AS T\nGROUP BY T.cName, T.pPos, T.decision\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=\"College:N\",\n    y=\"PlayerCount:Q\",\n    xOffset=\"Position:N\",\n    color=\"Decision:N\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___grouped_bar_chart_with_xoffset.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "soccer_2",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_xoffset",
        "NLQ": "Could you create a chart showing how many players are associated with each college and position? I want to see the colleges on the x-axis, with bars grouped by position and colored based on the player's decision status. I need to pull this data from my soccer database instead of using the sample data in the example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/soccer_2.sqlite')\nquery = '''\nSELECT \n    T.cName AS College,\n    T.pPos AS Position,\n    T.decision AS Decision,\n    COUNT(T.pID) AS PlayerCount\nFROM Tryout AS T\nGROUP BY T.cName, T.pPos, T.decision\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=\"College:N\",\n    y=\"PlayerCount:Q\",\n    xOffset=\"Position:N\",\n    color=\"Decision:N\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___grouped_bar_chart_with_xoffset.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "solvency_ii",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_xoffset",
        "NLQ": "Can you create a bar chart showing the total number of products by event type and product type from our Solvency II database? I'd like to see event types on the x-axis and product counts on the y-axis, with different product types shown as different colored bars within each event type. Please add proper titles to the axes like \"Event Type\" and \"Total Number of Products\", and give the chart a title \"Total Products by Event Type and Product Type\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/solvency_ii.sqlite')\n\nquery = '''\nSELECT \n    E.Event_Type_Code AS EventType,\n    P.Product_Type_Code AS ProductType,\n    COUNT(PE.Product_ID) AS ProductCount\nFROM \n    Events AS E\nJOIN \n    Products_in_Events AS PE ON E.Event_ID = PE.Event_ID\nJOIN \n    Products AS P ON PE.Product_ID = P.Product_ID\nGROUP BY \n    E.Event_Type_Code, P.Product_Type_Code\nORDER BY \n    E.Event_Type_Code, P.Product_Type_Code;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"EventType:N\", title=\"Event Type\"),\n    y=alt.Y(\"ProductCount:Q\", title=\"Total Number of Products\"),\n    xOffset=\"ProductType:N\",\n    color=\"ProductType:N\"\n).properties(\n    title=\"Total Products by Event Type and Product Type\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___grouped_bar_chart_with_xoffset.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "solvency_ii",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_xoffset",
        "NLQ": "Can you create a bar chart showing the total number of products grouped by event types and product types? I need to pull this data from our Solvency II database using SQL. Each product type should have its own color and be positioned within the same event type. Please add a clear title \"Total Products by Event Type and Product Type\" and label the axes as \"Event Type\" and \"Total Number of Products\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/solvency_ii.sqlite')\n\nquery = '''\nSELECT \n    E.Event_Type_Code AS EventType,\n    P.Product_Type_Code AS ProductType,\n    COUNT(PE.Product_ID) AS ProductCount\nFROM \n    Events AS E\nJOIN \n    Products_in_Events AS PE ON E.Event_ID = PE.Event_ID\nJOIN \n    Products AS P ON PE.Product_ID = P.Product_ID\nGROUP BY \n    E.Event_Type_Code, P.Product_Type_Code\nORDER BY \n    E.Event_Type_Code, P.Product_Type_Code;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"EventType:N\", title=\"Event Type\"),\n    y=alt.Y(\"ProductCount:Q\", title=\"Total Number of Products\"),\n    xOffset=\"ProductType:N\",\n    color=\"ProductType:N\"\n).properties(\n    title=\"Total Products by Event Type and Product Type\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___grouped_bar_chart_with_xoffset.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "solvency_ii",
        "chart_category": "Interactive Charts",
        "chart_type": "multi-line_tooltip_(standard)",
        "NLQ": "Can you create a chart showing the total product prices from our Solvency II database? I'd like to see the prices grouped by event type, with each event type having a different colored line. Make the x-axis show the Event IDs instead of numerical values. When I hover over a point, I want it to highlight and show a tooltip with both the event type and the total product price. Also, please add a title \"Total Product Price by Event Type\" and make the chart 600 pixels wide by 300 pixels tall.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/solvency_ii.sqlite')\nquery = '''\nSELECT \n    E.Event_Type_Code AS Event_Type,\n    SUM(P.Product_Price) AS Total_Product_Price,\n    E.Event_ID\nFROM \n    Events AS E\nJOIN \n    Products_in_Events AS PIE ON E.Event_ID = PIE.Event_ID\nJOIN \n    Products AS P ON PIE.Product_ID = P.Product_ID\nGROUP BY \n    E.Event_Type_Code, E.Event_ID\nORDER BY \n    E.Event_Type_Code, E.Event_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nnearest = alt.selection_point(nearest=True, on=\"pointerover\",\n                              fields=[\"Event_ID\"], empty=False)\nline = alt.Chart(df).mark_line(interpolate=\"basis\").encode(\n    x=\"Event_ID:N\",\n    y=\"Total_Product_Price:Q\",\n    color=\"Event_Type:N\"\n)\npoints = line.mark_point().encode(\n    opacity=alt.condition(nearest, alt.value(1), alt.value(0))\n)\nrules = alt.Chart(df).transform_pivot(\n    \"Event_Type\",\n    value=\"Total_Product_Price\",\n    groupby=[\"Event_ID\"]\n).mark_rule(color=\"gray\").encode(\n    x=\"Event_ID:N\",\n    opacity=alt.condition(nearest, alt.value(0.3), alt.value(0)),\n    tooltip=[alt.Tooltip(\"Event_Type:N\", title=\"Event Type\"),\n             alt.Tooltip(\"Total_Product_Price:Q\", title=\"Total Product Price\")]\n).add_params(nearest)\nchart = alt.layer(\n    line, points, rules\n).properties(\n    width=600, height=300,\n    title=\"Total Product Price by Event Type\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multi-line_tooltip_(standard).py"
    },
    {
        "type": "type_C_altair",
        "db_id": "solvency_ii",
        "chart_category": "Tables",
        "chart_type": "lasagna_plot_dense_time-series_heatmap",
        "NLQ": "I'd like to create a heatmap showing total product prices for different event types over time. Instead of using the stock market data, please use our Solvency II database to pull event types, dates, and prices. Make the months run along the x-axis with labels angled for better readability, event types on the y-axis, and use a viridis color scheme to represent the total prices. Add a clear title \"Heatmap of Total Product Prices by Event Type Over Time\" and proper axis labels. Can you make it about 400 pixels wide and 200 pixels tall?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/solvency_ii.sqlite')\nquery = '''\nSELECT \n    E.Event_Type_Code AS Event_Type,\n    strftime('%Y-%m', A.Address_Details) AS Month,\n    SUM(P.Product_Price) AS Total_Price\nFROM \n    Events AS E\nJOIN \n    Products_in_Events AS PE ON E.Event_ID = PE.Event_ID\nJOIN \n    Products AS P ON PE.Product_ID = P.Product_ID\nJOIN \n    Addresses AS A ON E.Address_ID = A.Address_ID\nGROUP BY \n    E.Event_Type_Code, strftime('%Y-%m', A.Address_Details)\nORDER BY \n    Month, Event_Type;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, width=400, height=200).mark_rect().encode(\n    alt.X(\"Month:O\").title(\"Time (Year-Month)\").axis(labelAngle=-45),\n    alt.Y(\"Event_Type:N\").title(\"Event Type\"),\n    alt.Color(\"Total_Price:Q\").title(\"Total Price\").scale(scheme=\"viridis\")\n).properties(\n    title=\"Heatmap of Total Product Prices by Event Type Over Time\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Tables___lasagna_plot_dense_time-series_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "sports_competition",
        "chart_category": "Interactive Charts",
        "chart_type": "multi-panel_scatter_plot_with_linked_brushing",
        "NLQ": "Can you change this car performance chart to show sports competition medal data instead? I need to see how different clubs compare in terms of their gold and silver medals, with the total medal count on the y-axis. Keep the same interactive selection feature where I can highlight points by club name, but also add tooltips so I can see the club name and all their medal counts when I hover over a point. Could you make the charts a bit bigger too, like 250x250 each?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/sports_competition.sqlite')\nquery = '''\nSELECT \n    c.name AS Club_Name,\n    cr.Gold,\n    cr.Silver,\n    cr.Total\nFROM \n    club_rank AS cr\nJOIN \n    club AS c\nON \n    cr.Club_ID = c.Club_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval(resolve='global')\n\nbase = alt.Chart(df).mark_point().encode(\n    y='Total:Q',\n    color=alt.condition(brush, 'Club_Name:N', alt.value('gray')),\n    tooltip=['Club_Name', 'Gold', 'Silver', 'Total']\n).add_params(\n    brush\n).properties(\n    width=250,\n    height=250\n)\n\nchart = base.encode(x='Gold:Q') | base.encode(x='Silver:Q')\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multi-panel_scatter_plot_with_linked_brushing.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "station_weather",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_xoffset_and_overlapping_bars",
        "NLQ": "Can you create a chart showing high and low temperatures for each day of the week from my weather station database? I'd like to have grouped bars for each day, with one bar showing the high temperature and another showing the low temperature. Make the bars a good size with white borders and slightly transparent. Could you also add labels above each bar showing the exact temperature values? I want to pull this data specifically from station ID 1 in my weekly_weather table.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/station_weather.sqlite')\n\nquery = '''\nSELECT \n    day_of_week AS day,\n    high_temperature AS temperature,\n    'High' AS temp_type\nFROM \n    weekly_weather\nWHERE \n    station_id = 1\nUNION ALL\nSELECT \n    day_of_week AS day,\n    low_temperature AS temperature,\n    'Low' AS temp_type\nFROM \n    weekly_weather\nWHERE \n    station_id = 1\nORDER BY \n    day\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df, width=alt.Step(20)).encode(\n    x=\"day:N\",\n    y=\"temperature:Q\",\n    xOffset=alt.XOffset(\"temp_type:N\").scale(paddingOuter=0.5),\n)\n\nchart = alt.layer(\n    base.mark_bar(size=20, stroke=\"white\", fillOpacity=0.9).encode(fill=\"temp_type:N\"),\n    base.mark_text(dy=-5).encode(text=\"temperature:Q\"),\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___grouped_bar_chart_with_xoffset_and_overlapping_bars.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "station_weather",
        "chart_category": "Interactive Charts",
        "chart_type": "multi-panel_scatter_plot_with_linked_brushing",
        "NLQ": "Can you change my car data visualization to show weather data from our station database instead? I'd like to see two charts side by side - one showing high temperature versus wind speed and the other showing high temperature versus precipitation. Keep the interactive selection feature where I can highlight points by station name instead of origin. Also, add tooltips so when I hover over points I can see the station name, day of week, high temperature, and wind speed. Please give each chart a title and make them both 250x250 in size.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/station_weather.sqlite')\n\nquery = '''\nSELECT \n    s.network_name AS station_name,\n    w.day_of_week,\n    w.high_temperature,\n    w.low_temperature,\n    w.precipitation,\n    w.wind_speed_mph\nFROM \n    weekly_weather AS w\nJOIN \n    station AS s\nON \n    w.station_id = s.id\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval(resolve='global')\n\nbase = alt.Chart(df).mark_point().encode(\n    y='high_temperature:Q',\n    color=alt.condition(brush, 'station_name:N', alt.value('gray')),\n    tooltip=['station_name', 'day_of_week', 'high_temperature', 'wind_speed_mph']\n).add_params(\n    brush\n).properties(\n    width=250,\n    height=250\n)\n\nchart1 = base.encode(x='wind_speed_mph:Q').properties(title='High Temp vs Wind Speed')\nchart2 = base.encode(x='precipitation:Q').properties(title='Low Temp vs Precipitation')\n\nchart1 | chart2",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multi-panel_scatter_plot_with_linked_brushing.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "store_1",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_xoffset_and_overlapping_bars",
        "NLQ": "I need to create a chart showing total sales for different music genres across the top 5 countries from our store database. Can you make a grouped bar chart where each country has multiple bars representing different genres? I'd like the bars to be colored by genre with the sales values displayed above each bar. Please add a title \"Total Sales by Genre and Country (Top 5 Countries)\" and make sure the axes are properly labeled as \"Country\" and \"Total Sales\". Could you also make the bars a bit narrower with white borders and slightly transparent?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/store_1.sqlite')\n\nquery = '''\nWITH CountrySales AS (\n    SELECT\n        c.country,\n        g.name AS genre,\n        SUM(il.unit_price * il.quantity) AS total_sales,\n        RANK() OVER (ORDER BY SUM(il.unit_price * il.quantity) DESC) as country_rank\n    FROM customers c\n    JOIN invoices i ON c.id = i.customer_id\n    JOIN invoice_lines il ON i.id = il.invoice_id\n    JOIN tracks t ON il.track_id = t.id\n    JOIN genres g ON t.genre_id = g.id\n    GROUP BY c.country, g.name\n)\nSELECT\n    cs.country,\n    cs.genre,\n    cs.total_sales\nFROM CountrySales cs\nWHERE country_rank <= 5;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df, width=alt.Step(12)).encode(\n    x=alt.X(\"country:N\", title=\"Country\"),\n    y=alt.Y(\"total_sales:Q\", title=\"Total Sales\"),\n    xOffset=alt.XOffset(\"genre:N\", title=\"Genre\").scale(paddingOuter=0.5),\n)\n\nalt.layer(\n    base.mark_bar(size=20, stroke=\"white\", fillOpacity=0.9).encode(fill=alt.Color(\"genre:N\", title=\"Genre\")),\n    base.mark_text(dy=-5).encode(text=alt.Text(\"total_sales:Q\", format=\".2f\")),\n).properties(\n    title=\"Total Sales by Genre and Country (Top 5 Countries)\"\n)",
        "reference_path": "./vis_bench/code/altair/Bar Charts___grouped_bar_chart_with_xoffset_and_overlapping_bars.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "store_1",
        "chart_category": "Interactive Charts",
        "chart_type": "multi-panel_scatter_plot_with_linked_brushing",
        "NLQ": "I want to create a visualization using my music database instead of the car data. Can you show me a scatter plot with two panels side by side - one showing track size in KB versus duration in seconds, and the other showing media type versus duration? I'd like to be able to select points in one chart and see the same tracks highlighted in the other chart. Please color-code the points by music genre and add tooltips so I can see details when I hover over each point. Make both charts the same size with dimensions of 250x250.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/store_1.sqlite')\n\nquery = '''\nSELECT \n    g.name AS genre, \n    mt.name AS media_type, \n    t.milliseconds / 1000.0 AS duration_seconds, \n    t.bytes / 1024.0 AS size_kb\nFROM \n    tracks AS t\nJOIN \n    genres AS g ON t.genre_id = g.id\nJOIN \n    media_types AS mt ON t.media_type_id = mt.id\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbrush = alt.selection_interval(resolve='global')\n\nbase = alt.Chart(df).mark_point().encode(\n    y='duration_seconds:Q',\n    color=alt.condition(brush, 'genre:N', alt.value('gray')),\n    tooltip=['genre', 'media_type', 'duration_seconds', 'size_kb']\n).add_params(\n    brush\n).properties(\n    width=250,\n    height=250\n)\n\nchart = base.encode(x='size_kb:Q') | base.encode(x='media_type:N')\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multi-panel_scatter_plot_with_linked_brushing.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "storm_record",
        "chart_category": "Interactive Charts",
        "chart_type": "multiple_interactions",
        "NLQ": "Can you change this movie visualization to show storm data instead? I'd like to see a chart that plots storm wind speed against number of deaths, with each point representing a different storm. Please include the storm name in tooltips. I want to keep the same interactive layout with four panels, but modify them to: 1) filter storms by number of deaths using a slider, 2) filter by specific storm name using a dropdown, 3) highlight storms by name using radio buttons instead of MPAA ratings, and 4) use a checkbox to resize points based on whether damage exceeded $15 million instead of production budget. The data should come from my storm database rather than the movie dataset.",
        "code": "import altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/storm_record.sqlite')\nquery = '''\nSELECT Storm_ID, Name, Max_speed, Damage_millions_USD, Number_Deaths\nFROM storm\n'''\ndf = pd.read_sql_query(query, conn)\ndf['Damage_Above_15M'] = df['Damage_millions_USD'].apply(lambda x: \"Yes\" if x > 15 else \"No\")\nconn.close()\n\nbase = alt.Chart(df, width=200, height=200).mark_point(filled=True).encode(\n    x='Max_speed:Q',\n    y='Number_Deaths:Q',\n    tooltip=\"Name:N\"\n)\n\ndeaths_slider = alt.binding_range(min=df['Number_Deaths'].min(), max=df['Number_Deaths'].max(), step=1, name=\"Number of Deaths\")\nslider_selection = alt.selection_point(bind=deaths_slider, fields=['Number_Deaths'])\n\nfilter_deaths = base.add_params(\n    slider_selection\n).transform_filter(\n    slider_selection\n).properties(title=\"Slider Filtering (Deaths)\")\n\nstorm_names = df['Name'].unique().tolist()\nname_dropdown = alt.binding_select(options=storm_names, name=\"Storm Name\")\nname_select = alt.selection_point(fields=['Name'], bind=name_dropdown)\n\nfilter_names = base.add_params(\n    name_select\n).transform_filter(\n    name_select\n).properties(title=\"Dropdown Filtering (Storm Name)\")\n\nname_radio = alt.binding_radio(options=storm_names, name=\"Storm Name\")\nname_radio_select = alt.selection_point(fields=['Name'], bind=name_radio)\nname_color = (\n    alt.when(name_radio_select)\n    .then(alt.Color(\"Name:N\").legend(None))\n    .otherwise(alt.value(\"lightgray\"))\n)\n\nhighlight_names = base.add_params(\n    name_radio_select\n).encode(\n    color=name_color\n).properties(title=\"Radio Button Highlighting\")\n\ninput_checkbox = alt.binding_checkbox(name=\"Damage > $15M \")\ncheckbox_selection = alt.param(bind=input_checkbox)\n\nsize_checkbox = (\n    alt.when(checkbox_selection)\n    .then(alt.Size('Damage_Above_15M:N').scale(range=[25, 150]))\n    .otherwise(alt.value(25))\n)\n\ndamage_sizing = base.add_params(\n    checkbox_selection\n).encode(\n    size=size_checkbox\n).properties(title=\"Checkbox Formatting\")\n\n(filter_deaths | damage_sizing) & (highlight_names | filter_names)",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multiple_interactions.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "student_transcripts_tracking",
        "chart_category": "Interactive Charts",
        "chart_type": "reorder_stacked_bar_segments",
        "NLQ": "Could you help me create a chart that shows how many courses students take in each degree program across different semesters? I'd like to pull this data from my student transcripts database instead of using random data. I want the semesters to be stacked on the y-axis and the total number of courses on the x-axis. Please use different colors for each degree program and add a title that says \"Total Courses Taken by Students in Each Degree Program by Semester\". Also, make sure the axis labels clearly show \"Semester\" and \"Total Courses Taken\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/student_transcripts_tracking.sqlite')\n\nquery = '''\nSELECT \n    dp.degree_summary_name AS degree_program,\n    s.semester_name AS semester,\n    COUNT(sec.course_id) AS total_courses\nFROM \n    Student_Enrolment AS se\nJOIN \n    Degree_Programs AS dp ON se.degree_program_id = dp.degree_program_id\nJOIN \n    Semesters AS s ON se.semester_id = s.semester_id\nJOIN \n    Student_Enrolment_Courses AS sec ON se.student_enrolment_id = sec.student_enrolment_id\nGROUP BY \n    dp.degree_summary_name, s.semester_name\nORDER BY \n    dp.degree_summary_name, s.semester_name;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nselection = alt.selection_point(fields=['degree_program'], bind='legend')\n\nchart = alt.Chart(df).mark_bar().transform_calculate(\n    degree_order=f\"if({selection.name}.degree_program && indexof({selection.name}.degree_program, datum.degree_program) !== -1, 0, 1)\"\n).encode(\n    x=alt.X('sum(total_courses):Q', title='Total Courses Taken'),\n    y=alt.Y('semester:N', title='Semester'),\n    color=alt.Color('degree_program:N', title='Degree Program'),\n    order=alt.Order('degree_order:N'),\n    opacity=alt.condition(selection, alt.value(0.9), alt.value(0.2))\n).add_params(\n    selection\n).properties(\n    title=\"Total Courses Taken by Students in Each Degree Program by Semester\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___reorder_stacked_bar_segments.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "swimming",
        "chart_category": "Interactive Charts",
        "chart_type": "reorder_stacked_bar_segments",
        "NLQ": "I have a bar chart showing crop yields for different varieties across multiple sites. Can you change it to show swimming data from my database instead? I need to display each swimmer's times at different distances (100m, 200m, etc.), with the total time in seconds on the x-axis and swimmers' names on the y-axis. Keep the interactive legend that lets me highlight specific distances by clicking on them. The data needs to be pulled from my swimming database and the time values need to be converted from minutes:seconds format to seconds.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/swimming.sqlite')\n\nquery = '''\nSELECT \n    name AS Swimmer,\n    meter_100 AS \"100m\",\n    CAST(SUBSTR(meter_200, 1, INSTR(meter_200, ':') - 1) AS REAL) * 60 + \n        CAST(SUBSTR(meter_200, INSTR(meter_200, ':') + 1) AS REAL) AS \"200m\",\n    CAST(SUBSTR(meter_300, 1, INSTR(meter_300, ':') - 1) AS REAL) * 60 + \n        CAST(SUBSTR(meter_300, INSTR(meter_300, ':') + 1) AS REAL) AS \"300m\",\n    CAST(SUBSTR(meter_400, 1, INSTR(meter_400, ':') - 1) AS REAL) * 60 + \n        CAST(SUBSTR(meter_400, INSTR(meter_400, ':') + 1) AS REAL) AS \"400m\",\n    CAST(SUBSTR(meter_500, 1, INSTR(meter_500, ':') - 1) AS REAL) * 60 + \n        CAST(SUBSTR(meter_500, INSTR(meter_500, ':') + 1) AS REAL) AS \"500m\",\n    CAST(SUBSTR(meter_600, 1, INSTR(meter_600, ':') - 1) AS REAL) * 60 + \n        CAST(SUBSTR(meter_600, INSTR(meter_600, ':') + 1) AS REAL) AS \"600m\",\n    CAST(SUBSTR(meter_700, 1, INSTR(meter_700, ':') - 1) AS REAL) * 60 + \n        CAST(SUBSTR(meter_700, INSTR(meter_700, ':') + 1) AS REAL) AS \"700m\"\nFROM swimmer\nWHERE meter_100 IS NOT NULL AND meter_200 IS NOT NULL AND meter_300 IS NOT NULL \n      AND meter_400 IS NOT NULL AND meter_500 IS NOT NULL AND meter_600 IS NOT NULL \n      AND meter_700 IS NOT NULL;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['Swimmer'], var_name='Interval', value_name='Time')\n\nselection = alt.selection_point(fields=['Interval'], bind='legend')\n\nchart = alt.Chart(df_melted).mark_bar().transform_calculate(\n    interval_order=f\"if({selection.name}.Interval && indexof({selection.name}.Interval, datum.Interval) !== -1, 0, 1)\"\n).encode(\n    x=alt.X('sum(Time):Q', title='Total Time (seconds)'),\n    y=alt.Y('Swimmer:N', title='Swimmer'),\n    color=alt.Color('Interval:N', title='Interval'),\n    order=alt.Order('interval_order:N'),\n    opacity=alt.condition(selection, alt.value(0.9), alt.value(0.2))\n).add_params(\n    selection\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___reorder_stacked_bar_segments.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "theme_gallery",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_grouped_bar_chart",
        "NLQ": "Can you create a chart showing exhibition attendance data from our database instead of the wheat production data? I'd like to see the total attendance for each theme, with bars colored by year. Also, can you organize it so each theme has its own row in the chart? Make the chart wider (about 600 pixels) but keep each row's height around 100 pixels.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/theme_gallery.sqlite')\n\nquery = '''\nSELECT \n    e.Theme AS Theme, \n    e.Year AS Year, \n    SUM(er.Attendance) AS Total_Attendance\nFROM \n    exhibition AS e\nJOIN \n    exhibition_record AS er ON e.Exhibition_ID = er.Exhibition_ID\nGROUP BY \n    e.Theme, e.Year\nORDER BY \n    e.Theme, e.Year\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Total_Attendance:Q',\n    y='Theme:N',\n    color='Year:N',\n    row='Theme:N'\n).properties(\n    width=600,\n    height=100\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___horizontal_grouped_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "theme_gallery",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_grouped_bar_chart",
        "NLQ": "Instead of showing wheat production by year in a horizontal bar chart, can you create a visualization that shows exhibition attendance data from my database? I'd like to group the attendance numbers by theme and year, with different colors representing different years. Also, I want to organize the chart by theme in separate rows, with each row showing the attendance for that theme. Make the chart wider (about 600 pixels) but keep each row's height around 100 pixels.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/theme_gallery.sqlite')\n\nquery = '''\nSELECT \n    e.Theme AS Theme, \n    e.Year AS Year, \n    SUM(er.Attendance) AS Total_Attendance\nFROM \n    exhibition AS e\nJOIN \n    exhibition_record AS er ON e.Exhibition_ID = er.Exhibition_ID\nGROUP BY \n    e.Theme, e.Year\nORDER BY \n    e.Theme, e.Year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Total_Attendance:Q',\n    y='Theme:N',\n    color='Year:N',\n    row='Theme:N'\n).properties(\n    width=600,\n    height=100\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___horizontal_grouped_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "theme_gallery",
        "chart_category": "Interactive Charts",
        "chart_type": "reorder_stacked_bar_segments",
        "NLQ": "I have data about exhibition attendance in a database. Can you create a bar chart showing the total attendance for each exhibition theme, with different colors representing different years? I'd like the exhibition themes listed on the y-axis and the total attendance numbers on the x-axis. Make it interactive so I can click on a year in the legend to highlight just that year's data, while the other years become more transparent. Please pull the data directly from my SQLite database called 'theme_gallery.sqlite' instead of using the random sample data in my example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/theme_gallery.sqlite')\n\nquery = '''\nSELECT \n    e.Theme AS Theme,\n    e.Year AS Year,\n    SUM(er.Attendance) AS Total_Attendance\nFROM \n    exhibition AS e\nJOIN \n    exhibition_record AS er\nON \n    e.Exhibition_ID = er.Exhibition_ID\nGROUP BY \n    e.Theme, e.Year\nORDER BY \n    e.Theme, e.Year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nselection = alt.selection_point(fields=['Year'], bind='legend')\n\nchart = alt.Chart(df).mark_bar().transform_calculate(\n    year_order=f\"if({selection.name}.Year && indexof({selection.name}.Year, datum.Year) !== -1, 0, 1)\"\n).encode(\n    x=alt.X('sum(Total_Attendance):Q', title='Total Attendance'),\n    y=alt.Y('Theme:N', title='Exhibition Theme'),\n    color=alt.Color('Year:N', title='Year'),\n    order=alt.Order('year_order:N'),\n    opacity=alt.condition(selection, alt.value(0.9), alt.value(0.2))\n).add_params(\n    selection\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___reorder_stacked_bar_segments.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "tracking_grants_for_research",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_grouped_bar_chart",
        "NLQ": "Can you create a horizontal bar chart showing the total grant amounts for different organization types? I need to pull this data from our research grants database instead of using the wheat production data. Please add a clear title \"Total Grant Amounts by Organisation Type\" and make the chart taller (about 400 pixels) so it's easier to read all the organization types.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/tracking_grants_for_research.sqlite')\n\nquery = '''\nSELECT \n    ot.organisation_type_description AS Organisation_Type,\n    SUM(g.grant_amount) AS Total_Grant_Amount\nFROM \n    Grants AS g\nJOIN \n    Organisations AS o ON g.organisation_id = o.organisation_id\nJOIN \n    Organisation_Types AS ot ON o.organisation_type = ot.organisation_type\nGROUP BY \n    ot.organisation_type_description\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Total_Grant_Amount:Q',\n    y='Organisation_Type:N'\n).properties(\n    height=400,\n    title=\"Total Grant Amounts by Organisation Type\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___horizontal_grouped_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "tracking_grants_for_research",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_grouped_bar_chart",
        "NLQ": "Instead of showing wheat values by year, I'd like to create a horizontal bar chart showing the total grant amounts for different organization types. Can you pull this data from our research grants database and display it clearly with the organization types on the y-axis and the total grant amounts on the x-axis? Please add a title \"Total Grant Amounts by Organisation Type\" and make the chart tall enough (about 400 pixels in height) so it's easy to read all the organization types.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/tracking_grants_for_research.sqlite')\nquery = '''\nSELECT \n    ot.organisation_type_description AS Organisation_Type,\n    SUM(g.grant_amount) AS Total_Grant_Amount\nFROM \n    Grants AS g\nJOIN \n    Organisations AS o ON g.organisation_id = o.organisation_id\nJOIN \n    Organisation_Types AS ot ON o.organisation_type = ot.organisation_type\nGROUP BY \n    ot.organisation_type_description\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Total_Grant_Amount:Q',\n    y='Organisation_Type:N'\n).properties(\n    height=400,\n    title=\"Total Grant Amounts by Organisation Type\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___horizontal_grouped_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "tracking_share_transactions",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_stacked_bar_chart",
        "NLQ": "Could you help me create a chart that shows the total transaction amounts for each investor, broken down by the type of transaction? I want to use my investment database instead of the sample data in your example. I'd like a horizontal bar chart where each investor is listed on the y-axis, with their total transaction amounts on the x-axis, and different transaction types shown in different colors. Please add a title that says \"Total Transaction Amounts by Investor and Type\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/tracking_share_transactions.sqlite')\n\nquery = '''\nSELECT \n    I.Investor_details AS investor,\n    RT.transaction_type_description AS transaction_type,\n    SUM(T.amount_of_transaction) AS total_amount\nFROM \n    Transactions AS T\nJOIN \n    Investors AS I ON T.investor_id = I.investor_id\nJOIN \n    Ref_Transaction_Types AS RT ON T.transaction_type_code = RT.transaction_type_code\nGROUP BY \n    I.Investor_details, RT.transaction_type_description\nORDER BY \n    I.Investor_details\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='sum(total_amount):Q',\n    y='investor:N',\n    color='transaction_type:N'\n).properties(\n    title=\"Total Transaction Amounts by Investor and Type\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___horizontal_stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "tracking_share_transactions",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_stacked_bar_chart",
        "NLQ": "Could you create a horizontal stacked bar chart showing the total transaction amounts for each investor, broken down by transaction type? I want to see how much money each investor has put in, with different colors representing different transaction types. I need this data to come from our SQL database that tracks share transactions, not from the barley yield dataset we were using before. And can you use Altair instead of Matplotlib for this visualization? Make sure to give it a clear title like \"Total Transaction Amounts by Investor and Type\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/tracking_share_transactions.sqlite')\n\nquery = '''\nSELECT \n    I.Investor_details AS investor,\n    RT.transaction_type_description AS transaction_type,\n    SUM(T.amount_of_transaction) AS total_amount\nFROM \n    Transactions AS T\nJOIN \n    Investors AS I ON T.investor_id = I.investor_id\nJOIN \n    Ref_Transaction_Types AS RT ON T.transaction_type_code = RT.transaction_type_code\nGROUP BY \n    I.Investor_details, RT.transaction_type_description\nORDER BY \n    I.Investor_details\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='sum(total_amount):Q',\n    y='investor:N',\n    color='transaction_type:N'\n).properties(\n    title=\"Total Transaction Amounts by Investor and Type\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___horizontal_stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "tracking_share_transactions",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "error_bars_with_standard_deviation",
        "NLQ": "I have a chart showing barley yields for different varieties with error bars. Can you create a similar visualization but for my transaction data from my SQLite database? I need to show transaction amounts by transaction type, with error bars showing the standard deviation. Keep the black dots for the mean values, but make them filled. Also, please add proper axis titles - \"Transaction Amount\" for the x-axis and \"Transaction Type\" for the y-axis. Make sure the x-axis doesn't start at zero so we can better see the differences.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\ndatabase_path = 'database/tracking_share_transactions.sqlite'\nconn = sqlite3.connect(database_path)\n\nquery = '''\nSELECT\n    T2.transaction_type_description,\n    T1.amount_of_transaction\nFROM Transactions AS T1\nJOIN Ref_Transaction_Types AS T2 ON T1.transaction_type_code = T2.transaction_type_code;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nerror_bars = alt.Chart(df).mark_errorbar(extent='stdev').encode(\n    x=alt.X('amount_of_transaction', scale=alt.Scale(zero=False), title='Transaction Amount'),\n    y=alt.Y('transaction_type_description', title='Transaction Type')\n)\n\npoints = alt.Chart(df).mark_point(filled=True, color='black').encode(\n    x=alt.X('mean(amount_of_transaction)', title='Mean Transaction Amount'),\n    y=alt.Y('transaction_type_description', title='Transaction Type'),\n)\n\nerror_bars + points",
        "reference_path": "./vis_bench/code/altair/Uncertainties And Trends___error_bars_with_standard_deviation.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "tracking_share_transactions",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "error_bars_with_standard_deviation",
        "NLQ": "I have this chart showing barley yields for different varieties with error bars, but I need to change it to show my transaction data from my SQLite database instead. Can you create a similar chart that shows transaction amounts by transaction type, still keeping the error bars to show variation and the black dots for the mean values? I need it to pull data directly from my tracking_share_transactions database rather than using the hardcoded barley data.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\ndatabase_path = 'database/tracking_share_transactions.sqlite'\nconn = sqlite3.connect(database_path)\n\nquery = '''\nSELECT\n    T2.transaction_type_description,\n    T1.amount_of_transaction\nFROM Transactions AS T1\nJOIN Ref_Transaction_Types AS T2 ON T1.transaction_type_code = T2.transaction_type_code;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nerror_bars = alt.Chart(df).mark_errorbar(extent='stdev').encode(\n    x=alt.X('amount_of_transaction', scale=alt.Scale(zero=False), title='Transaction Amount'),\n    y=alt.Y('transaction_type_description', title='Transaction Type')\n)\n\npoints = alt.Chart(df).mark_point(filled=True, color='black').encode(\n    x=alt.X('mean(amount_of_transaction)', title='Mean Transaction Amount'),\n    y=alt.Y('transaction_type_description', title='Transaction Type'),\n)\n\nerror_bars + points",
        "reference_path": "./vis_bench/code/matplotlib/Uncertainties And Trends___error_bars_with_standard_deviation.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "tracking_software_problems",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_stacked_bar_chart",
        "NLQ": "I need to create a horizontal bar chart showing the distribution of software problems by category and status. Can you pull data from our tracking database instead of using the sample data in the reference? I want to see the count of problems for each category, with different colors representing the different status types. Please add a title \"Problem Distribution by Category and Status\" to make it clear what the chart is showing.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/tracking_software_problems.sqlite')\n\nquery = '''\nSELECT \n    pcc.problem_category_description AS category,\n    psc.problem_status_description AS status,\n    COUNT(*) AS count\nFROM \n    Problem_Log AS pl\nJOIN \n    Problem_Category_Codes AS pcc ON pl.problem_category_code = pcc.problem_category_code\nJOIN \n    Problem_Status_Codes AS psc ON pl.problem_status_code = psc.problem_status_code\nGROUP BY \n    pcc.problem_category_description, psc.problem_status_description\nORDER BY \n    pcc.problem_category_description, psc.problem_status_description;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='sum(count):Q',\n    y='category:N',\n    color='status:N'\n).properties(\n    title=\"Problem Distribution by Category and Status\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___horizontal_stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "tracking_software_problems",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_stacked_bar_chart",
        "NLQ": "I need to create a horizontal bar chart showing the distribution of software problems by category and status. Instead of using the barley yield data from the example, can you pull data from my tracking software database and group it by problem category and status? I'd like each problem category to be a row, with the bars colored by different status types. Please add a title \"Problem Distribution by Category and Status\" to make it clear what the chart is showing. I want to see the total count of problems in each category-status combination.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/tracking_software_problems.sqlite')\n\nquery = '''\nSELECT \n    pcc.problem_category_description AS category,\n    psc.problem_status_description AS status,\n    COUNT(*) AS count\nFROM \n    Problem_Log AS pl\nJOIN \n    Problem_Category_Codes AS pcc ON pl.problem_category_code = pcc.problem_category_code\nJOIN \n    Problem_Status_Codes AS psc ON pl.problem_status_code = psc.problem_status_code\nGROUP BY \n    pcc.problem_category_description, psc.problem_status_description\nORDER BY \n    pcc.problem_category_description, psc.problem_status_description;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='sum(count):Q',\n    y='category:N',\n    color='status:N'\n).properties(\n    title=\"Problem Distribution by Category and Status\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___horizontal_stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "train_station",
        "chart_category": "Bar Charts",
        "chart_type": "layered_bar_chart",
        "NLQ": "I have this chart showing energy generation from different sources over the years, but I'd like to change it to show London train station data instead. Can you create a bar chart that shows passenger counts for different London stations? I need to see both entry/exit numbers and interchange numbers for each station, using different colors for each type of traffic. The data should come from our train station database rather than using random numbers.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/train_station.sqlite')\n\nquery = '''\nSELECT \n    Name AS Station_Name,\n    Annual_entry_exit AS Entry_Exit,\n    Annual_interchanges AS Interchanges\nFROM \n    station\nWHERE \n    Location = 'London'\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars='Station_Name', value_vars=['Entry_Exit', 'Interchanges'], \n                    var_name='Traffic_Type', value_name='Passenger_Count')\n\nchart = alt.Chart(df_melted).mark_bar(opacity=0.7).encode(\n    x='Station_Name:N',\n    y=alt.Y('Passenger_Count:Q').stack(None),\n    color='Traffic_Type:N'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___layered_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "train_station",
        "chart_category": "Bar Charts",
        "chart_type": "layered_bar_chart",
        "NLQ": "Instead of showing energy generation by source over time, can you create a bar chart that shows passenger traffic data for London train stations? I need to see both entry/exit numbers and interchange numbers for each station, but don't stack them - I want to compare them side by side. Pull this data from the train station database and make sure to use different colors to distinguish between the two traffic types.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/train_station.sqlite')\n\nquery = '''\nSELECT \n    Name AS Station_Name,\n    Annual_entry_exit AS Entry_Exit,\n    Annual_interchanges AS Interchanges\nFROM \n    station\nWHERE \n    Location = 'London'\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ndf_melted = df.melt(id_vars='Station_Name', value_vars=['Entry_Exit', 'Interchanges'], \n                    var_name='Traffic_Type', value_name='Passenger_Count')\n\nchart = alt.Chart(df_melted).mark_bar(opacity=0.7).encode(\n    x='Station_Name:N',\n    y=alt.Y('Passenger_Count:Q').stack(None),\n    color='Traffic_Type:N'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___layered_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "tvshow",
        "chart_category": "Bar Charts",
        "chart_type": "layered_bar_chart",
        "NLQ": "Can you create a chart showing TV series data instead of energy sources? I want to see how different TV shows compare based on their ratings and total viewers. Each TV series should be on the x-axis, with bars showing the total viewers for each rating category. Make the bars slightly transparent and don't stack them so I can see all the ratings for each show side by side. The data should come from my TV show database instead of the random data in the example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/tvshow.sqlite')\nquery = '''\nSELECT \n    T2.series_name AS Series_Name,\n    T1.Rating,\n    SUM(CAST(T1.Viewers_m AS REAL)) AS Total_Viewers\nFROM \n    TV_series AS T1\nJOIN \n    TV_Channel AS T2\nON \n    T1.Channel = T2.id\nGROUP BY \n    T2.series_name, T1.Rating\nORDER BY \n    T2.series_name, T1.Rating;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar(opacity=0.7).encode(\n    x='Series_Name:N',\n    y=alt.Y('Total_Viewers:Q').stack(None),\n    color='Rating:N'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___layered_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "tvshow",
        "chart_category": "Bar Charts",
        "chart_type": "layered_bar_chart",
        "NLQ": "Can you create a chart that shows TV series data instead of energy sources? I want to see how different TV shows compare based on their ratings and total viewers. Each TV series should be on the x-axis, with bars showing the total viewers for each rating category. Please use different colors to represent the different ratings, and make the bars slightly transparent. I need to pull this data from my TV show database rather than using the random data in the example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/tvshow.sqlite')\n\nquery = '''\nSELECT \n    T2.series_name AS Series_Name,\n    T1.Rating,\n    SUM(CAST(T1.Viewers_m AS REAL)) AS Total_Viewers\nFROM \n    TV_series AS T1\nJOIN \n    TV_Channel AS T2\nON \n    T1.Channel = T2.id\nGROUP BY \n    T2.series_name, T1.Rating\nORDER BY \n    T2.series_name, T1.Rating;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar(opacity=0.7).encode(\n    x='Series_Name:N',\n    y=alt.Y('Total_Viewers:Q').stack(None),\n    color='Rating:N'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___layered_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "twitter_1",
        "chart_category": "Bar Charts",
        "chart_type": "layered_bar_chart",
        "NLQ": "I have a chart showing energy generation by different sources over the years, but I'd like to create a new visualization that shows how many tweets are posted on each day of the week by popular Twitter users who have over a million followers. Could you pull this data from our Twitter database? I want to see the tweet counts for each day of the week with different colors representing different users. Please use actual weekday names instead of numbers, add proper titles to the axes like \"Day of Week\" and \"Number of Tweets,\" and give the chart a clear title that explains what we're looking at. Also, make the bars slightly transparent so we can see overlapping data better, and don't stack the bars so we can compare users more easily.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/twitter_1.sqlite')\n\nquery = '''\nSELECT \n    strftime('%w', t.createdate) AS day_of_week,\n    u.name AS user_name,\n    COUNT(t.id) AS tweet_count\nFROM \n    tweets AS t\nJOIN \n    user_profiles AS u ON t.uid = u.uid\nWHERE \n    u.followers > 1000000\nGROUP BY \n    day_of_week, user_name\nORDER BY \n    day_of_week;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nweekday_map = {\n    '0': 'Sunday',\n    '1': 'Monday',\n    '2': 'Tuesday',\n    '3': 'Wednesday',\n    '4': 'Thursday',\n    '5': 'Friday',\n    '6': 'Saturday'\n}\ndf['day_of_week'] = df['day_of_week'].map(weekday_map)\n\nchart = alt.Chart(df).mark_bar(opacity=0.7).encode(\n    x=alt.X('day_of_week:N', title='Day of Week'),\n    y=alt.Y('tweet_count:Q', title='Number of Tweets').stack(None),\n    color=alt.Color('user_name:N', title='User')\n).properties(\n    title='Tweets by Users with >1M Followers Grouped by Day of Week'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___layered_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "twitter_1",
        "chart_category": "Bar Charts",
        "chart_type": "layered_bar_chart",
        "NLQ": "Instead of showing energy generation by source over the years, could you create a bar chart that shows how many tweets are posted on each day of the week by popular users with over a million followers? I'd like to see the data pulled from our Twitter database, with each user represented by a different color. Make sure to use actual weekday names instead of numbers, and give it a clear title that explains what we're looking at. I prefer the bars to be slightly transparent and not stacked on top of each other so we can compare users more easily.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/twitter_1.sqlite')\nquery = '''\nSELECT \n    strftime('%w', t.createdate) AS day_of_week,\n    u.name AS user_name,\n    COUNT(t.id) AS tweet_count\nFROM \n    tweets AS t\nJOIN \n    user_profiles AS u ON t.uid = u.uid\nWHERE \n    u.followers > 1000000\nGROUP BY \n    day_of_week, user_name\nORDER BY \n    day_of_week;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nweekday_map = {\n    '0': 'Sunday',\n    '1': 'Monday',\n    '2': 'Tuesday',\n    '3': 'Wednesday',\n    '4': 'Thursday',\n    '5': 'Friday',\n    '6': 'Saturday'\n}\ndf['day_of_week'] = df['day_of_week'].map(weekday_map)\n\nchart = alt.Chart(df).mark_bar(opacity=0.7).encode(\n    x=alt.X('day_of_week:N', title='Day of Week'),\n    y=alt.Y('tweet_count:Q', title='Number of Tweets').stack(None),\n    color=alt.Color('user_name:N', title='User')\n).properties(\n    title='Tweets by Users with >1M Followers Grouped by Day of Week'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___layered_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "twitter_1",
        "chart_category": "Interactive Charts",
        "chart_type": "selection_detail",
        "NLQ": "Can you change my visualization to show Twitter user data instead of random points? I want a scatter plot showing each user's follower count versus their tweet count, and when I click on a user, I want to see their tweet activity over time in the line chart. Please pull this data from my Twitter database, add tooltips so I can see user names and counts when hovering, and make the points bigger and filled in. The line chart should show tweet timestamps on the x-axis instead of just numbers.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/twitter_1.sqlite')\n\nquery = '''\nSELECT \n    up.uid AS user_id,\n    up.name AS user_name,\n    up.followers AS follower_count,\n    COUNT(t.id) AS tweet_count,\n    t.createdate AS tweet_timestamp\nFROM \n    user_profiles AS up\nLEFT JOIN \n    tweets AS t ON up.uid = t.uid\nGROUP BY \n    up.uid, up.name, up.followers\nORDER BY \n    follower_count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ndf['tweet_timestamp'] = pd.to_datetime(df['tweet_timestamp'])\ndf = df.explode('tweet_timestamp').reset_index(drop=True)\n\nselector = alt.selection_point(fields=['user_id'])\n\ncolor = (\n    alt.when(selector)\n    .then(alt.Color(\"user_name:N\").legend(None))\n    .otherwise(alt.value(\"lightgray\"))\n)\n\nbase = alt.Chart(df).properties(\n    width=250,\n    height=250\n).add_params(selector)\n\npoints = base.mark_point(filled=True, size=200).encode(\n    x='follower_count:Q',\n    y='tweet_count:Q',\n    color=color,\n    tooltip=['user_name:N', 'follower_count:Q', 'tweet_count:Q']\n)\n\nline = base.mark_line().encode(\n    x='tweet_timestamp:T',\n    y=alt.Y('tweet_count:Q').scale(domain=(0, df['tweet_count'].max())),\n    color=alt.Color('user_name:N').legend(None)\n).transform_filter(\n    selector\n)\n\npoints | line",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___selection_detail.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "twitter_1",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "line_chart_with_confidence_interval_band",
        "NLQ": "Using the code I shared as a starting point, can you create a graph that shows how the average number of Twitter followers changes over time? I'd like to pull this data from our Twitter database instead of using the random car data. The graph should show dates on the x-axis and followers on the y-axis, with a line showing the average followers per day. Please add a shaded area around the line to show the confidence interval of individual follower counts. Also, can you add a title that says \"Average Followers per Day with Confidence Interval\"?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/twitter_1.sqlite')\n\nquery = '''\nSELECT \n    DATE(t.createdate) AS date, \n    AVG(up.followers) AS avg_followers, \n    up.followers AS individual_followers\nFROM \n    tweets AS t\nJOIN \n    user_profiles AS up \nON \n    t.uid = up.uid\nGROUP BY \n    DATE(t.createdate), up.uid\nORDER BY \n    DATE(t.createdate)\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nline = alt.Chart(df).mark_line().encode(\n    x='date:T',\n    y='mean(avg_followers):Q'\n)\n\nband = alt.Chart(df).mark_errorband(extent='ci').encode(\n    x='date:T',\n    y=alt.Y('individual_followers:Q').title('Followers')\n)\n\nchart = band + line\nchart.properties(title=\"Average Followers per Day with Confidence Interval\")",
        "reference_path": "./vis_bench/code/altair/Uncertainties And Trends___line_chart_with_confidence_interval_band.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "twitter_1",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "line_chart_with_confidence_interval_band",
        "NLQ": "Can you create a graph showing how Twitter users' average followers change over time? I'd like to use my Twitter database instead of the car MPG data in the example. Please show a line for the average followers per day, with a shaded confidence interval around it to show the variation in individual follower counts. Label the y-axis as \"Followers\" and make sure to include dates on the x-axis. Also, add a title that says \"Average Followers per Day with Confidence Interval\" and switch from matplotlib to Altair for creating the visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/twitter_1.sqlite')\n\nquery = '''\nSELECT \n    DATE(t.createdate) AS date, \n    AVG(up.followers) AS avg_followers, \n    up.followers AS individual_followers\nFROM \n    tweets AS t\nJOIN \n    user_profiles AS up \nON \n    t.uid = up.uid\nGROUP BY \n    DATE(t.createdate), up.uid\nORDER BY \n    DATE(t.createdate)\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nline = alt.Chart(df).mark_line().encode(\n    x='date:T',\n    y='mean(avg_followers):Q'\n)\n\nband = alt.Chart(df).mark_errorband(extent='ci').encode(\n    x='date:T',\n    y=alt.Y('individual_followers:Q').title('Followers')\n)\n\nchart = band + line\nchart.properties(title=\"Average Followers per Day with Confidence Interval\")",
        "reference_path": "./vis_bench/code/matplotlib/Uncertainties And Trends___line_chart_with_confidence_interval_band.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "university_basketball",
        "chart_category": "Bar Charts",
        "chart_type": "normalized_stacked_bar_chart",
        "NLQ": "I want to make a chart that looks like the one in my code, but instead of showing barley varieties and yields, I need it to show basketball team performance. Can you create a stacked bar chart that compares how well each basketball team performed at home versus on the road in ACC games? Use the university basketball database to get the team names and their win records. The bars should be normalized so we can see the proportion of home wins versus road wins for each team. Also, please add a title that says \"Normalized Comparison of ACC Home vs Road Wins\" to make it clear what the chart is showing.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/university_basketball.sqlite')\nquery = '''\nSELECT \n    Team_Name,\n    CAST(SUBSTR(ACC_Home, 1, INSTR(ACC_Home, '–') - 1) AS INT) AS ACC_Home_Wins,\n    CAST(SUBSTR(ACC_Road, 1, INSTR(ACC_Road, '–') - 1) AS INT) AS ACC_Road_Wins\nFROM basketball_match\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_long = df.melt(id_vars=['Team_Name'], \n                  value_vars=['ACC_Home_Wins', 'ACC_Road_Wins'],\n                  var_name='Game_Location', \n                  value_name='Wins')\n\nchart = alt.Chart(df_long).mark_bar().encode(\n    x=alt.X('sum(Wins)').stack(\"normalize\"),\n    y='Team_Name:N',\n    color='Game_Location:N'\n).properties(\n    title=\"Normalized Comparison of ACC Home vs Road Wins\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___normalized_stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "university_basketball",
        "chart_category": "Bar Charts",
        "chart_type": "normalized_stacked_bar_chart",
        "NLQ": "I want to change my visualization to show basketball team performance instead of crop varieties. Can you create a normalized stacked bar chart that compares how each team performed at home versus on the road in ACC games? Use the university basketball database to get the team names and their ACC home and road wins. Make the bars horizontal with team names on the y-axis, and show the proportion of home vs road wins for each team as percentages that add up to 100%. Please add a clear title that explains what we're looking at.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/university_basketball.sqlite')\n\nquery = '''\nSELECT \n    Team_Name,\n    CAST(SUBSTR(ACC_Home, 1, INSTR(ACC_Home, '–') - 1) AS INT) AS ACC_Home_Wins,\n    CAST(SUBSTR(ACC_Road, 1, INSTR(ACC_Road, '–') - 1) AS INT) AS ACC_Road_Wins\nFROM basketball_match\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_long = df.melt(id_vars=['Team_Name'], \n                  value_vars=['ACC_Home_Wins', 'ACC_Road_Wins'],\n                  var_name='Game_Location', \n                  value_name='Wins')\n\nchart = alt.Chart(df_long).mark_bar().encode(\n    x=alt.X('sum(Wins)').stack(\"normalize\"),\n    y='Team_Name:N',\n    color='Game_Location:N'\n).properties(\n    title=\"Normalized Comparison of ACC Home vs Road Wins\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___normalized_stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "university_basketball",
        "chart_category": "Interactive Charts",
        "chart_type": "selection_detail",
        "NLQ": "Can you create a visualization for my basketball team data that shows each team's overall win percentage? I'd like to be able to click on a team name to highlight it and see a breakdown of their performance in home games, road games, and neutral site games in a separate chart. When I select a team, it should change color while the other teams turn light gray. For the first chart, put the team names on the y-axis and their overall win percentage on the x-axis. In the second chart, show the win percentages for the different game types with a line connecting them. Make sure the win percentage scale goes from 0 to 1.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/university_basketball.sqlite')\n\nquery = '''\nSELECT \n    bm.Team_Name,\n    bm.All_Games_Percent AS Overall_Win_Percent,\n    CAST(SUBSTR(bm.All_Home, 1, INSTR(bm.All_Home, '–') - 1) AS REAL) / \n    (CAST(SUBSTR(bm.All_Home, 1, INSTR(bm.All_Home, '–') - 1) AS REAL) + \n     CAST(SUBSTR(bm.All_Home, INSTR(bm.All_Home, '–') + 1) AS REAL)) AS Home_Win_Percent,\n    CAST(SUBSTR(bm.All_Road, 1, INSTR(bm.All_Road, '–') - 1) AS REAL) / \n    (CAST(SUBSTR(bm.All_Road, 1, INSTR(bm.All_Road, '–') - 1) AS REAL) + \n     CAST(SUBSTR(bm.All_Road, INSTR(bm.All_Road, '–') + 1) AS REAL)) AS Road_Win_Percent,\n    CAST(SUBSTR(bm.All_Neutral, 1, INSTR(bm.All_Neutral, '–') - 1) AS REAL) / \n    (CAST(SUBSTR(bm.All_Neutral, 1, INSTR(bm.All_Neutral, '–') - 1) AS REAL) + \n     CAST(SUBSTR(bm.All_Neutral, INSTR(bm.All_Neutral, '–') + 1) AS REAL)) AS Neutral_Win_Percent\nFROM \n    basketball_match AS bm\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nmelted_df = df.melt(id_vars=['Team_Name', 'Overall_Win_Percent'], \n                    value_vars=['Home_Win_Percent', 'Road_Win_Percent', 'Neutral_Win_Percent'],\n                    var_name='Game_Type', value_name='Win_Percent')\n\nselector = alt.selection_point(fields=['Team_Name'])\n\ncolor = (\n    alt.when(selector)\n    .then(alt.Color(\"Team_Name:N\").legend(None))\n    .otherwise(alt.value(\"lightgray\"))\n)\n\nbase = alt.Chart(df).properties(\n    width=250,\n    height=250\n).add_params(selector)\n\npoints = base.mark_point(filled=True, size=200).encode(\n    x=alt.X('Overall_Win_Percent:Q', title='Overall Win Percentage'),\n    y=alt.Y('Team_Name:N', title='Team Name'),\n    color=color\n)\n\nline = alt.Chart(melted_df).mark_line().encode(\n    x=alt.X('Game_Type:N', title='Game Type'),\n    y=alt.Y('Win_Percent:Q', title='Win Percentage', scale=alt.Scale(domain=(0, 1))),\n    color=alt.Color('Team_Name:N').legend(None)\n).transform_filter(\n    selector\n)\n\npoints | line",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___selection_detail.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "voter_1",
        "chart_category": "Bar Charts",
        "chart_type": "normalized_stacked_bar_chart",
        "NLQ": "Can you create a chart that shows how votes are distributed across different states for each contestant in our voting database? I'd like to see a stacked bar chart where each contestant has a bar showing the percentage breakdown of their votes by state. Make sure each bar adds up to 100% so we can easily compare the state distribution patterns. Please add a clear title like \"Vote Distribution Across States for Each Contestant\" and label the x-axis as \"Percentage of Votes\". You'll need to pull the data from our voter database using the VOTES and CONTESTANTS tables.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/voter_1.sqlite')\n\nquery = '''\nSELECT \n    CONTESTANTS.contestant_name AS contestant,\n    VOTES.state AS state,\n    COUNT(VOTES.vote_id) AS vote_count\nFROM VOTES\nJOIN CONTESTANTS ON VOTES.contestant_number = CONTESTANTS.contestant_number\nGROUP BY CONTESTANTS.contestant_name, VOTES.state\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('sum(vote_count)').stack(\"normalize\").title('Percentage of Votes'),\n    y='contestant:N',\n    color='state:N'\n).properties(\n    title='Vote Distribution Across States for Each Contestant'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___normalized_stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "voter_1",
        "chart_category": "Bar Charts",
        "chart_type": "normalized_stacked_bar_chart",
        "NLQ": "Can you create a chart showing how votes are distributed across different states for each contestant in our voting database? I'd like to see a horizontal bar chart where each contestant has a bar that shows the percentage breakdown of their votes by state. Each state should be a different color, and the bars should be normalized so they all add up to 100%. Please add a title that explains what the chart is showing, and make sure the x-axis is labeled as \"Percentage of Votes\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/voter_1.sqlite')\n\nquery = '''\nSELECT \n    CONTESTANTS.contestant_name AS contestant,\n    VOTES.state AS state,\n    COUNT(VOTES.vote_id) AS vote_count\nFROM VOTES\nJOIN CONTESTANTS ON VOTES.contestant_number = CONTESTANTS.contestant_number\nGROUP BY CONTESTANTS.contestant_name, VOTES.state\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('sum(vote_count)').stack(\"normalize\").title('Percentage of Votes'),\n    y='contestant:N',\n    color='state:N'\n).properties(\n    title='Vote Distribution Across States for Each Contestant'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___normalized_stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "voter_2",
        "chart_category": "Bar Charts",
        "chart_type": "normalized_stacked_bar_chart",
        "NLQ": "I have this chart showing barley varieties and their yields across different sites, but I'd like to change it to show voting data instead. Can you create a similar normalized stacked bar chart but using my election data from my SQLite database? I want to show the breakdown of president, vice president, and secretary votes for each election cycle. Keep the same stacked bar style but flip the orientation so election cycles are on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/voter_2.sqlite')\n\nquery = '''\nSELECT \n    Election_Cycle,\n    SUM(President_Vote) AS Total_President_Votes,\n    SUM(Vice_President_Vote) AS Total_Vice_President_Votes,\n    SUM(Secretary_Vote) AS Total_Secretary_Votes\nFROM Voting_record\nGROUP BY Election_Cycle\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['Election_Cycle'], \n                    value_vars=['Total_President_Votes', 'Total_Vice_President_Votes', 'Total_Secretary_Votes'],\n                    var_name='Vote_Type', value_name='Total_Votes')\n\nchart = alt.Chart(df_melted).mark_bar().encode(\n    x=alt.X('sum(Total_Votes)').stack(\"normalize\"),\n    y='Election_Cycle',\n    color='Vote_Type'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___normalized_stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "voter_2",
        "chart_category": "Bar Charts",
        "chart_type": "normalized_stacked_bar_chart",
        "NLQ": "I have some voting data from a database with information about president, vice president, and secretary votes across different election cycles. Can you create a horizontal stacked bar chart that shows the proportion of each vote type within each election cycle? I'd like to see the relative distribution of these vote types side by side, with different colors for each vote type, and have the election cycles listed along the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/voter_2.sqlite')\n\nquery = '''\nSELECT \n    Election_Cycle,\n    SUM(President_Vote) AS Total_President_Votes,\n    SUM(Vice_President_Vote) AS Total_Vice_President_Votes,\n    SUM(Secretary_Vote) AS Total_Secretary_Votes\nFROM Voting_record\nGROUP BY Election_Cycle\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['Election_Cycle'], \n                    value_vars=['Total_President_Votes', 'Total_Vice_President_Votes', 'Total_Secretary_Votes'],\n                    var_name='Vote_Type', value_name='Total_Votes')\n\nchart = alt.Chart(df_melted).mark_bar().encode(\n    x=alt.X('sum(Total_Votes)').stack(\"normalize\"),\n    y='Election_Cycle',\n    color='Vote_Type'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___normalized_stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "voter_2",
        "chart_category": "Interactive Charts",
        "chart_type": "selection_histogram",
        "NLQ": "Can you change this visualization to show student voting data from our database instead of car information? I'd like to see student ages on the x-axis and the count of students on the y-axis in the scatter plot. For the bar chart, I want to see city codes on the x-axis and the count of students from each city on the y-axis. Also, please color-code the points and bars by city code, and keep the interactive selection feature so when I select points in the scatter plot, the bar chart updates to show only those selected students. Only include students who voted in the Spring election cycle.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/voter_2.sqlite')\nquery = '''\nSELECT S.Age, S.city_code\nFROM Student AS S\nJOIN Voting_record AS V ON S.StuID = V.StuID\nWHERE V.Election_Cycle = 'Spring'\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(df).mark_point().encode(\n    x='Age:Q',\n    y='count():Q',\n    color=alt.condition(brush, 'city_code:N', alt.value('lightgray'))\n).add_params(\n    brush\n)\n\nbars = alt.Chart(df).mark_bar().encode(\n    x='city_code:N',\n    y='count(city_code):Q',\n    color='city_code:N'\n).transform_filter(\n    brush\n)\n\npoints & bars",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___selection_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "voter_2",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "polynomial_fit_plot_with_regression_transform",
        "NLQ": "Instead of using the sample data in my code, can you create a chart that shows how student ages relate to their advisors from my database? I need the data to come from the Student table in my voter_2.sqlite database. Keep the same polynomial fit lines with degrees 1, 3, and 5, but make the actual data points black dots instead of the default color. Everything else should stay the same as my original chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/voter_2.sqlite')\n\nquery = '''\nSELECT Age, Advisor FROM Student;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf.rename(columns={'Age': 'x', 'Advisor': 'y'}, inplace=True)\n\ndegree_list = [1, 3, 5]\n\nbase = alt.Chart(df).mark_circle(color=\"black\").encode(\n    alt.X(\"x\"),\n    alt.Y(\"y\")\n)\n\npolynomial_fit = [\n    base.transform_regression(\n        \"x\", \"y\", method=\"poly\", order=order, as_=[\"x\", str(order)]\n    )\n    .mark_line()\n    .transform_fold([str(order)], as_=[\"degree\", \"y\"])\n    .encode(alt.Color(\"degree:N\"))\n    for order in degree_list\n]\n\nchart = alt.layer(base, *polynomial_fit)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Uncertainties And Trends___polynomial_fit_plot_with_regression_transform.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "voter_2",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "polynomial_fit_plot_with_regression_transform",
        "NLQ": "Instead of using my random data, can you create a scatter plot using real student data from our voter database? I need to see the relationship between student ages and their advisors. Keep the black dots for the data points and show the same polynomial fit lines (degrees 1, 3, and 5) as in my example, but use different colors for each line. Also, can you switch from matplotlib to Altair for this visualization?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/voter_2.sqlite')\n\nquery = '''\nSELECT Age, Advisor FROM Student;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf.rename(columns={'Age': 'x', 'Advisor': 'y'}, inplace=True)\n\ndegree_list = [1, 3, 5]\n\nbase = alt.Chart(df).mark_circle(color=\"black\").encode(\n    alt.X(\"x\"),\n    alt.Y(\"y\")\n)\n\npolynomial_fit = [\n    base.transform_regression(\n        \"x\", \"y\", method=\"poly\", order=order, as_=[\"x\", str(order)]\n    )\n    .mark_line()\n    .transform_fold([str(order)], as_=[\"degree\", \"y\"])\n    .encode(alt.Color(\"degree:N\"))\n    for order in degree_list\n]\n\nchart = alt.layer(base, *polynomial_fit)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Uncertainties And Trends___polynomial_fit_plot_with_regression_transform.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "workshop_paper",
        "chart_category": "Bar Charts",
        "chart_type": "sorted_bar_chart",
        "NLQ": "I want to create a chart that looks like the one in my code, but instead of showing crop yields for different sites, I'd like it to display colleges and their average scores. The bars should be sorted from highest to lowest, just like in the example I provided. Also, instead of using the sample data in the code, could you pull the information from our workshop_paper database? I need to get the average scores for each college from the submission table.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/workshop_paper.sqlite')\nquery = '''\nSELECT College, AVG(Scores) AS Average_Score\nFROM submission\nGROUP BY College\nORDER BY Average_Score DESC\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Average_Score:Q',\n    y=alt.Y('College:N').sort('-x')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___sorted_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "workshop_paper",
        "chart_category": "Bar Charts",
        "chart_type": "sorted_bar_chart",
        "NLQ": "I want to change my bar chart to show colleges and their average scores instead of sites and yields. Can you switch from matplotlib to Altair and pull the data from our SQLite database instead of using the hardcoded data? Keep the horizontal bar format with the highest values at the top like in my original chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/workshop_paper.sqlite')\nquery = '''\nSELECT College, AVG(Scores) AS Average_Score\nFROM submission\nGROUP BY College\nORDER BY Average_Score DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Average_Score:Q',\n    y=alt.Y('College:N').sort('-x')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___sorted_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "world_1",
        "chart_category": "Bar Charts",
        "chart_type": "sorted_bar_chart",
        "NLQ": "Instead of showing yield data for different sites, can you create a similar bar chart but show the top 10 most populous cities in the world? I'd like to keep the same layout with city names listed vertically on the left and horizontal bars showing their populations, sorted from highest to lowest population. Please pull this data from the world database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/world_1.sqlite')\nquery = '''\nSELECT Name, Population\nFROM city\nORDER BY Population DESC\nLIMIT 10\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Population:Q',\n    y=alt.Y('Name:N').sort('-x')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___sorted_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "world_1",
        "chart_category": "Bar Charts",
        "chart_type": "sorted_bar_chart",
        "NLQ": "Instead of showing yield data by site, can you create a chart that shows the top 10 cities with the largest populations? I'd like to pull this data from our world database rather than using the sample data. Keep the horizontal bar chart format with cities listed vertically and sorted from highest to lowest population, but let's use Altair instead of Matplotlib for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/world_1.sqlite')\nquery = '''\nSELECT Name, Population\nFROM city\nORDER BY Population DESC\nLIMIT 10\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Population:Q',\n    y=alt.Y('Name:N').sort('-x')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___sorted_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "world_1",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "scatter_plot_with_loess_lines",
        "NLQ": "Can you create a scatter plot showing the relationship between population and GNP for European countries? I'd like to see dots for each country with a smooth trend line. Make the dots slightly transparent and the trend line thicker. Please get the data from our world database, but only include European countries that have GNP values and populations greater than zero. Label the axes as \"Population\" and \"Gross National Product (GNP)\" and make the chart 600x400 in size.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/world_1.sqlite')\nquery = '''\nSELECT \n    country.Population, \n    country.GNP, \n    country.Continent\nFROM \n    country\nWHERE \n    country.Continent = 'Europe' AND country.GNP IS NOT NULL AND country.Population > 0\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).mark_circle(opacity=0.7).encode(\n    alt.X('Population:Q', title='Population'),\n    alt.Y('GNP:Q', title='Gross National Product (GNP)'),\n    alt.Color('Continent:N', title='Continent')\n)\nchart = base + base.transform_loess('Population', 'GNP', groupby=['Continent']).mark_line(size=3)\nchart.properties(width=600, height=400)",
        "reference_path": "./vis_bench/code/altair/Uncertainties And Trends___scatter_plot_with_loess_lines.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "world_1",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "scatter_plot_with_loess_lines",
        "NLQ": "Instead of using my example code with random data, could you create a scatter plot that shows the relationship between population and GNP specifically for European countries? I'd like to pull this data from our SQLite database. Keep the smooth trend lines like in my example, but use circles for the data points and make them slightly transparent. Label the axes properly as \"Population\" and \"Gross National Product (GNP)\" and make the chart a decent size - about 600 by 400 pixels.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/world_1.sqlite')\nquery = '''\nSELECT \n    country.Population, \n    country.GNP, \n    country.Continent\nFROM \n    country\nWHERE \n    country.Continent = 'Europe' AND country.GNP IS NOT NULL AND country.Population > 0\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).mark_circle(opacity=0.7).encode(\n    alt.X('Population:Q', title='Population'),\n    alt.Y('GNP:Q', title='Gross National Product (GNP)'),\n    alt.Color('Continent:N', title='Continent')\n)\n\nchart = base + base.transform_loess('Population', 'GNP', groupby=['Continent']).mark_line(size=3)\nchart.properties(width=600, height=400)",
        "reference_path": "./vis_bench/code/matplotlib/Uncertainties And Trends___scatter_plot_with_loess_lines.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "wrestler",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart",
        "NLQ": "Instead of using the random yield data by variety and site, can you create a bar chart showing the total number of days wrestlers held their titles? I want to group the data by location on the x-axis and stack the bars by event type with different colors. Get the data from the wrestler database instead of generating it randomly. Make sure to sum up the total days held for each location and event combination.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/wrestler.sqlite')\n\nquery = '''\nSELECT Location, Event, SUM(CAST(Days_held AS INT)) AS Total_Days_Held\nFROM wrestler\nGROUP BY Location, Event\nORDER BY Location, Event\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Location:N',\n    y='Total_Days_Held:Q',\n    color='Event:N'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "wrestler",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart",
        "NLQ": "Instead of using the sample data in my code, can you create a bar chart that shows the total number of days wrestlers held their titles? I need to pull this data from my wrestler database, group it by location and event type, and show it as stacked bars. Each location should be on the x-axis, the total days held on the y-axis, and use different colors to represent the different event types.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/wrestler.sqlite')\nquery = '''\nSELECT Location, Event, SUM(CAST(Days_held AS INT)) AS Total_Days_Held\nFROM wrestler\nGROUP BY Location, Event\nORDER BY Location, Event\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Location:N',\n    y='Total_Days_Held:Q',\n    color='Event:N'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "wrestler",
        "chart_category": "Interactive Charts",
        "chart_type": "simple_interactive_colored_scatter_plot",
        "NLQ": "I have a scatter plot showing the relationship between horsepower and miles per gallon for cars from different origins. Can you create a similar visualization but using my wrestling data instead? I want to see the relationship between how many days wrestlers held their titles and their elimination times in seconds. Please color-code the points by team, and make the chart interactive so I can explore the data. Also, make sure to label the axes properly as \"Days Held\" and \"Elimination Time (seconds)\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/wrestler.sqlite')\n\nquery = '''\nSELECT \n    w.Days_held, \n    e.Time, \n    e.Team\nFROM \n    wrestler AS w\nJOIN \n    Elimination AS e\nON \n    w.Wrestler_ID = e.Wrestler_ID\nWHERE \n    w.Days_held != '' AND e.Time != ''\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf['Days_held'] = pd.to_numeric(df['Days_held'], errors='coerce')\ndf['Time'] = df['Time'].apply(lambda x: int(x.split(':')[0]) * 60 + int(x.split(':')[1]))\n\nchart = alt.Chart(df).mark_circle().encode(\n    x=alt.X('Days_held', title='Days Held'),\n    y=alt.Y('Time', title='Elimination Time (seconds)'),\n    color='Team'\n).interactive()\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___simple_interactive_colored_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "wrestler",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "scatter_plot_with_loess_lines",
        "NLQ": "Can you create a graph using my wrestler database that shows the relationship between how many days wrestlers held their titles and how long they lasted before elimination in seconds? I want to see different teams in different colors, and include a smooth trend line running through the points. Please add a clear title that explains what the chart is showing, and make the points slightly transparent so we can see overlapping data better. Label the axes as \"Days Held\" and \"Elimination Time (Seconds)\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/wrestler.sqlite')\n\nquery = '''\nSELECT \n    w.Days_held AS Days_Held,\n    CAST(substr(e.Time, 4, 2) AS INTEGER) * 60 + CAST(substr(e.Time, 7, 2) AS INTEGER) AS Elimination_Time_Seconds,\n    e.Team AS Team\nFROM \n    wrestler AS w\nJOIN \n    Elimination AS e\nON \n    w.Wrestler_ID = e.Wrestler_ID\nWHERE \n    w.Event = 'Live event'\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).mark_circle(opacity=0.5).encode(\n    alt.X('Days_Held:Q', title='Days Held'),\n    alt.Y('Elimination_Time_Seconds:Q', title='Elimination Time (Seconds)'),\n    alt.Color('Team:N', title='Team')\n)\n\nchart = base + base.transform_loess('Days_Held', 'Elimination_Time_Seconds', groupby=['Team']).mark_line(size=4)\n\nchart.properties(\n    title=\"Relationship Between Days Held and Elimination Time by Team\"\n)",
        "reference_path": "./vis_bench/code/altair/Uncertainties And Trends___scatter_plot_with_loess_lines.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "wrestler",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "scatter_plot_with_loess_lines",
        "NLQ": "Instead of using the random data in my example, can you create a similar scatter plot but using my wrestler database? I need to see the relationship between how many days wrestlers held their titles and their elimination times in seconds. Please color-code the points by team and keep those trend lines going through the points. Also, add a clear title that explains what the chart is showing.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/wrestler.sqlite')\n\nquery = '''\nSELECT \n    w.Days_held AS Days_Held,\n    CAST(substr(e.Time, 4, 2) AS INTEGER) * 60 + CAST(substr(e.Time, 7, 2) AS INTEGER) AS Elimination_Time_Seconds,\n    e.Team AS Team\nFROM \n    wrestler AS w\nJOIN \n    Elimination AS e\nON \n    w.Wrestler_ID = e.Wrestler_ID\nWHERE \n    w.Event = 'Live event'\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).mark_circle(opacity=0.5).encode(\n    alt.X('Days_Held:Q', title='Days Held'),\n    alt.Y('Elimination_Time_Seconds:Q', title='Elimination Time (Seconds)'),\n    alt.Color('Team:N', title='Team')\n)\n\nchart = base + base.transform_loess('Days_Held', 'Elimination_Time_Seconds', groupby=['Team']).mark_line(size=4)\n\nchart.properties(\n    title=\"Relationship Between Days Held and Elimination Time by Team\"\n)",
        "reference_path": "./vis_bench/code/matplotlib/Uncertainties And Trends___scatter_plot_with_loess_lines.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "apartment_rentals",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_sorted_segments",
        "NLQ": "I really like this chart showing crop yields by variety and site, but I need to create a similar visualization for my apartment rental data instead. Could you help me create a stacked bar chart that shows the total number of apartments by building type, broken down by the different facility codes they offer? I'd like to keep the same colorful stacked bar approach, with the building types listed on the y-axis and the count of apartments on the x-axis. Also, please add a title that says \"Total Apartments by Building Type and Facilities\" to make it clear what the chart is showing. The data should come from my apartment rentals database instead of the random data in the original chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/apartment_rentals.sqlite')\n\nquery = '''\nSELECT \n    AB.building_description AS building_type,\n    AF.facility_code,\n    COUNT(AF.apt_id) AS apartment_count\nFROM \n    Apartment_Buildings AS AB\nJOIN \n    Apartments AS A ON AB.building_id = A.building_id\nJOIN \n    Apartment_Facilities AS AF ON A.apt_id = AF.apt_id\nGROUP BY \n    AB.building_description, AF.facility_code\nORDER BY \n    AB.building_description, AF.facility_code\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='sum(apartment_count):Q',\n    y='building_type:N',\n    color='facility_code:N',\n    order=alt.Order(\n        'facility_code:N',\n        sort='ascending'\n    )\n).properties(\n    title=\"Total Apartments by Building Type and Facilities\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___stacked_bar_chart_with_sorted_segments.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "apartment_rentals",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_sorted_segments",
        "NLQ": "I have a chart showing crop yields by variety and site, but I'd like to create a new visualization using my apartment rental database instead. Can you make a horizontal stacked bar chart that shows the total number of apartments by building type, with each bar segment colored by the facility code? I want to see how different facilities are distributed across building types. Please use Altair instead of matplotlib and pull the data directly from my SQLite database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/apartment_rentals.sqlite')\n\nquery = '''\nSELECT \n    AB.building_description AS building_type,\n    AF.facility_code,\n    COUNT(AF.apt_id) AS apartment_count\nFROM \n    Apartment_Buildings AS AB\nJOIN \n    Apartments AS A ON AB.building_id = A.building_id\nJOIN \n    Apartment_Facilities AS AF ON A.apt_id = AF.apt_id\nGROUP BY \n    AB.building_description, AF.facility_code\nORDER BY \n    AB.building_description, AF.facility_code\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='sum(apartment_count):Q',\n    y='building_type:N',\n    color='facility_code:N',\n    order=alt.Order(\n        'facility_code:N',\n        sort='ascending'\n    )\n).properties(\n    title=\"Total Apartments by Building Type and Facilities\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___stacked_bar_chart_with_sorted_segments.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "apartment_rentals",
        "chart_category": "Interactive Charts",
        "chart_type": "slider_cutoff",
        "NLQ": "I have a chart showing random points with x and y values, but I need to change it to show apartment data from my database instead. Can you create a chart that shows building descriptions on the x-axis and bedroom counts on the y-axis? I'd like to keep the interactive slider feature, but make it control the bedroom count cutoff from 0 to 6 instead. Also, please use circles instead of points, and add tooltips so I can see the building description and bedroom count when I hover over each circle. The chart should still use red and blue colors to highlight values above and below the cutoff.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/apartment_rentals.sqlite')\nquery = '''\nSELECT\n    AB.building_description,\n    A.bedroom_count\nFROM\n    Apartments AS A\nJOIN\n    Apartment_Buildings AS AB ON A.building_id = AB.building_id\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbedroom_slider = alt.binding_range(min=0, max=6, step=1, name='Bedroom Count Cutoff:')\ncutoff_param = alt.param(bind=bedroom_slider, value=3)\npredicate = alt.datum.bedroom_count > cutoff_param\n\nchart = alt.Chart(df).mark_circle().encode(\n    x='building_description:N',\n    y='bedroom_count:Q',\n    color=alt.condition(\n        predicate,\n        alt.value('red'),\n        alt.value('blue')\n    ),\n    tooltip=['building_description', 'bedroom_count']\n).add_params(\n    cutoff_param\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___slider_cutoff.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "architecture",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_sorted_segments",
        "NLQ": "Can you create a chart showing the total length of bridges built by architects from different countries? I want to see the total bridge length for each nationality, with the bars sorted alphabetically by country. Please use a different color for each nationality and add a title \"Total Length of Bridges by Architect Nationality\" to the chart. I need to pull this data from my architecture database instead of using the sample crop yield data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/architecture.sqlite')\n\nquery = '''\nSELECT \n    a.nationality AS nationality,\n    SUM(b.length_meters) AS total_length_meters\nFROM \n    architect AS a\nJOIN \n    bridge AS b ON a.id = b.architect_id\nGROUP BY \n    a.nationality\nORDER BY \n    a.nationality ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='sum(total_length_meters):Q',\n    y='nationality:N',\n    color='nationality:N',\n    order=alt.Order(\n        'nationality',\n        sort='ascending'\n    )\n).properties(\n    title=\"Total Length of Bridges by Architect Nationality\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___stacked_bar_chart_with_sorted_segments.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "architecture",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_sorted_segments",
        "NLQ": "Can you create a horizontal bar chart showing the total length of bridges built by architects from different countries? I want to see the data pulled from our architecture database instead of using random numbers. Each nationality should be on its own row with a bar showing the total bridge length in meters. Please color-code the bars by nationality and sort them alphabetically by country name. Add a title that says \"Total Length of Bridges by Architect Nationality\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/architecture.sqlite')\n\nquery = '''\nSELECT \n    a.nationality AS nationality,\n    SUM(b.length_meters) AS total_length_meters\nFROM \n    architect AS a\nJOIN \n    bridge AS b ON a.id = b.architect_id\nGROUP BY \n    a.nationality\nORDER BY \n    a.nationality ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='sum(total_length_meters):Q',\n    y='nationality:N',\n    color='nationality:N',\n    order=alt.Order(\n        'nationality',\n        sort='ascending'\n    )\n).properties(\n    title=\"Total Length of Bridges by Architect Nationality\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___stacked_bar_chart_with_sorted_segments.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "architecture",
        "chart_category": "Interactive Charts",
        "chart_type": "using_selection_interval_with_mark_area",
        "NLQ": "Can you change my chart to show data from my architecture database instead of the random data? I want to see how many mills of each type were built each year. Keep the interactive feature where I can select time periods, but make the chart show different types of mills using different colored areas. When I select a time period, I'd like those areas to become more solid and easier to see.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/architecture.sqlite')\n\nquery = '''\nSELECT \n    built_year AS year,\n    type,\n    COUNT(*) AS count\nFROM \n    mill\nGROUP BY \n    built_year, type\nORDER BY \n    built_year ASC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).mark_area(\n    opacity=0.3\n).encode(\n    x='year:O',\n    y='sum(count):Q',\n    color='type:N'\n)\n\nbrush = alt.selection_interval(encodings=['x'])\nbackground = base.add_params(brush)\nselected = base.transform_filter(brush).mark_area(opacity=1)\n\nchart = background + selected\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___using_selection_interval_with_mark_area.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "battle_death",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_text_overlay",
        "NLQ": "Could you make a chart that shows the total number of people killed and injured in each battle, with the battles listed vertically and the numbers stacked on top of each other like in my code? I'd also like the injured numbers to be shown in shades of blue, and the exact numbers for killed should appear on the bars in white text. Please add a title \"Total Killed and Injured in Battles\" and label the x-axis as \"Total Killed and Injured\" and the y-axis as \"Battle Name\". Can you pull this data from the battle_death database instead of using the barley yield data?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/battle_death.sqlite')\n\nquery = '''\nSELECT \n    b.name AS battle_name,\n    SUM(d.killed) AS total_killed,\n    SUM(d.injured) AS total_injured\nFROM \n    battle AS b\nJOIN \n    death AS d ON b.id = d.caused_by_ship_id\nGROUP BY \n    b.name\nORDER BY \n    total_killed DESC, total_injured DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X('total_killed:Q', stack='zero', title='Total Killed and Injured'),\n    y=alt.Y('battle_name:N', title='Battle Name'),\n    color=alt.Color('total_injured:Q', scale=alt.Scale(scheme='blues'), title='Injured')\n)\n\ntext = alt.Chart(df).mark_text(dx=-15, dy=3, color='white').encode(\n    x=alt.X('total_killed:Q', stack='zero'),\n    y=alt.Y('battle_name:N'),\n    detail='total_injured:Q',\n    text=alt.Text('total_killed:Q', format='.0f')\n)\n\n(bars + text).properties(\n    title='Total Killed and Injured in Battles'\n)",
        "reference_path": "./vis_bench/code/altair/Bar Charts___stacked_bar_chart_with_text_overlay.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "battle_death",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_text_overlay",
        "NLQ": "Can you create a horizontal bar chart showing battle data instead of crop varieties? I need to pull data from my battle_death SQLite database, showing the total killed and injured for each battle. Please list the battle names on the y-axis and sort them by the highest number of casualties. Use shades of blue to represent the injury counts, and add white text labels inside the bars showing the exact number of people killed. Also, add a title that says \"Total Killed and Injured in Battles\" at the top.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/battle_death.sqlite')\n\nquery = '''\nSELECT \n    b.name AS battle_name,\n    SUM(d.killed) AS total_killed,\n    SUM(d.injured) AS total_injured\nFROM \n    battle AS b\nJOIN \n    death AS d ON b.id = d.caused_by_ship_id\nGROUP BY \n    b.name\nORDER BY \n    total_killed DESC, total_injured DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X('total_killed:Q', stack='zero', title='Total Killed and Injured'),\n    y=alt.Y('battle_name:N', title='Battle Name'),\n    color=alt.Color('total_injured:Q', scale=alt.Scale(scheme='blues'), title='Injured')\n)\n\ntext = alt.Chart(df).mark_text(dx=-15, dy=3, color='white').encode(\n    x=alt.X('total_killed:Q', stack='zero'),\n    y=alt.Y('battle_name:N'),\n    detail='total_injured:Q',\n    text=alt.Text('total_killed:Q', format='.0f')\n)\n\n(bars + text).properties(\n    title='Total Killed and Injured in Battles'\n)",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___stacked_bar_chart_with_text_overlay.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "behavior_monitoring",
        "chart_category": "Circular Plots",
        "chart_type": "donut_chart",
        "NLQ": "Can you help me create a donut-shaped chart that shows how many times each type of behavior incident has happened? I want to pull the data directly from our behavior monitoring database instead of using the sample data. The chart should show the count of each incident type from the Behavior_Incident table, with different colors for each incident type description.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/behavior_monitoring.sqlite')\n\nquery = '''\nSELECT \n    Ref_Incident_Type.incident_type_description AS incident_type,\n    COUNT(Behavior_Incident.incident_id) AS incident_count\nFROM \n    Behavior_Incident\nJOIN \n    Ref_Incident_Type ON Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code\nGROUP BY \n    Ref_Incident_Type.incident_type_description\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndonut_chart = alt.Chart(df).mark_arc(innerRadius=50).encode(\n    theta=\"incident_count:Q\",\n    color=\"incident_type:N\"\n)\n\ndonut_chart",
        "reference_path": "./vis_bench/code/altair/Circular Plots___donut_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "behavior_monitoring",
        "chart_category": "Circular Plots",
        "chart_type": "donut_chart",
        "NLQ": "Can you help me create a donut-shaped chart that shows how many times each type of behavior incident has happened? Instead of using the sample data in the example, I'd like to pull the real data from our behavior monitoring database. I need it to show the count of each incident type from the Behavior_Incident table, with different colors representing each incident type description. Please use Altair instead of Matplotlib for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/behavior_monitoring.sqlite')\n\nquery = '''\nSELECT \n    Ref_Incident_Type.incident_type_description AS incident_type,\n    COUNT(Behavior_Incident.incident_id) AS incident_count\nFROM \n    Behavior_Incident\nJOIN \n    Ref_Incident_Type ON Behavior_Incident.incident_type_code = Ref_Incident_Type.incident_type_code\nGROUP BY \n    Ref_Incident_Type.incident_type_description\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndonut_chart = alt.Chart(df).mark_arc(innerRadius=50).encode(\n    theta=\"incident_count:Q\",\n    color=\"incident_type:N\"\n)\n\ndonut_chart",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___donut_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "bike_1",
        "chart_category": "Circular Plots",
        "chart_type": "donut_chart",
        "NLQ": "Can you make a donut-shaped chart like the one in my code, but instead of using my sample data, can you pull data from the bike database to show how many trips started in each city? I'd like it to use nice colors for each city and include labels when I hover over the sections.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/bike_1.sqlite')\nquery = '''\nSELECT s.city, COUNT(t.id) AS trip_count\nFROM trip AS t\nJOIN station AS s ON t.start_station_id = s.id\nGROUP BY s.city\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_arc(innerRadius=50).encode(\n    theta=\"trip_count\",\n    color=\"city:N\",\n    tooltip=[\"city\", \"trip_count\"]\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Circular Plots___donut_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "bike_1",
        "chart_category": "Circular Plots",
        "chart_type": "donut_chart",
        "NLQ": "Can you change my pie chart to show bike trip data instead? I'd like to see how many trips started in each city using a donut chart. Please use different colors for each city and add tooltips so I can see the city name and number of trips when I hover over each section. The data should come from my bike database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/bike_1.sqlite')\nquery = '''\nSELECT s.city, COUNT(t.id) AS trip_count\nFROM trip AS t\nJOIN station AS s ON t.start_station_id = s.id\nGROUP BY s.city\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_arc(innerRadius=50).encode(\n    theta=\"trip_count\",\n    color=\"city:N\",\n    tooltip=[\"city\", \"trip_count\"]\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___donut_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "body_builder",
        "chart_category": "Circular Plots",
        "chart_type": "donut_chart",
        "NLQ": "I want to create a donut chart showing the total weight lifted by bodybuilders from different birthplaces. Instead of using the sample data in the example, can you pull the real data from my body_builder database? I need to connect the bodybuilder table with the people table to get their birthplaces, then sum up the total weight lifted for each birthplace. Keep the same donut chart style with the hollow center that's in the example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/body_builder.sqlite')\n\nquery = '''\nSELECT p.Birth_Place AS BirthPlace, SUM(b.Total) AS TotalWeightLifted\nFROM body_builder AS b\nJOIN people AS p ON b.People_ID = p.People_ID\nGROUP BY p.Birth_Place\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_arc(innerRadius=50).encode(\n    theta=\"TotalWeightLifted:Q\",\n    color=\"BirthPlace:N\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Circular Plots___donut_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "body_builder",
        "chart_category": "Circular Plots",
        "chart_type": "donut_chart",
        "NLQ": "Instead of using the sample data in the example, could you create a donut chart that shows the total weight lifted by bodybuilders grouped by their birthplace? I need to pull this data from my body_builder database - specifically combining information from the body_builder and people tables. I'd like each birthplace to have its own color in the chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/body_builder.sqlite')\n\nquery = '''\nSELECT p.Birth_Place AS BirthPlace, SUM(b.Total) AS TotalWeightLifted\nFROM body_builder AS b\nJOIN people AS p ON b.People_ID = p.People_ID\nGROUP BY p.Birth_Place\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_arc(innerRadius=50).encode(\n    theta=\"TotalWeightLifted:Q\",\n    color=\"BirthPlace:N\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___donut_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "book_2",
        "chart_category": "Circular Plots",
        "chart_type": "pacman_chart",
        "NLQ": "Can you make this arc chart look like Pac-Man but color it gold? Also, make the mouth a bit wider than it currently is. I'd like to connect it to my database to count the number of publications too.",
        "code": "import numpy as np\nimport altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/book_2.sqlite')\nquery = \"SELECT COUNT(*) FROM publication\"\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart().mark_arc(color=\"gold\").encode(\n    theta=alt.ThetaDatum((5 / 8) * np.pi).scale(None),\n    theta2=alt.Theta2Datum((19 / 8) * np.pi),\n    radius=alt.RadiusDatum(100).scale(None),\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Circular Plots___pacman_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "city_record",
        "chart_category": "Circular Plots",
        "chart_type": "pie_chart",
        "NLQ": "Can you change this pie chart to show real data instead of the sample numbers? I'd like to see the top 5 cities by GDP from our city database. Each slice should represent a city, with the size of the slice showing its GDP, and each city should have its own color.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/city_record.sqlite')\n\nquery = '''\nSELECT City, GDP\nFROM city\nORDER BY GDP DESC\nLIMIT 5\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_arc().encode(\n    theta=\"GDP\",\n    color=\"City\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Circular Plots___pie_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "city_record",
        "chart_category": "Circular Plots",
        "chart_type": "pie_chart",
        "NLQ": "I have a simple pie chart showing some categories and values, but I'd like to change it to show real data about cities. Can you create a pie chart that shows the top 5 cities by GDP? Instead of using made-up data, please pull the information from my city_record database. Each slice of the pie should represent a city, with the size based on its GDP, and each city should have its own color. Also, I'd prefer to use Altair instead of Matplotlib for creating this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/city_record.sqlite')\nquery = '''\nSELECT City, GDP\nFROM city\nORDER BY GDP DESC\nLIMIT 5\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_arc().encode(\n    theta=\"GDP\",\n    color=\"City\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___pie_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "climbing",
        "chart_category": "Circular Plots",
        "chart_type": "pie_chart_with_labels",
        "NLQ": "Can you create a pie chart showing the total points earned by climbers for each mountain? I need to pull this data from my climbing database. Make the pie chart a bit larger than usual with the mountain names displayed outside the slices in a bigger font. Keep the same style as my example where each slice has a different color.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/climbing.sqlite')\n\nquery = '''\nSELECT \n    m.Name AS Mountain_Name, \n    SUM(c.Points) AS Total_Points\nFROM climber AS c\nJOIN mountain AS m ON c.Mountain_ID = m.Mountain_ID\nGROUP BY m.Name\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"Total_Points:Q\").stack(True),\n    alt.Color(\"Mountain_Name:N\").legend(None)\n)\n\npie = base.mark_arc(outerRadius=120)\ntext = base.mark_text(radius=140, size=20).encode(text=\"Mountain_Name:N\")\n\nchart = pie + text\nchart",
        "reference_path": "./vis_bench/code/altair/Circular Plots___pie_chart_with_labels.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "climbing",
        "chart_category": "Circular Plots",
        "chart_type": "pie_chart_with_labels",
        "NLQ": "Instead of using my sample data, can you create a pie chart that shows mountains and the total points earned by climbers on each mountain? Pull this data from the climbing database. I'd like the mountain names to appear outside the pie slices rather than using a legend, and make sure each mountain has a different color. Also, can you make the chart a bit larger so it's easier to read?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/climbing.sqlite')\n\nquery = '''\nSELECT \n    m.Name AS Mountain_Name, \n    SUM(c.Points) AS Total_Points\nFROM climber AS c\nJOIN mountain AS m ON c.Mountain_ID = m.Mountain_ID\nGROUP BY m.Name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"Total_Points:Q\").stack(True),\n    alt.Color(\"Mountain_Name:N\").legend(None)\n)\n\npie = base.mark_arc(outerRadius=120)\ntext = base.mark_text(radius=140, size=20).encode(text=\"Mountain_Name:N\")\n\nchart = pie + text\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___pie_chart_with_labels.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "club_1",
        "chart_category": "Circular Plots",
        "chart_type": "pie_chart_with_labels",
        "NLQ": "I want to create a pie chart showing the distribution of students by gender. Can you pull this data from the club_1 database instead of using the sample data in my code? Make the pie chart a bit larger and increase the size of the labels so they're easier to read. Keep the same style where the labels are placed outside the pie slices.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/club_1.sqlite')\n\nquery = '''\nSELECT Sex, COUNT(*) AS count\nFROM Student\nGROUP BY Sex;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"count:Q\").stack(True),\n    alt.Color(\"Sex:N\").legend(None)\n)\n\npie = base.mark_arc(outerRadius=120)\ntext = base.mark_text(radius=140, size=20).encode(text=\"Sex:N\")\n\nchart = pie + text\nchart",
        "reference_path": "./vis_bench/code/altair/Circular Plots___pie_chart_with_labels.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "club_1",
        "chart_category": "Circular Plots",
        "chart_type": "pie_chart_with_labels",
        "NLQ": "I want to change my pie chart to show the distribution of students by gender instead of using the category data I have in my code. Can you pull this information directly from the student database and create a pie chart that shows the count of male and female students? Make sure to include labels for each gender directly on the chart without a separate legend.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/club_1.sqlite')\nquery = '''\nSELECT Sex, COUNT(*) AS count\nFROM Student\nGROUP BY Sex;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"count:Q\").stack(True),\n    alt.Color(\"Sex:N\").legend(None)\n)\npie = base.mark_arc(outerRadius=120)\ntext = base.mark_text(radius=140, size=20).encode(text=\"Sex:N\")\nchart = pie + text\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___pie_chart_with_labels.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "coffee_shop",
        "chart_category": "Circular Plots",
        "chart_type": "pie_chart_with_labels",
        "NLQ": "Could you show me a colorful pie chart, similar to what my code creates, but this time breaking down the number of customers by their membership card types from our coffee shop database? I'd like the labels for each slice to be clear and placed neatly around the chart, a bit further out from the pie itself, and make them larger so they're easier to read. Also, can you make the pie chart a bit bigger overall?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/coffee_shop.sqlite')\n\nquery = '''\nSELECT Membership_card, COUNT(*) AS count\nFROM member\nGROUP BY Membership_card;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"count:Q\").stack(True),\n    alt.Color(\"Membership_card:N\").legend(None)\n)\n\npie = base.mark_arc(outerRadius=120)\ntext = base.mark_text(radius=140, size=20).encode(text=\"Membership_card:N\")\n\nchart = pie + text\n\nchart",
        "reference_path": "./vis_bench/code/altair/Circular Plots___pie_chart_with_labels.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "coffee_shop",
        "chart_category": "Circular Plots",
        "chart_type": "pie_chart_with_labels",
        "NLQ": "Could you show me a colorful pie chart, similar to what my code creates, but this time breaking down the number of customers by their membership card types? I'd like the labels for each slice to be clear and placed neatly around the chart. Instead of using my sample data, please pull the actual membership data from our coffee shop database. Also, can you use Altair instead of Matplotlib for this visualization?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/coffee_shop.sqlite')\n\nquery = '''\nSELECT Membership_card, COUNT(*) AS count\nFROM member\nGROUP BY Membership_card;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"count:Q\").stack(True),\n    alt.Color(\"Membership_card:N\").legend(None)\n)\n\npie = base.mark_arc(outerRadius=120)\ntext = base.mark_text(radius=140, size=20).encode(text=\"Membership_card:N\")\n\nchart = pie + text\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___pie_chart_with_labels.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "college_3",
        "chart_category": "Circular Plots",
        "chart_type": "polar_bar_chart",
        "NLQ": "Can you create a circular chart that shows the number of courses offered by each department from our college database? I'd like the departments to be spread evenly around the circle, with the length of each section showing how many courses that department offers. Please add a title \"Number of Courses Offered by Each Department\" at the top. Color-code the sections based on the course count, but don't include a color legend. Make sure to label each department around the outside of the circle, and add some light grey rings with numbers to show the course count scale. Also, I'd like white borders between the colored sections to make them stand out better.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\nimport math\nconn = sqlite3.connect('database\\college_3.sqlite')\nquery = \"\"\"\nSELECT D.DName, COUNT(C.CID) AS CourseCount\nFROM Department AS D\nLEFT JOIN Course AS C ON D.DNO = C.DNO\nGROUP BY D.DName;\n\"\"\"\ndf = pd.read_sql_query(query, conn)\nconn.close()\nnum_departments = len(df)\ndf['angle'] = (2 * math.pi / num_departments) * df.index\npolar_bars = alt.Chart(df).mark_arc(stroke='white', tooltip=True).encode(\n    theta=alt.Theta(\"angle:Q\", scale=alt.Scale(domain=[0, 2 * math.pi])),\n    radius=alt.Radius('CourseCount:Q').scale(type='linear'),\n    color=alt.Color('CourseCount:Q', legend=None),\n    radius2=alt.datum(1)\n)\nmax_count = df['CourseCount'].max()\naxis_rings = alt.Chart(pd.DataFrame({\"ring\": range(0, int(max_count) + 2, 2)})).mark_arc(stroke='lightgrey', fill=None).encode(\n    theta=alt.value(2 * math.pi),\n    radius=alt.Radius('ring:Q').stack(False)\n)\naxis_rings_labels = axis_rings.mark_text(color='grey', radiusOffset=5, align='left').encode(\n    text=\"ring:Q\",\n    theta=alt.value(math.pi / 4)\n)\naxis_lines_data = []\nfor i in range(num_departments):\n  angle = (2*math.pi/num_departments) * i\n  axis_lines_data.append({'radius':max_count+2, 'theta': angle, 'DName':df['DName'][i]})\naxis_lines_df = pd.DataFrame(axis_lines_data)\naxis_lines = alt.Chart(axis_lines_df).mark_arc(stroke='lightgrey', fill=None).encode(\n  theta=alt.Theta('theta:Q').stack(True),\n    radius=alt.Radius('radius:Q'),\n    radius2=alt.datum(1)\n)\naxis_lines_labels = axis_lines.mark_text(\n    color='grey',\n    radiusOffset=10,\n).encode(\n    text=\"DName:N\",\n    theta=alt.Theta('theta:Q')\n)\nchart = alt.layer(\n    axis_rings,\n    polar_bars,\n    axis_rings_labels,\n    axis_lines,\n    axis_lines_labels\n).properties(\n    title='Number of Courses Offered by Each Department'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Circular Plots___polar_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "college_3",
        "chart_category": "Circular Plots",
        "chart_type": "polar_bar_chart",
        "NLQ": "Can you create a circular chart showing how many courses each department offers from our college database? I'd like to see the departments arranged around the circle with bars extending outward based on their course count. Please use a color gradient for the bars and include department names as labels around the edge. Also, add some light grey rings as guidelines with numbers showing the course count scale. Make sure to give it a clear title like \"Number of Courses Offered by Each Department\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\nimport math\n\nconn = sqlite3.connect('database\\college_3.sqlite')\nquery = \"\"\"\nSELECT D.DName, COUNT(C.CID) AS CourseCount\nFROM Department AS D\nLEFT JOIN Course AS C ON D.DNO = C.DNO\nGROUP BY D.DName;\n\"\"\"\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nnum_departments = len(df)\ndf['angle'] = (2 * math.pi / num_departments) * df.index\n\npolar_bars = alt.Chart(df).mark_arc(stroke='white', tooltip=True).encode(\n    theta=alt.Theta(\"angle:Q\", scale=alt.Scale(domain=[0, 2 * math.pi])),\n    radius=alt.Radius('CourseCount:Q').scale(type='linear'),\n    color=alt.Color('CourseCount:Q', legend=None),\n    radius2=alt.datum(1)\n)\n\nmax_count = df['CourseCount'].max()\naxis_rings = alt.Chart(pd.DataFrame({\"ring\": range(0, int(max_count) + 2, 2)})).mark_arc(stroke='lightgrey', fill=None).encode(\n    theta=alt.value(2 * math.pi),\n    radius=alt.Radius('ring:Q').stack(False)\n)\naxis_rings_labels = axis_rings.mark_text(color='grey', radiusOffset=5, align='left').encode(\n    text=\"ring:Q\",\n    theta=alt.value(math.pi / 4)\n)\n\naxis_lines_data = []\nfor i in range(num_departments):\n  angle = (2*math.pi/num_departments) * i\n  axis_lines_data.append({'radius':max_count+2, 'theta': angle, 'DName':df['DName'][i]})\naxis_lines_df = pd.DataFrame(axis_lines_data)\n\naxis_lines = alt.Chart(axis_lines_df).mark_arc(stroke='lightgrey', fill=None).encode(\n  theta=alt.Theta('theta:Q').stack(True),\n    radius=alt.Radius('radius:Q'),\n    radius2=alt.datum(1)\n)\n\naxis_lines_labels = axis_lines.mark_text(\n    color='grey',\n    radiusOffset=10,\n).encode(\n    text=\"DName:N\",\n    theta=alt.Theta('theta:Q')\n)\n\nchart = alt.layer(\n    axis_rings,\n    polar_bars,\n    axis_rings_labels,\n    axis_lines,\n    axis_lines_labels\n).properties(\n    title='Number of Courses Offered by Each Department'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___polar_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "college_3",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_custom_order",
        "NLQ": "Instead of showing gas mileage data, can you create a chart that shows the average grade points for each course in the computer science department? I need to pull this data from my college database. I want a line chart with points that connects all the courses, with Course IDs on the x-axis and Average Grade Points on the y-axis. Please add proper titles to the axes and give the chart a title like \"Trend of Average Grade Points by Course in Computer Science Department\". Also, make it so when I hover over a point, I can see the Course ID, Course Name, and the exact Grade Point value.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/college_3.sqlite')\n\nquery = '''\nSELECT \n    Course.CID AS CourseID,\n    Course.CName AS CourseName,\n    Enrolled_in.Grade,\n    Gradeconversion.gradepoint AS GradePoint\nFROM \n    Enrolled_in\nJOIN \n    Course ON Enrolled_in.CID = Course.CID\nJOIN \n    Gradeconversion ON Enrolled_in.Grade = Gradeconversion.lettergrade\nWHERE \n    Course.DNO = 600\nORDER BY \n    Course.CID;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ngrouped_df = df.groupby(['CourseID', 'CourseName'], as_index=False).agg({'GradePoint': 'mean'})\n\nchart = alt.Chart(grouped_df).mark_line(point=True).encode(\n    x=alt.X(\"CourseID:N\").title(\"Course ID\"),\n    y=alt.Y(\"GradePoint:Q\").title(\"Average Grade Points\"),\n    order=\"CourseID\",\n    tooltip=[\"CourseID\", \"CourseName\", \"GradePoint\"]\n).properties(\n    title=\"Trend of Average Grade Points by Course in Computer Science Department\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_custom_order.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "college_3",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_custom_order",
        "NLQ": "Instead of plotting gas consumption against miles driven, I'd like to create a chart showing average grade points for computer science courses. Can you pull this data from the college database, specifically from department 600? I want a line chart with points that shows the trend of grade points across different courses, with Course IDs on the x-axis. Please add a clear title like \"Trend of Average Grade Points by Course in Computer Science Department\" and make it so when I hover over each point, I can see the course ID, course name, and the exact grade point average. Also, make sure the courses are displayed in the correct order.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/college_3.sqlite')\n\nquery = '''\nSELECT \n    Course.CID AS CourseID,\n    Course.CName AS CourseName,\n    Enrolled_in.Grade,\n    Gradeconversion.gradepoint AS GradePoint\nFROM \n    Enrolled_in\nJOIN \n    Course ON Enrolled_in.CID = Course.CID\nJOIN \n    Gradeconversion ON Enrolled_in.Grade = Gradeconversion.lettergrade\nWHERE \n    Course.DNO = 600\nORDER BY \n    Course.CID;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\ngrouped_df = df.groupby(['CourseID', 'CourseName'], as_index=False).agg({'GradePoint': 'mean'})\n\nchart = alt.Chart(grouped_df).mark_line(point=True).encode(\n    x=alt.X(\"CourseID:N\").title(\"Course ID\"),\n    y=alt.Y(\"GradePoint:Q\").title(\"Average Grade Points\"),\n    order=\"CourseID\",\n    tooltip=[\"CourseID\", \"CourseName\", \"GradePoint\"]\n).properties(\n    title=\"Trend of Average Grade Points by Course in Computer Science Department\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_custom_order.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "company_1",
        "chart_category": "Circular Plots",
        "chart_type": "radial_chart",
        "NLQ": "I'd like to create a chart that shows how many employees work in each department, with the departments displayed in different colors around a circular layout. Instead of using the sample data in the code, could you pull the actual employee counts from our company database? I want to connect to the company_1 database and count employees grouped by department name. Also, add white borders between the sections to make them stand out better. The numbers should still be shown clearly and the design should look clean and professional.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_1.sqlite')\n\nquery = '''\nSELECT D.Dname, COUNT(E.Ssn) AS EmployeeCount\nFROM employee AS E\nJOIN department AS D ON E.Dno = D.Dnumber\nGROUP BY D.Dname;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"EmployeeCount:Q\").stack(True),\n    alt.Radius(\"EmployeeCount\").scale(type=\"sqrt\", zero=True, rangeMin=20),\n    color=\"Dname:N\",\n)\n\nc1 = base.mark_arc(innerRadius=20, stroke=\"#fff\")\nc2 = base.mark_text(radiusOffset=10).encode(text=\"EmployeeCount:Q\")\n\nchart = c1 + c2\n\nchart",
        "reference_path": "./vis_bench/code/altair/Circular Plots___radial_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "company_1",
        "chart_category": "Circular Plots",
        "chart_type": "radial_chart",
        "NLQ": "Can you create a radial pie chart showing the number of employees in each department? I'd like the size of each pie slice to represent the employee count, with different colors for each department. Please display the actual employee count as text on each slice. Make the chart have a hollow center like a donut chart, with white borders between the slices for better visibility.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_1.sqlite')\n\nquery = '''\nSELECT D.Dname, COUNT(E.Ssn) AS EmployeeCount\nFROM employee AS E\nJOIN department AS D ON E.Dno = D.Dnumber\nGROUP BY D.Dname;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"EmployeeCount:Q\").stack(True),\n    alt.Radius(\"EmployeeCount\").scale(type=\"sqrt\", zero=True, rangeMin=20),\n    color=\"Dname:N\",\n)\n\nc1 = base.mark_arc(innerRadius=20, stroke=\"#fff\")\nc2 = base.mark_text(radiusOffset=10).encode(text=\"EmployeeCount:Q\")\n\nchart = c1 + c2\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___radial_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "company_office",
        "chart_category": "Circular Plots",
        "chart_type": "radial_chart",
        "NLQ": "I want to create a radial chart that shows how many companies moved into buildings in different cities over the years. Can you use our company database to get this information? I'd like to see each city in a different color, with the number of companies displayed on each segment. Please add tooltips so when I hover over a segment I can see the city, year, and number of companies. Also, add a title at the top that says \"Companies Moving Into Buildings by City and Year\" and make the segments have white borders between them.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_office.sqlite')\n\nquery = '''\nSELECT \n    b.City AS city,\n    o.move_in_year AS year,\n    COUNT(o.company_id) AS company_count\nFROM \n    Office_locations AS o\nJOIN \n    buildings AS b ON o.building_id = b.id\nGROUP BY \n    b.City, o.move_in_year\nORDER BY \n    b.City, o.move_in_year;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"company_count:Q\").stack(True),\n    alt.Radius(\"company_count\").scale(type=\"sqrt\", zero=True, rangeMin=20),\n    color=\"city:N\",\n    tooltip=[\"city:N\", \"year:Q\", \"company_count:Q\"]\n)\n\nc1 = base.mark_arc(innerRadius=20, stroke=\"#fff\")\nc2 = base.mark_text(radiusOffset=10).encode(text=\"company_count:Q\")\nchart = c1 + c2\n\nchart.properties(title=\"Companies Moving Into Buildings by City and Year\")",
        "reference_path": "./vis_bench/code/altair/Circular Plots___radial_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "company_office",
        "chart_category": "Circular Plots",
        "chart_type": "radial_chart",
        "NLQ": "Can you create a radial chart showing the number of companies that moved into buildings across different cities over the years? I'd like a circular visualization where the segments are colored by city, with the size of each segment representing the company count. Please display the actual count numbers on the chart itself and include tooltips that show the city name, year, and company count when hovering. Title the chart \"Companies Moving Into Buildings by City and Year\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_office.sqlite')\n\nquery = '''\nSELECT \n    b.City AS city,\n    o.move_in_year AS year,\n    COUNT(o.company_id) AS company_count\nFROM \n    Office_locations AS o\nJOIN \n    buildings AS b ON o.building_id = b.id\nGROUP BY \n    b.City, o.move_in_year\nORDER BY \n    b.City, o.move_in_year;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.Theta(\"company_count:Q\").stack(True),\n    alt.Radius(\"company_count\").scale(type=\"sqrt\", zero=True, rangeMin=20),\n    color=\"city:N\",\n    tooltip=[\"city:N\", \"year:Q\", \"company_count:Q\"]\n)\n\nc1 = base.mark_arc(innerRadius=20, stroke=\"#fff\")\nc2 = base.mark_text(radiusOffset=10).encode(text=\"company_count:Q\")\nchart = c1 + c2\n\nchart.properties(title=\"Companies Moving Into Buildings by City and Year\")",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___radial_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "county_public_safety",
        "chart_category": "Distributions",
        "chart_type": "2d_histogram_heatmap",
        "NLQ": "Can you change this chart to show the relationship between crime rates and the number of residents per police officer using data from the county public safety database? Keep the same heatmap style, but use shades of green and blue instead of the default colors to highlight areas with higher concentrations of data points.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/county_public_safety.sqlite')\n\nquery = '''\nSELECT Crime_rate, Residents_per_officer\nFROM county_public_safety\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_rect().encode(\n    alt.X('Crime_rate:Q').bin(maxbins=60),\n    alt.Y('Residents_per_officer:Q').bin(maxbins=40),\n    alt.Color('count():Q').scale(scheme='greenblue')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___2d_histogram_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "county_public_safety",
        "chart_category": "Distributions",
        "chart_type": "2d_histogram_heatmap",
        "NLQ": "Can you change this visualization to show the relationship between crime rates and the number of residents per police officer using data from the county public safety database? Instead of the current color scheme, I'd like to use shades of green and blue to highlight areas with higher concentrations of data points. Also, can you switch from matplotlib to Altair for creating the heatmap?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/county_public_safety.sqlite')\n\nquery = '''\nSELECT Crime_rate, Residents_per_officer\nFROM county_public_safety\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_rect().encode(\n    alt.X('Crime_rate:Q').bin(maxbins=60),\n    alt.Y('Residents_per_officer:Q').bin(maxbins=40),\n    alt.Color('count():Q').scale(scheme='greenblue')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___2d_histogram_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "cre_Doc_Tracking_DB",
        "chart_category": "Distributions",
        "chart_type": "boxplot_with_minmax_whiskers",
        "NLQ": "I want to create a boxplot chart that shows how long different types of documents stay in storage. Instead of using random data like in my example, can you pull the real data from our SQLite database? I need to compare document types on the x-axis and show their storage durations in days on the y-axis. Make sure to label the axes properly with \"Document Type\" and \"Storage Duration (Days)\" so it's clear what we're looking at.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/cre_Doc_Tracking_DB.sqlite')\nquery = '''\nSELECT \n    T1.Document_Type_Name,\n    (julianday(T2.Date_Stored) - julianday(T3.Date_in_Location_From)) AS Storage_Duration\nFROM \n    Ref_Document_Types AS T1\nJOIN \n    All_Documents AS T2 ON T1.Document_Type_Code = T2.Document_Type_Code\nJOIN \n    Document_Locations AS T3 ON T2.Document_ID = T3.Document_ID\nWHERE \n    T3.Date_in_Location_From IS NOT NULL AND T2.Date_Stored IS NOT NULL\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\nchart = alt.Chart(df).mark_boxplot(extent='min-max').encode(\n    x=alt.X('Document_Type_Name:N', title='Document Type'),\n    y=alt.Y('Storage_Duration:Q', title='Storage Duration (Days)')\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___boxplot_with_minmax_whiskers.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "cre_Doc_Tracking_DB",
        "chart_category": "Distributions",
        "chart_type": "boxplot_with_minmax_whiskers",
        "NLQ": "Instead of using the age and people data with the boxplot I had before, can you create a similar boxplot that shows how long different types of documents stay in storage? I need to pull this information from my SQLite database called 'cre_Doc_Tracking_DB.sqlite'. The chart should show document types on the x-axis and storage duration in days on the y-axis. Make sure to label the axes properly.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/cre_Doc_Tracking_DB.sqlite')\n\nquery = '''\nSELECT \n    T1.Document_Type_Name,\n    (julianday(T2.Date_Stored) - julianday(T3.Date_in_Location_From)) AS Storage_Duration\nFROM \n    Ref_Document_Types AS T1\nJOIN \n    All_Documents AS T2 ON T1.Document_Type_Code = T2.Document_Type_Code\nJOIN \n    Document_Locations AS T3 ON T2.Document_ID = T3.Document_ID\nWHERE \n    T3.Date_in_Location_From IS NOT NULL AND T2.Date_Stored IS NOT NULL\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_boxplot(extent='min-max').encode(\n    x=alt.X('Document_Type_Name:N', title='Document Type'),\n    y=alt.Y('Storage_Duration:Q', title='Storage Duration (Days)')\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___boxplot_with_minmax_whiskers.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "customers_campaigns_ecommerce",
        "chart_category": "Distributions",
        "chart_type": "distributions_and_medians_of_likert_scale_ratings",
        "NLQ": "Can you create a chart showing the distribution of order quantities for each product category from our e-commerce database? I'd like to use blue bubbles where the size represents the number of orders, with a black tick mark showing the median quantity for each category. Add \"Low Quantity\" and \"High Quantity\" labels on the sides, and give it a title \"Distribution of Item Order Quantities by Product Category\". Make it clean with minimal gridlines, bold category labels, and include tooltips that show the number of orders when hovering over the bubbles.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/customers_campaigns_ecommerce.sqlite')\n\nquery = '''\nSELECT p.product_category, CAST(oi.item_order_quantity AS INTEGER) AS item_order_quantity\nFROM Order_Items AS oi\nJOIN Products AS p ON oi.product_id = p.product_id\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nmedians_df = df.groupby('product_category')['item_order_quantity'].median().reset_index()\nmedians_df.columns = ['product_category', 'median_quantity']\nmedians_df['lo'] = 'Low Quantity'\nmedians_df['hi'] = 'High Quantity'\n\ny_axis = alt.Y(\"product_category\").axis(\n    title=\"Product Category\",\n    offset=50,\n    labelFontWeight=\"bold\",\n    ticks=False,\n    grid=True,\n    domain=False,\n)\n\nbase = alt.Chart(\n    medians_df,\n).encode(y_axis)\n\nbubbles = (\n    alt.Chart(df)\n    .mark_circle(color=\"#6EB4FD\")\n    .encode(\n        alt.X(\n            \"item_order_quantity:Q\",\n        ).title(\"Item Order Quantity\"),\n        y_axis,\n        alt.Size(\"count()\").legend(offset=75, title=\"Number of Orders\"),\n        tooltip=[alt.Tooltip(\"count()\").title(\"Number of Orders\")],\n    )\n)\n\nticks = base.mark_tick(color=\"black\").encode(\n    alt.X(\"median_quantity:Q\")\n    .axis(grid=False)\n)\n\ntexts_lo = base.mark_text(align=\"right\", x=-5).encode(text=\"lo\")\ntexts_hi = base.mark_text(align=\"left\", x=255).encode(text=\"hi\")\n\nchart = (bubbles + ticks + texts_lo + texts_hi).properties(\n    title=\"Distribution of Item Order Quantities by Product Category\", width=300, height=200\n).configure_view(stroke=None)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___distributions_and_medians_of_likert_scale_ratings.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "customers_campaigns_ecommerce",
        "chart_category": "Distributions",
        "chart_type": "distributions_and_medians_of_likert_scale_ratings",
        "NLQ": "Can you create a chart showing the distribution of order quantities for each product category from our e-commerce database? I'd like to see blue bubbles where the size represents the number of orders, with a black mark showing the median value for each category. Please add \"Low Quantity\" and \"High Quantity\" labels on the sides, and give it a title \"Distribution of Item Order Quantities by Product Category\". Make it clean and simple with a width of 300 and height of 200.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/customers_campaigns_ecommerce.sqlite')\n\nquery = '''\nSELECT p.product_category, CAST(oi.item_order_quantity AS INTEGER) AS item_order_quantity\nFROM Order_Items AS oi\nJOIN Products AS p ON oi.product_id = p.product_id\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nmedians_df = df.groupby('product_category')['item_order_quantity'].median().reset_index()\nmedians_df.columns = ['product_category', 'median_quantity']\nmedians_df['lo'] = 'Low Quantity'\nmedians_df['hi'] = 'High Quantity'\n\ny_axis = alt.Y(\"product_category\").axis(\n    title=\"Product Category\",\n    offset=50,\n    labelFontWeight=\"bold\",\n    ticks=False,\n    grid=True,\n    domain=False,\n)\n\nbase = alt.Chart(\n    medians_df,\n).encode(y_axis)\n\nbubbles = (\n    alt.Chart(df)\n    .mark_circle(color=\"#6EB4FD\")\n    .encode(\n        alt.X(\n            \"item_order_quantity:Q\",\n        ).title(\"Item Order Quantity\"),\n        y_axis,\n        alt.Size(\"count()\").legend(offset=75, title=\"Number of Orders\"),\n        tooltip=[alt.Tooltip(\"count()\").title(\"Number of Orders\")],\n    )\n)\n\nticks = base.mark_tick(color=\"black\").encode(\n    alt.X(\"median_quantity:Q\")\n    .axis(grid=False)\n)\n\ntexts_lo = base.mark_text(align=\"right\", x=-5).encode(text=\"lo\")\n\ntexts_hi = base.mark_text(align=\"left\", x=255).encode(text=\"hi\")\n\nchart = (bubbles + ticks + texts_lo + texts_hi).properties(\n    title=\"Distribution of Item Order Quantities by Product Category\", width=300, height=200\n).configure_view(stroke=None)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___distributions_and_medians_of_likert_scale_ratings.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "customers_card_transactions",
        "chart_category": "Distributions",
        "chart_type": "distributions_and_medians_of_likert_scale_ratings",
        "NLQ": "Can you create a chart showing customer ratings for payment and refund transactions from our database? I'd like to use the same bubble chart style as my example, but make it more focused on customer satisfaction. Use blue bubbles instead of the default color, add a proper title \"Customer Ratings for Transaction Types\", and make it more compact (about 250x175). Keep the rating scale from 1-5 with labels \"Very Dissatisfied\" to \"Very Satisfied\" on the sides. Also, add a tooltip that shows how many ratings each bubble represents and include a legend for the bubble sizes titled \"Number of ratings\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customers_card_transactions.sqlite')\n\nquery = '''\nSELECT \n    T1.transaction_type AS transaction_type,\n    CASE \n        WHEN T1.transaction_amount > 1000 THEN 5\n        WHEN T1.transaction_amount BETWEEN 500 AND 1000 THEN 4\n        WHEN T1.transaction_amount BETWEEN 200 AND 499 THEN 3\n        WHEN T1.transaction_amount BETWEEN 100 AND 199 THEN 2\n        ELSE 1\n    END AS rating\nFROM Financial_Transactions AS T1\nWHERE T1.transaction_type IN ('Payment', 'Refund')\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nmedians = df.groupby('transaction_type')['rating'].median().reset_index()\nmedians.columns = ['name', 'median']\nmedians['lo'] = 'Very Dissatisfied'\nmedians['hi'] = 'Very Satisfied'\n\nvalues = df.rename(columns={'transaction_type': 'name', 'rating': 'value'})\n\ny_axis = alt.Y(\"name\").axis(\n    title=None,\n    offset=50,\n    labelFontWeight=\"bold\",\n    ticks=False,\n    grid=True,\n    domain=False,\n)\n\nbase = alt.Chart(medians).encode(y_axis)\n\nbubbles = (\n    alt.Chart(values)\n    .mark_circle(color=\"#6EB4FD\")\n    .encode(\n        alt.X(\"value:Q\").title(None),\n        y_axis,\n        alt.Size(\"count()\").legend(offset=75, title=\"Number of ratings\"),\n        tooltip=[alt.Tooltip(\"count()\").title(\"Number of ratings\")],\n    )\n)\n\nticks = base.mark_tick(color=\"black\").encode(\n    alt.X(\"median:Q\")\n    .axis(grid=False, values=[1, 2, 3, 4, 5], format=\".0f\")\n    .scale(domain=[0, 6]),\n)\n\ntexts_lo = base.mark_text(align=\"right\", x=-5).encode(text=\"lo\")\ntexts_hi = base.mark_text(align=\"left\", x=255).encode(text=\"hi\")\n\n(bubbles + ticks + texts_lo + texts_hi).properties(\n    title=\"Customer Ratings for Transaction Types\", width=250, height=175\n).configure_view(stroke=None)",
        "reference_path": "./vis_bench/code/altair/Distributions___distributions_and_medians_of_likert_scale_ratings.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "customers_card_transactions",
        "chart_category": "Distributions",
        "chart_type": "distributions_and_medians_of_likert_scale_ratings",
        "NLQ": "Can you create a chart showing customer ratings for payment and refund transactions from our database? I'd like to use the same bubble chart style as my previous visualization, where the size of each bubble shows how many ratings there are. Please add a title \"Customer Ratings for Transaction Types\" and change the labels on the sides to \"Very Dissatisfied\" and \"Very Satisfied\" instead of \"Easy\" and \"Hard\". Also, can you add a tooltip that shows the number of ratings when hovering over a bubble and include a legend explaining what the bubble sizes mean?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customers_card_transactions.sqlite')\n\nquery = '''\nSELECT \n    T1.transaction_type AS transaction_type,\n    CASE \n        WHEN T1.transaction_amount > 1000 THEN 5\n        WHEN T1.transaction_amount BETWEEN 500 AND 1000 THEN 4\n        WHEN T1.transaction_amount BETWEEN 200 AND 499 THEN 3\n        WHEN T1.transaction_amount BETWEEN 100 AND 199 THEN 2\n        ELSE 1\n    END AS rating\nFROM Financial_Transactions AS T1\nWHERE T1.transaction_type IN ('Payment', 'Refund')\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nmedians = df.groupby('transaction_type')['rating'].median().reset_index()\nmedians.columns = ['name', 'median']\nmedians['lo'] = 'Very Dissatisfied'\nmedians['hi'] = 'Very Satisfied'\n\nvalues = df.rename(columns={'transaction_type': 'name', 'rating': 'value'})\n\ny_axis = alt.Y(\"name\").axis(\n    title=None,\n    offset=50,\n    labelFontWeight=\"bold\",\n    ticks=False,\n    grid=True,\n    domain=False,\n)\n\nbase = alt.Chart(medians).encode(y_axis)\n\nbubbles = (\n    alt.Chart(values)\n    .mark_circle(color=\"#6EB4FD\")\n    .encode(\n        alt.X(\"value:Q\").title(None),\n        y_axis,\n        alt.Size(\"count()\").legend(offset=75, title=\"Number of ratings\"),\n        tooltip=[alt.Tooltip(\"count()\").title(\"Number of ratings\")],\n    )\n)\n\nticks = base.mark_tick(color=\"black\").encode(\n    alt.X(\"median:Q\")\n    .axis(grid=False, values=[1, 2, 3, 4, 5], format=\".0f\")\n    .scale(domain=[0, 6]),\n)\n\ntexts_lo = base.mark_text(align=\"right\", x=-5).encode(text=\"lo\")\ntexts_hi = base.mark_text(align=\"left\", x=255).encode(text=\"hi\")\n\n(bubbles + ticks + texts_lo + texts_hi).properties(\n    title=\"Customer Ratings for Transaction Types\", width=250, height=175\n).configure_view(stroke=None)",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___distributions_and_medians_of_likert_scale_ratings.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "hr_1",
        "chart_category": "Distributions",
        "chart_type": "repeated_density_estimates",
        "NLQ": "Instead of showing flower measurements like in the example, can you create a chart that shows how salaries are distributed across different job titles? I'd like to pull this data from our HR database. Each job title should have its own row in the visualization with smooth density curves showing the salary patterns. Make sure to label the x-axis as \"Salary\" and set the range to go up to about $25,000. Keep the chart width around 300 pixels with a height of 50 pixels for each job title section.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/hr_1.sqlite')\n\nquery = '''\nSELECT e.SALARY, j.JOB_TITLE\nFROM employees AS e\nJOIN jobs AS j ON e.JOB_ID = j.JOB_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).transform_fold(\n    ['SALARY'],\n    as_=['Measurement_type', 'value']\n).transform_density(\n    density='value',\n    bandwidth=500,\n    groupby=['JOB_TITLE'],\n    extent=[0, 25000]\n).mark_area().encode(\n    alt.X(\"value:Q\", title=\"Salary\"),\n    alt.Y(\"density:Q\", title=\"Density\"),\n    alt.Row(\"JOB_TITLE:N\", title=\"Job Title\")\n).properties(\n    width=300, height=50\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___repeated_density_estimates.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "hr_1",
        "chart_category": "Distributions",
        "chart_type": "repeated_density_estimates",
        "NLQ": "Instead of showing flower measurements like petal width and length, can you create a chart that shows how salaries are distributed across different job titles? I'd like to pull this data from our HR database rather than using random numbers. Each job title should have its own row in the visualization with smooth density curves showing the salary patterns. Make sure to label the x-axis as \"Salary\" and set the range from 0 to 25,000. Can you make the chart about 300 pixels wide with each row being 50 pixels tall?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/hr_1.sqlite')\n\nquery = '''\nSELECT e.SALARY, j.JOB_TITLE\nFROM employees AS e\nJOIN jobs AS j ON e.JOB_ID = j.JOB_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).transform_fold(\n    ['SALARY'],\n    as_=['Measurement_type', 'value']\n).transform_density(\n    density='value',\n    bandwidth=500,\n    groupby=['JOB_TITLE'],\n    extent=[0, 25000]\n).mark_area().encode(\n    alt.X(\"value:Q\", title=\"Salary\"),\n    alt.Y(\"density:Q\", title=\"Density\"),\n    alt.Row(\"JOB_TITLE:N\", title=\"Job Title\")\n).properties(\n    width=300, height=50\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___repeated_density_estimates.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "hr_1",
        "chart_category": "Scatter Plots",
        "chart_type": "brushing_scatter_plot_to_show_data_on_a_table",
        "NLQ": "Can you change the chart to show employee data from our HR database instead of car information? I want to see salary on the x-axis and commission percentage on the y-axis, with employee details showing up in a table on the right when I select points. The table should display their first name, last name, job title, and department. Make sure the axis titles are clear and add headings above each column in the table.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/hr_1.sqlite')\n\nquery = '''\nSELECT \n    e.FIRST_NAME,\n    e.LAST_NAME,\n    e.SALARY,\n    e.COMMISSION_PCT,\n    j.JOB_TITLE,\n    d.DEPARTMENT_NAME\nFROM \n    employees AS e\nJOIN \n    jobs AS j ON e.JOB_ID = j.JOB_ID\nJOIN \n    departments AS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(df).mark_point().encode(\n    x=alt.X('SALARY:Q', title='Salary'),\n    y=alt.Y('COMMISSION_PCT:Q', title='Commission Percentage'),\n    color=alt.condition(brush, alt.value(\"steelblue\"), alt.value(\"grey\"))\n).add_params(brush)\n\nranked_text = alt.Chart(df).mark_text(align='right').encode(\n    y=alt.Y('row_number:O').axis(None)\n).transform_filter(\n    brush\n).transform_window(\n    row_number='row_number()'\n).transform_filter(\n    alt.datum.row_number < 15\n)\n\nfirst_name = ranked_text.encode(text='FIRST_NAME:N').properties(\n    title=alt.Title(text='First Name', align='right')\n)\nlast_name = ranked_text.encode(text='LAST_NAME:N').properties(\n    title=alt.Title(text='Last Name', align='right')\n)\njob_title = ranked_text.encode(text='JOB_TITLE:N').properties(\n    title=alt.Title(text='Job Title', align='right')\n)\ndepartment_name = ranked_text.encode(text='DEPARTMENT_NAME:N').properties(\n    title=alt.Title(text='Department', align='right')\n)\ntext = alt.hconcat(first_name, last_name, job_title, department_name)\n\nchart = alt.hconcat(\n    points,\n    text\n).resolve_legend(\n    color=\"independent\"\n).configure_view(\n    stroke=None\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___brushing_scatter_plot_to_show_data_on_a_table.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "performance_attendance",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_chart_with_aggregation",
        "NLQ": "Can you create a chart showing the relationship between performance attendance and the number of pieces played at each performance? I'd like to pull this data from our performance_attendance database instead of using the movie ratings data. Please add a title \"Performance Attendance vs. Number of Pieces Played\" and make the axis labels clearer by renaming them to \"Performance Attendance\" and \"Number of Pieces Played\". I want an interactive slider that lets me set an attendance threshold, with a thick gray line showing where that threshold is. The chart should work like the example I showed you - points above the threshold should be regular circles, while points below should be grouped into bins with the size showing how many points are in each bin.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/performance_attendance.sqlite')\nquery = '''\nSELECT\n    p.Attendance,\n    ma.Num_of_Pieces\nFROM\n    performance AS p\nJOIN\n    member_attendance AS ma ON p.Performance_ID = ma.Performance_ID;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nmax_attendance = df['Attendance'].max()\nslider = alt.binding_range(min=0, max=max_attendance, step=100, name='Attendance Threshold')\nthreshold = alt.param(name=\"threshold\", value=max_attendance/2, bind=slider)\n\nchart = alt.layer(\n    alt.Chart(df).mark_circle().encode(\n        x=alt.X(\"Attendance:Q\").title(\"Performance Attendance\"),\n        y=alt.Y(\"Num_of_Pieces:Q\").title(\"Number of Pieces Played\")\n    ).transform_filter(\n        alt.datum[\"Attendance\"] >= threshold\n    ),\n    alt.Chart(df).mark_circle().encode(\n        x=alt.X(\"Attendance:Q\").bin(maxbins=10).title(\"Performance Attendance (binned)\"),\n        y=alt.Y(\"Num_of_Pieces:Q\").bin(maxbins=10).title(\"Number of Pieces Played (binned)\"),\n        size=alt.Size(\"count():Q\").scale(domain=[0, df.shape[0]])\n    ).transform_filter(\n        alt.datum[\"Attendance\"] < threshold\n    ),\n    alt.Chart().mark_rule(color=\"gray\").encode(\n        strokeWidth=alt.StrokeWidth(value=6),\n        x=alt.X(datum=alt.expr(threshold.name), type=\"quantitative\").title(\"Attendance Threshold\")\n    )\n).add_params(threshold).properties(\n    title=\"Performance Attendance vs. Number of Pieces Played\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_chart_with_aggregation.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "perpetrator",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_chart_with_cross-highlight",
        "NLQ": "Can you create a visualization showing the relationship between total people killed and injured by country? I'd like a heatmap at the top with a color scheme in green-blue tones showing how many countries fall into each bin. When I click on parts of the heatmap, I want to see which specific countries are affected in a bar chart below. Please use my database of perpetrator data instead of the movie ratings, and make sure to label the axes properly as \"Total Killed\" and \"Total Injured\". Also, can you make the bar chart wider so all country names are visible?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/perpetrator.sqlite')\n\nquery = '''\nSELECT Country, SUM(Killed) AS Total_Killed, SUM(Injured) AS Total_Injured\nFROM perpetrator\nGROUP BY Country\nORDER BY Total_Killed DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\npts = alt.selection_point(encodings=['x'])\n\nrect = alt.Chart(df).mark_rect().encode(\n    alt.X('Total_Killed:Q', bin=True, title='Total Killed'),\n    alt.Y('Total_Injured:Q', bin=True, title='Total Injured'),\n    alt.Color('count()').scale(scheme='greenblue').title('Number of Countries')\n)\n\ncirc = rect.mark_point().encode(\n    alt.ColorValue('grey'),\n    alt.Size('count()').title('Countries in Selection')\n).transform_filter(\n    pts\n)\n\nbar = alt.Chart(df, width=550, height=200).mark_bar().encode(\n    x='Country:N',\n    y='count()',\n    color=alt.when(pts).then(alt.ColorValue(\"steelblue\")).otherwise(alt.ColorValue(\"grey\"))\n).add_params(pts)\n\nchart = alt.vconcat(\n    rect + circ,\n    bar\n).resolve_legend(\n    color=\"independent\",\n    size=\"independent\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_chart_with_cross-highlight.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "pilot_record",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_crossfilter",
        "NLQ": "Instead of using the flight data with distance, delay, and time, can you create a similar interactive visualization but for our pilot database? I'd like to see the distribution of pilot ages, ranks, and the years they joined the company. Keep the same interactive filtering where selecting one chart affects the others, but make the unselected bars gray. Also, can you make the charts a bit smaller and neater - around 150x100 in size?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/pilot_record.sqlite')\n\nquery = '''\nSELECT Age, Rank, Join_Year\nFROM pilot;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf['Join_Year'] = pd.to_numeric(df['Join_Year'], errors='coerce')\n\nbrush = alt.selection_interval(encodings=['x'])\n\nbase = alt.Chart(df).mark_bar().encode(\n    alt.X(alt.repeat('column'), bin=alt.Bin(maxbins=20)),\n    y='count()'\n).properties(\n    width=150,\n    height=100\n)\n\nbackground = base.encode(\n    color=alt.value('#ddd')\n).add_params(brush)\n\nhighlight = base.transform_filter(brush)\n\nchart = alt.layer(\n    background,\n    highlight\n).repeat(column=['Age', 'Rank', 'Join_Year'])\n\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_crossfilter.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "products_for_hire",
        "chart_category": "Simple Charts",
        "chart_type": "simple_heatmap",
        "NLQ": "Can you create a heatmap that shows the total amount customers paid each month and year? I want to see the data from my products_for_hire database, with months on the x-axis and years on the y-axis. Please use different colors to represent the payment amounts and add a title that says \"Total Amount Payable by Month and Year\". Also, make sure to label the axes as \"Month\" and \"Year\" and the color legend as \"Total Amount Payable\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/products_for_hire.sqlite')\n\nquery = '''\nSELECT \n    strftime('%Y', booking_start_date) AS year,\n    strftime('%m', booking_start_date) AS month,\n    SUM(amount_payable) AS total_amount_payable\nFROM Bookings\nGROUP BY year, month\nORDER BY year, month\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nheatmap = alt.Chart(df).mark_rect().encode(\n    x=alt.X('month:O', title='Month'),\n    y=alt.Y('year:O', title='Year'),\n    color=alt.Color('total_amount_payable:Q', title='Total Amount Payable')\n).properties(\n    title='Total Amount Payable by Month and Year'\n)\n\nheatmap",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "products_for_hire",
        "chart_category": "Simple Charts",
        "chart_type": "simple_heatmap",
        "NLQ": "Instead of showing that mathematical grid with x and y values, could you create a business-focused heatmap that shows the total amount customers paid each month and year? I need to pull this data from our products_for_hire database, with months running across the x-axis and years down the y-axis. Please use colors to represent the payment amounts and add a title that says \"Total Amount Payable by Month and Year\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/products_for_hire.sqlite')\n\nquery = '''\nSELECT \n    strftime('%Y', booking_start_date) AS year,\n    strftime('%m', booking_start_date) AS month,\n    SUM(amount_payable) AS total_amount_payable\nFROM Bookings\nGROUP BY year, month\nORDER BY year, month\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nheatmap = alt.Chart(df).mark_rect().encode(\n    x=alt.X('month:O', title='Month'),\n    y=alt.Y('year:O', title='Year'),\n    color=alt.Color('total_amount_payable:Q', title='Total Amount Payable')\n).properties(\n    title='Total Amount Payable by Month and Year'\n)\n\nheatmap",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "roller_coaster",
        "chart_category": "Simple Charts",
        "chart_type": "simple_scatter_plot_with_tooltips",
        "NLQ": "Can you change my scatter plot to show roller coaster data instead of cars? I'd like to see the height of roller coasters on the x-axis and their speed on the y-axis. Please color-code the points by country instead of origin, and make the dots a bit bigger. When I hover over a point, I want to see the coaster's name, the park it's in, and its height and speed measurements. Also, can you make the chart interactive so I can explore the data better?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/roller_coaster.sqlite')\n\nquery = '''\nSELECT \n    r.Name AS Coaster_Name,\n    r.Park,\n    r.Height,\n    CAST(r.Speed AS REAL) AS Speed,\n    c.Name AS Country\nFROM \n    roller_coaster AS r\nJOIN \n    country AS c\nON \n    r.Country_ID = c.Country_ID\nWHERE \n    r.Height IS NOT NULL AND r.Speed IS NOT NULL\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle(size=60).encode(\n    x='Height:Q',\n    y='Speed:Q',\n    color='Country:N',\n    tooltip=['Coaster_Name:N', 'Park:N', 'Height:Q', 'Speed:Q']\n).interactive()\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_scatter_plot_with_tooltips.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "roller_coaster",
        "chart_category": "Simple Charts",
        "chart_type": "simple_scatter_plot_with_tooltips",
        "NLQ": "I have this scatter plot showing horsepower vs. miles per gallon for cars from different countries, but I'd like to create something similar for roller coasters instead. Can you make a chart that shows the height of roller coasters on the x-axis and their speed on the y-axis? I want different colors for each country, just like how the original shows different origins. Also, could you make it interactive so when I hover over a point, I can see details about that roller coaster, like its name, the park it's in, and its exact height and speed measurements? I need this data to come from my roller coaster database rather than using random values.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/roller_coaster.sqlite')\n\nquery = '''\nSELECT \n    r.Name AS Coaster_Name,\n    r.Park,\n    r.Height,\n    CAST(r.Speed AS REAL) AS Speed,\n    c.Name AS Country\nFROM \n    roller_coaster AS r\nJOIN \n    country AS c\nON \n    r.Country_ID = c.Country_ID\nWHERE \n    r.Height IS NOT NULL AND r.Speed IS NOT NULL\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle(size=60).encode(\n    x='Height:Q',\n    y='Speed:Q',\n    color='Country:N',\n    tooltip=['Coaster_Name:N', 'Park:N', 'Height:Q', 'Speed:Q']\n).interactive()\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_scatter_plot_with_tooltips.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "store_product",
        "chart_category": "Interactive Charts",
        "chart_type": "multiple_interactions",
        "NLQ": "I have a database with store information and I'd like to create a scatter plot showing the relationship between store area size and number of product categories. Can you make a visualization where each store is represented by a circle, with store area size on the x-axis and number of product categories on the y-axis? I want to include interactive filters: a dropdown menu to select store types, a slider to filter by store ranking, and radio buttons to highlight stores with specific rankings. When using the radio buttons, highlighted stores should be colored while others appear light gray. Also, make sure to include store name, type and ranking in the tooltip when hovering over points. Can you arrange these three interactive components in a 2x2 grid layout?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/store_product.sqlite')\nquery = '''\nSELECT Store_Name, Type, Area_size, Number_of_product_category, Ranking\nFROM store\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).mark_circle().encode(\n    x=alt.X('Area_size:Q', title='Store Area Size'),\n    y=alt.Y('Number_of_product_category:Q', title='Number of Product Categories'),\n    tooltip=['Store_Name:N', 'Type:N', 'Ranking:N']\n)\n\ntype_dropdown = alt.binding_select(options=df['Type'].unique().tolist(), name=\"Store Type\")\ntype_select = alt.selection_point(fields=['Type'], bind=type_dropdown)\n\nfilter_type = base.add_params(\n    type_select\n).transform_filter(\n    type_select\n).properties(title=\"Filter by Store Type\")\n\nranking_slider = alt.binding_range(min=df['Ranking'].min(), max=df['Ranking'].max(), step=1, name=\"Ranking\")\nranking_selection = alt.selection_point(bind=ranking_slider, fields=['Ranking'])\n\nfilter_ranking = base.add_params(\n    ranking_selection\n).transform_filter(\n    ranking_selection\n).properties(title=\"Filter by Ranking\")\n\nranking_radio = alt.binding_radio(options=df['Ranking'].unique().tolist(), name=\"Highlight Ranking\")\nranking_highlight = alt.selection_point(fields=['Ranking'], bind=ranking_radio)\n\nhighlight_ranking = base.add_params(\n    ranking_highlight\n).encode(\n    color=alt.condition(ranking_highlight, alt.Color('Ranking:N', legend=None), alt.value('lightgray'))\n).properties(title=\"Highlight by Ranking\")\n\n(filter_type | filter_ranking) & highlight_ranking",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multiple_interactions.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "tracking_orders",
        "chart_category": "Interactive Charts",
        "chart_type": "scatter_plot_and_histogram_with_interval_selection",
        "NLQ": "Can you create a dashboard that shows our order tracking data from the database? I need a scatter plot showing order IDs versus customer IDs, and a histogram showing the distribution of invoice numbers. Make both charts the same size, about 300x300. For the scatter plot, use filled black points. When I select data points in either chart, I want the selected bars in the histogram to stay black while the unselected ones turn light gray. Please pull the data from our tracking_orders database, joining the Orders, Shipments, and Invoices tables.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/tracking_orders.sqlite')\n\nquery = '''\nSELECT\n    O.order_id,\n    O.customer_id,\n    I.invoice_number\nFROM Orders AS O\nJOIN Shipments AS S ON O.order_id = S.order_id\nJOIN Invoices AS I ON S.invoice_number = I.invoice_number;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\npts = alt.selection_interval(encodings=[\"x\", \"y\"])\n\npoints = alt.Chart(df).mark_point(filled=True, color=\"black\").encode(\n    x='order_id',\n    y='customer_id'\n).transform_filter(\n    pts\n).properties(\n    width=300,\n    height=300\n)\n\nmag = alt.Chart(df).mark_bar().encode(\n    x='invoice_number_bin:N',\n    y=\"count()\",\n    color=alt.condition(pts, alt.value(\"black\"), alt.value(\"lightgray\"))\n).properties(\n    width=300,\n    height=300\n).add_params(pts)\n\nchart = alt.hconcat(\n    points,\n    mag\n).transform_bin(\n    \"invoice_number_bin\",\n    field=\"invoice_number\",\n    bin=alt.Bin(maxbins=20)\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___scatter_plot_and_histogram_with_interval_selection.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "wedding",
        "chart_category": "Interactive Charts",
        "chart_type": "selection_histogram",
        "NLQ": "I have some wedding data in a database that shows when people got married and what countries they're from. Could you create an interactive chart that shows the number of weddings per year? I'd like to see the count of people from different countries over time, with points showing the yearly counts and a bar chart showing the breakdown by country. When I select certain years in the top chart, I want the bar chart below to update to show just those countries. Please use different colors for each country and make the unselected points light gray.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/wedding.sqlite')\n\nquery = '''\nSELECT w.Year, p1.Country AS Male_Country, p2.Country AS Female_Country\nFROM wedding AS w\nJOIN people AS p1 ON w.Male_ID = p1.People_ID\nJOIN people AS p2 ON w.Female_ID = p2.People_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_combined = pd.melt(df, id_vars=['Year'], value_vars=['Male_Country', 'Female_Country'], \n                      var_name='Gender', value_name='Country')\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(df_combined).mark_point().encode(\n    x='Year:Q',\n    y='count(Country):Q',\n    color=alt.condition(brush, 'Country:N', alt.value('lightgray'))\n).add_params(\n    brush\n)\n\nbars = alt.Chart(df_combined).mark_bar().encode(\n    y='Country:N',\n    color='Country:N',\n    x='count(Country):Q'\n).transform_filter(\n    brush\n)\n\npoints & bars",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___selection_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "local_govt_and_lot",
        "chart_category": "Scatter Plots",
        "chart_type": "faceted_scatter_plot",
        "NLQ": "Can you help me create a chart that shows how many residents are satisfied with each type of service, broken down by the kind of property they live in? I want to see the service types on the y-axis and the resident count on the x-axis. Please organize it so each property type gets its own row in the chart, with points showing the number of residents for each service type. I need to pull this data from our local government database, specifically looking at satisfied residents only.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/local_govt_and_lot.sqlite')\n\nquery = '''\nSELECT \n    T1.service_type_code AS Service_Type,\n    COUNT(T2.resident_id) AS Resident_Count,\n    T3.property_type_code AS Property_Type\nFROM \n    Services AS T1\nJOIN \n    Residents_Services AS T2 ON T1.service_id = T2.service_id\nJOIN \n    Properties AS T3 ON T2.property_id = T3.property_id\nWHERE \n    T1.service_details = 'Satisfied'\nGROUP BY \n    T1.service_type_code, T3.property_type_code\nORDER BY \n    T1.service_type_code, T3.property_type_code;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, width=100, height=100).mark_point().encode(\n    x=\"Resident_Count:Q\",\n    y=\"Service_Type:N\",\n    row=\"Property_Type:N\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___faceted_scatter_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "local_govt_and_lot",
        "chart_category": "Scatter Plots",
        "chart_type": "faceted_scatter_plot",
        "NLQ": "Can you change my car performance chart to show local government service data instead? I'd like to see how many residents use each type of service, broken down by property type. I want to pull this data from my SQLite database, focusing only on satisfied services. Each property type should have its own row of charts, with service types on the y-axis and resident counts on the x-axis. Please use Altair instead of matplotlib for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/local_govt_and_lot.sqlite')\n\nquery = '''\nSELECT \n    T1.service_type_code AS Service_Type,\n    COUNT(T2.resident_id) AS Resident_Count,\n    T3.property_type_code AS Property_Type\nFROM \n    Services AS T1\nJOIN \n    Residents_Services AS T2 ON T1.service_id = T2.service_id\nJOIN \n    Properties AS T3 ON T2.property_id = T3.property_id\nWHERE \n    T1.service_details = 'Satisfied'\nGROUP BY \n    T1.service_type_code, T3.property_type_code\nORDER BY \n    T1.service_type_code, T3.property_type_code;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, width=100, height=100).mark_point().encode(\n    x=\"Resident_Count:Q\",\n    y=\"Service_Type:N\",\n    row=\"Property_Type:N\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___faceted_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "machine_repair",
        "chart_category": "Scatter Plots",
        "chart_type": "multifeature_scatter_plot",
        "NLQ": "Could you help me create a chart that shows the relationship between when machines were made and their value, using colors to group them by type and adjusting the size of the points based on their quality ranking? I want to use our machine repair database and only include machines made after 1990. Make sure the axes don't start from zero so we can see the patterns more clearly.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/machine_repair.sqlite')\n\nquery = '''\nSELECT Making_Year, value_points, Class, quality_rank\nFROM machine\nWHERE Making_Year > 1990\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    alt.X('Making_Year').scale(zero=False),\n    alt.Y('value_points').scale(zero=False, padding=1),\n    color='Class',\n    size='quality_rank'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___multifeature_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "activity_1",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart",
        "NLQ": "Can you create a bar chart that shows the number of students and faculty participating in each activity? I'd like to see the activities listed along the bottom axis, with bars showing the count of participants. Please use different colors to distinguish between students and faculty members in each activity, similar to how the example chart uses colors to show different sites for each variety.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/activity_1.sqlite')\nquery = '''\nSELECT \n    A.activity_name,\n    COUNT(DISTINCT P.stuid) AS student_count,\n    COUNT(DISTINCT F.FacID) AS faculty_count\nFROM \n    Activity AS A\nLEFT JOIN \n    Participates_in AS P ON A.actid = P.actid\nLEFT JOIN \n    Faculty_Participates_in AS F ON A.actid = F.actid\nGROUP BY \n    A.activity_name\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['activity_name'], \n                    value_vars=['student_count', 'faculty_count'], \n                    var_name='participant_type', \n                    value_name='count')\n\nchart = alt.Chart(df_melted).mark_bar().encode(\n    x='activity_name:N',\n    y='sum(count):Q',\n    color='participant_type:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "activity_1",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart",
        "NLQ": "Can you create a chart showing the number of students and faculty participating in each activity? I'd like to see the data from our activity database instead of using random numbers. Make it a stacked bar chart where each activity is on the x-axis, with different colors showing student counts versus faculty counts. Similar to the example I showed you with varieties and sites, but using our actual participation data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/activity_1.sqlite')\n\nquery = '''\nSELECT \n    A.activity_name,\n    COUNT(DISTINCT P.stuid) AS student_count,\n    COUNT(DISTINCT F.FacID) AS faculty_count\nFROM \n    Activity AS A\nLEFT JOIN \n    Participates_in AS P ON A.actid = P.actid\nLEFT JOIN \n    Faculty_Participates_in AS F ON A.actid = F.actid\nGROUP BY \n    A.activity_name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['activity_name'], \n                    value_vars=['student_count', 'faculty_count'], \n                    var_name='participant_type', \n                    value_name='count')\n\nchart = alt.Chart(df_melted).mark_bar().encode(\n    x='activity_name:N',\n    y='sum(count):Q',\n    color='participant_type:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "allergy_1",
        "chart_category": "Advanced Calculations",
        "chart_type": "calculate_residuals",
        "NLQ": "Instead of showing movie ratings over time, can you create a scatter plot that shows student ages compared to the average age? I'd like to see how each student's age differs from the average, with the x-axis showing their actual age and the y-axis showing how far above or below average they are. Please add colors that change based on how much they deviate from the average age, and give it a clear title like \"Student Age Deviation from Average.\" Also, can you pull this data from our student database instead of using random numbers?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/allergy_1.sqlite')\nquery = '''\nSELECT Age\nFROM Student;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_point().transform_joinaggregate(\n    Average_Age='mean(Age)'\n).transform_calculate(\n    Age_Delta='datum.Age - datum.Average_Age'\n).encode(\n    x=alt.X('Age:Q').title('Student Age'),\n    y=alt.Y('Age_Delta:Q').title('Age Delta (Age - Average Age)'),\n    color=alt.Color('Age_Delta:Q').title('Age Delta').scale(scheme='viridis')\n).properties(\n    title='Student Age Deviation from Average'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___calculate_residuals.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "allergy_1",
        "chart_category": "Advanced Calculations",
        "chart_type": "calculate_residuals",
        "NLQ": "Instead of using the movie ratings data from my example, can you create a similar chart but using student age data from our database? I want to see how each student's age compares to the average age of all students. Please label the x-axis as \"Student Age\" and the y-axis as \"Age Delta (Age - Average Age)\" and give the chart a title \"Student Age Deviation from Average\". Use a nice color gradient like viridis to highlight the differences between ages.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/allergy_1.sqlite')\n\nquery = '''\nSELECT Age\nFROM Student;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_point().transform_joinaggregate(\n    Average_Age='mean(Age)'\n).transform_calculate(\n    Age_Delta='datum.Age - datum.Average_Age'\n).encode(\n    x=alt.X('Age:Q').title('Student Age'),\n    y=alt.Y('Age_Delta:Q').title('Age Delta (Age - Average Age)'),\n    color=alt.Color('Age_Delta:Q').title('Age Delta').scale(scheme='viridis')\n).properties(\n    title='Student Age Deviation from Average'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___calculate_residuals.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "allergy_1",
        "chart_category": "Interactive Charts",
        "chart_type": "slider_cutoff",
        "NLQ": "Can you change my scatter plot to a bar chart showing the number of students with food allergies by age? Instead of random data, I need to pull this information from my allergy database. Keep the interactive slider that changes colors, but make it work with age ranges instead of x-values. I want red bars for younger students and blue bars for older ones, based on whatever age cutoff I select with the slider.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/allergy_1.sqlite')\n\nquery = '''\nSELECT S.Age, COUNT(*) AS NumStudents\nFROM Student AS S\nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID\nJOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy\nWHERE AT.AllergyType = 'food'\nGROUP BY S.Age\nORDER BY S.Age\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nslider = alt.binding_range(min=df['Age'].min(), max=df['Age'].max(), step=1)\ncutoff = alt.param(bind=slider, value=df['Age'].min())\n\npredicate = alt.datum.Age < cutoff\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Age:O',\n    y='NumStudents:Q',\n    color=alt.when(predicate).then(alt.value(\"red\")).otherwise(alt.value(\"blue\")),\n).add_params(\n    cutoff\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___slider_cutoff.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "allergy_1",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_sorted_segments",
        "NLQ": "I'd like to create a chart showing how many students in each major have different types of allergies. Can you pull this data from our allergy database? I want to see the majors listed on the y-axis and have the bars stacked by allergy type, with each type shown in a different color. Make sure the bars are sorted by allergy type in ascending order so it's easy to compare across majors.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/allergy_1.sqlite')\n\nquery = '''\nSELECT \n    S.Major AS Major,\n    AT.AllergyType AS AllergyType,\n    COUNT(*) AS StudentCount\nFROM \n    Student AS S\nJOIN \n    Has_Allergy AS HA ON S.StuID = HA.StuID\nJOIN \n    Allergy_Type AS AT ON HA.Allergy = AT.Allergy\nGROUP BY \n    S.Major, AT.AllergyType\nORDER BY \n    S.Major, AT.AllergyType\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='sum(StudentCount):Q',\n    y='Major:N',\n    color='AllergyType:N',\n    order=alt.Order(\n        'AllergyType',\n        sort='ascending'\n    )\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___stacked_bar_chart_with_sorted_segments.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "allergy_1",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_sorted_segments",
        "NLQ": "Instead of using the random yield data by variety and site, can you create a horizontal bar chart that shows the number of students in each major who have different types of allergies? I need this data to come from my allergy database. Please stack the bars by allergy type and color-code them so I can easily see the distribution of allergies across different majors.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/allergy_1.sqlite')\n\nquery = '''\nSELECT \n    S.Major AS Major,\n    AT.AllergyType AS AllergyType,\n    COUNT(*) AS StudentCount\nFROM \n    Student AS S\nJOIN \n    Has_Allergy AS HA ON S.StuID = HA.StuID\nJOIN \n    Allergy_Type AS AT ON HA.Allergy = AT.Allergy\nGROUP BY \n    S.Major, AT.AllergyType\nORDER BY \n    S.Major, AT.AllergyType\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='sum(StudentCount):Q',\n    y='Major:N',\n    color='AllergyType:N',\n    order=alt.Order(\n        'AllergyType',\n        sort='ascending'\n    )\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___stacked_bar_chart_with_sorted_segments.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "baseball_1",
        "chart_category": "Interactive Charts",
        "chart_type": "using_selection_interval_with_mark_area",
        "NLQ": "Could you change my chart to show baseball home run data instead of those random counts? I'd like to pull the yearly home run totals from the baseball database and display them in a nice steelblue color with some transparency. Keep that interactive feature where I can select a time range to focus on, but make sure both the background and selected areas use the steelblue color scheme.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/baseball_1.sqlite')\n\nquery = '''\nSELECT year, SUM(hr) AS total_hr\nFROM batting\nGROUP BY year\nORDER BY year\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df).mark_area(\n    color='steelblue',\n    opacity=0.3\n).encode(\n    x='year:T',\n    y='total_hr:Q'\n)\n\nbrush = alt.selection_interval(encodings=['x'])\nbackground = base.add_params(brush)\nselected = base.transform_filter(brush).mark_area(color='steelblue')\n\nbackground + selected",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___using_selection_interval_with_mark_area.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "baseball_1",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_text_overlay",
        "NLQ": "I want to create a stacked bar chart showing the total number of home runs by year for the American and National leagues. Use the baseball database to get this data. Make the bars horizontal with years on the y-axis and total home runs on the x-axis. Color-code the bars by league and add white text labels showing the exact number of home runs directly on each bar segment. Please add a title \"Total Home Runs by League Over the Years\" and proper axis labels like \"Year\" and \"Total Home Runs\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/baseball_1.sqlite')\n\nquery = '''\nSELECT \n    year,\n    league_id,\n    SUM(hr) AS total_hr\nFROM \n    batting\nWHERE \n    league_id IN ('NL', 'AL') AND hr IS NOT NULL\nGROUP BY \n    year, league_id\nORDER BY \n    year ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X('sum(total_hr):Q').stack('zero').title('Total Home Runs'),\n    y=alt.Y('year:N').title('Year'),\n    color=alt.Color('league_id:N').title('League')\n)\n\ntext = alt.Chart(df).mark_text(dx=-15, dy=3, color='white').encode(\n    x=alt.X('sum(total_hr):Q').stack('zero'),\n    y=alt.Y('year:N'),\n    detail='league_id:N',\n    text=alt.Text('sum(total_hr):Q', format='.0f')\n)\n\nchart = bars + text\nchart.properties(title=\"Total Home Runs by League Over the Years\")",
        "reference_path": "./vis_bench/code/altair/Bar Charts___stacked_bar_chart_with_text_overlay.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "baseball_1",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_text_overlay",
        "NLQ": "I want to create a horizontal stacked bar chart showing baseball data instead of crop yields. Can you show the total home runs by year for the American and National leagues? Use the baseball database to get this data. Make the bars stack horizontally with years on the y-axis and total home runs on the x-axis. Add a title \"Total Home Runs by League Over the Years\" and display the actual numbers on each bar segment in white text. Also, can you use Altair instead of matplotlib?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/baseball_1.sqlite')\n\nquery = '''\nSELECT \n    year,\n    league_id,\n    SUM(hr) AS total_hr\nFROM \n    batting\nWHERE \n    league_id IN ('NL', 'AL') AND hr IS NOT NULL\nGROUP BY \n    year, league_id\nORDER BY \n    year ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X('sum(total_hr):Q').stack('zero').title('Total Home Runs'),\n    y=alt.Y('year:N').title('Year'),\n    color=alt.Color('league_id:N').title('League')\n)\n\ntext = alt.Chart(df).mark_text(dx=-15, dy=3, color='white').encode(\n    x=alt.X('sum(total_hr):Q').stack('zero'),\n    y=alt.Y('year:N'),\n    detail='league_id:N',\n    text=alt.Text('sum(total_hr):Q', format='.0f')\n)\n\nchart = bars + text\nchart.properties(title=\"Total Home Runs by League Over the Years\")",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___stacked_bar_chart_with_text_overlay.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "chinook_1",
        "chart_category": "Circular Plots",
        "chart_type": "pie_chart",
        "NLQ": "Using the code I shared as a guide, could you create a colorful pie chart that shows how many tracks belong to each music genre from my music database? I'd like it to look similar to the style in my example, with each genre represented by a different slice of the pie. The data should come from the chinook database, showing the count of tracks for each genre name, and sorted by the number of tracks in descending order.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/chinook_1.sqlite')\n\nquery = '''\nSELECT \n    g.Name AS GenreName,\n    COUNT(t.TrackId) AS TrackCount\nFROM \n    Track AS t\nJOIN \n    Genre AS g ON t.GenreId = g.GenreId\nGROUP BY \n    g.Name\nORDER BY \n    TrackCount DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_arc().encode(\n    theta=\"TrackCount\",\n    color=\"GenreName\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Circular Plots___pie_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "chinook_1",
        "chart_category": "Circular Plots",
        "chart_type": "pie_chart",
        "NLQ": "Using the code I shared as a guide, could you create a colorful pie chart that shows how many tracks belong to each music genre from my music database? I'd like to pull the data directly from my SQLite database called 'chinook_1' instead of using the example values. The chart should show the genre names and count of tracks in each genre, with the larger genres appearing first. Could you use Altair instead of Matplotlib for this visualization?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/chinook_1.sqlite')\n\nquery = '''\nSELECT \n    g.Name AS GenreName,\n    COUNT(t.TrackId) AS TrackCount\nFROM \n    Track AS t\nJOIN \n    Genre AS g ON t.GenreId = g.GenreId\nGROUP BY \n    g.Name\nORDER BY \n    TrackCount DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_arc().encode(\n    theta=\"TrackCount\",\n    color=\"GenreName\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Circular Plots___pie_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "chinook_1",
        "chart_category": "Advanced Calculations",
        "chart_type": "gantt_chart",
        "NLQ": "I have a simple bar chart showing tasks A, B, and C with their start and end times. Could you change this to show employee tenure at our company instead? I'd like to see each employee's name on the y-axis and bars showing how long they've worked here, from their hire date until now. Please add a title that says \"Employee Tenure at the Company\" and make sure to pull the employee data from our database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\nfrom datetime import datetime\n\nconn = sqlite3.connect('database/chinook_1.sqlite')\n\nquery = '''\nSELECT \n    EmployeeId,\n    FirstName || ' ' || LastName AS FullName,\n    HireDate\nFROM \n    Employee\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ntoday = datetime.today()\ndf['start'] = df['HireDate'].apply(lambda x: datetime.strptime(x, '%Y-%m-%d %H:%M:%S').year)\ndf['end'] = today.year\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='start:O',\n    x2='end:O',\n    y=alt.Y('FullName:N', title=\"Employee Name\")\n).properties(\n    title=\"Employee Tenure at the Company\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___gantt_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "chinook_1",
        "chart_category": "Advanced Calculations",
        "chart_type": "gantt_chart",
        "NLQ": "Can you change this simple task timeline into a chart showing how long each employee has been with the company? I'd like to pull the employee data from our database, showing their full names and when they were hired. The bars should stretch from their hire year to the current year, and please add a title that says \"Employee Tenure at the Company\". Also, can you use Altair instead of Matplotlib for this visualization?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\nfrom datetime import datetime\n\nconn = sqlite3.connect('database/chinook_1.sqlite')\n\nquery = '''\nSELECT \n    EmployeeId,\n    FirstName || ' ' || LastName AS FullName,\n    HireDate\nFROM \n    Employee\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ntoday = datetime.today()\ndf['start'] = df['HireDate'].apply(lambda x: datetime.strptime(x, '%Y-%m-%d %H:%M:%S').year)\ndf['end'] = today.year\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='start:O',\n    x2='end:O',\n    y=alt.Y('FullName:N', title=\"Employee Name\")\n).properties(\n    title=\"Employee Tenure at the Company\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___gantt_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "browser_web",
        "chart_category": "Line Charts",
        "chart_type": "filled_step_chart",
        "NLQ": "I'd like to see a chart that shows how the total market share of browsers has grown over the years. Can you create a stepped area chart with light blue shading and a border line? Put the year on the x-axis and the cumulative market share on the y-axis. Please label the axes clearly and add a title that says \"Cumulative Browser Market Share Over Time\". Instead of using random data, can you pull the actual browser market share data from our SQLite database, specifically looking at the compatibility year and summing up the market share?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/browser_web.sqlite')\n\nquery = '''\nSELECT \n    T3.compatible_since_year AS year,\n    SUM(T2.market_share) AS cumulative_market_share\nFROM \n    accelerator_compatible_browser AS T3\nJOIN \n    browser AS T2 ON T3.browser_id = T2.id\nGROUP BY \n    T3.compatible_since_year\nORDER BY \n    T3.compatible_since_year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_area(\n    color=\"lightblue\",\n    interpolate='step-after',\n    line=True\n).encode(\n    x=alt.X('year:O', title='Year'),\n    y=alt.Y('cumulative_market_share:Q', title='Cumulative Market Share')\n).properties(\n    title=\"Cumulative Browser Market Share Over Time\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___filled_step_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "browser_web",
        "chart_category": "Line Charts",
        "chart_type": "filled_step_chart",
        "NLQ": "Instead of showing Google stock prices over time, can you create a chart that shows how the total market share of browsers has grown over the years? I'd like it to have a stepped, filled look with light blue shading and show the year on the bottom and the cumulative market share on the side. Please pull this data from our browser database and title the chart \"Cumulative Browser Market Share Over Time\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/browser_web.sqlite')\n\nquery = '''\nSELECT \n    T3.compatible_since_year AS year,\n    SUM(T2.market_share) AS cumulative_market_share\nFROM \n    accelerator_compatible_browser AS T3\nJOIN \n    browser AS T2 ON T3.browser_id = T2.id\nGROUP BY \n    T3.compatible_since_year\nORDER BY \n    T3.compatible_since_year\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_area(\n    color=\"lightblue\",\n    interpolate='step-after',\n    line=True\n).encode(\n    x=alt.X('year:O', title='Year'),\n    y=alt.Y('cumulative_market_share:Q', title='Cumulative Market Share')\n).properties(\n    title=\"Cumulative Browser Market Share Over Time\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___filled_step_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "candidate_poll",
        "chart_category": "Advanced Calculations",
        "chart_type": "gantt_chart",
        "NLQ": "I want to create a Gantt chart using my candidate poll database instead of the sample data. Can you pull the Poll_Source and Candidate_ID from my SQLite database, and use the Poll_Source as the task labels on the y-axis? Make each Candidate_ID represent the start time, with the end time being one unit later.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/candidate_poll.sqlite')\nquery = '''\nSELECT Poll_Source, Candidate_ID\nFROM candidate\nORDER BY Candidate_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf['start'] = df['Candidate_ID']\ndf['end'] = df['Candidate_ID'] + 1\ndf['task'] = df['Poll_Source']\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='start',\n    x2='end',\n    y='task'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___gantt_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "candidate_poll",
        "chart_category": "Advanced Calculations",
        "chart_type": "gantt_chart",
        "NLQ": "I want to change my simple task timeline chart to show poll sources for different candidates. Instead of using my current chart, can you create one that pulls data from my candidate_poll database? I need to see how different poll sources are distributed across candidate IDs, with each poll source as a separate row and the candidate IDs as the timeline. Use the Poll_Source and Candidate_ID fields from the database.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/candidate_poll.sqlite')\nquery = '''\nSELECT Poll_Source, Candidate_ID\nFROM candidate\nORDER BY Candidate_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf['start'] = df['Candidate_ID']\ndf['end'] = df['Candidate_ID'] + 1\ndf['task'] = df['Poll_Source']\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='start',\n    x2='end',\n    y='task'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___gantt_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "company_employee",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_custom_order",
        "NLQ": "Instead of showing gas mileage data, I'd like to create a chart that shows how the average age of employees relates to their total work experience, grouped by the college they graduated from. Can you pull this data from our company employee database? I want a line chart with points, where the x-axis shows total work experience in years and the y-axis shows average age. Please don't start the axes at zero, and add proper titles to both axes. Add a title at the top that says \"Work Experience vs. Average Age by Graduation College\" and make it so when I hover over points, I can see the college name, total experience, and average age.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_employee.sqlite')\n\nquery = '''\nSELECT \n    p.Graduation_College AS College,\n    AVG(p.Age) AS Avg_Age,\n    SUM(e.Year_working) AS Total_Experience\nFROM \n    people AS p\nJOIN \n    employment AS e ON p.People_ID = e.People_ID\nGROUP BY \n    p.Graduation_College\nORDER BY \n    AVG(p.Age)\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line(point=True).encode(\n    x=alt.X(\"Total_Experience:Q\").scale(zero=False).title(\"Total Work Experience (Years)\"),\n    y=alt.Y(\"Avg_Age:Q\").scale(zero=False).title(\"Average Age of Employees\"),\n    order=\"Avg_Age\",\n    tooltip=[\"College\", \"Total_Experience\", \"Avg_Age\"]\n).properties(\n    title=\"Work Experience vs. Average Age by Graduation College\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_custom_order.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "company_employee",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_custom_order",
        "NLQ": "Instead of plotting gas consumption against miles driven, I'd like to create a chart showing the relationship between employees' average age and their total work experience, grouped by the college they graduated from. Can you pull this data from our company employee database? I want a line chart with points that I can hover over to see details like the college name, total experience, and average age. Please label the axes clearly as \"Total Work Experience (Years)\" and \"Average Age of Employees\", and give the chart a title that explains what we're looking at. Make sure the chart doesn't start from zero so we can better see the trends.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_employee.sqlite')\n\nquery = '''\nSELECT \n    p.Graduation_College AS College,\n    AVG(p.Age) AS Avg_Age,\n    SUM(e.Year_working) AS Total_Experience\nFROM \n    people AS p\nJOIN \n    employment AS e ON p.People_ID = e.People_ID\nGROUP BY \n    p.Graduation_College\nORDER BY \n    AVG(p.Age)\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line(point=True).encode(\n    x=alt.X(\"Total_Experience:Q\").scale(zero=False).title(\"Total Work Experience (Years)\"),\n    y=alt.Y(\"Avg_Age:Q\").scale(zero=False).title(\"Average Age of Employees\"),\n    order=\"Avg_Age\",\n    tooltip=[\"College\", \"Total_Experience\", \"Avg_Age\"]\n).properties(\n    title=\"Work Experience vs. Average Age by Graduation College\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_custom_order.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "company_employee",
        "chart_category": "Advanced Calculations",
        "chart_type": "layered_chart_with_dual-axis",
        "NLQ": "Instead of showing temperature and precipitation data by month, can you create a chart that shows the total number of employees and their average years of experience across different industries? I'd like to use green bars to show the employee counts and a smooth blue line for the years of experience. The data should come from our company database rather than the weather dataset. Make sure to label the axes clearly with appropriate titles.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_employee.sqlite')\n\nquery = '''\nSELECT \n    c.Industry AS Industry,\n    COUNT(e.People_ID) AS Total_Employees,\n    AVG(e.Year_working) AS Avg_Years_Experience\nFROM \n    company AS c\nJOIN \n    employment AS e ON c.Company_ID = e.Company_ID\nGROUP BY \n    c.Industry\nORDER BY \n    Total_Employees DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.X('Industry:N').title('Industry')\n)\n\nbar = base.mark_bar(color='#57A44C', opacity=0.7).encode(\n    alt.Y('Total_Employees:Q').axis(title='Total Employees', titleColor='#57A44C')\n)\n\nline = base.mark_line(stroke='#5276A7', interpolate='monotone').encode(\n    alt.Y('Avg_Years_Experience:Q').axis(title='Average Years of Experience', titleColor='#5276A7')\n)\n\nchart = alt.layer(bar, line).resolve_scale(\n    y='independent'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___layered_chart_with_dual-axis.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "company_employee",
        "chart_category": "Advanced Calculations",
        "chart_type": "layered_chart_with_dual-axis",
        "NLQ": "I have this weather chart showing temperature ranges and precipitation in Seattle by month, but I'd like to create something completely different. Could you make a chart that shows the total number of employees and their average years of experience across different industries? I want to use data from my company database instead. For the visualization, I'd like green bars to represent the employee counts and a smooth blue line to show the average years of experience. Please make sure the industries are ordered by the number of employees from highest to lowest.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_employee.sqlite')\nquery = '''\nSELECT \n    c.Industry AS Industry,\n    COUNT(e.People_ID) AS Total_Employees,\n    AVG(e.Year_working) AS Avg_Years_Experience\nFROM \n    company AS c\nJOIN \n    employment AS e ON c.Company_ID = e.Company_ID\nGROUP BY \n    c.Industry\nORDER BY \n    Total_Employees DESC;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.X('Industry:N').title('Industry')\n)\nbar = base.mark_bar(color='#57A44C', opacity=0.7).encode(\n    alt.Y('Total_Employees:Q').axis(title='Total Employees', titleColor='#57A44C')\n)\nline = base.mark_line(stroke='#5276A7', interpolate='monotone').encode(\n    alt.Y('Avg_Years_Experience:Q').axis(title='Average Years of Experience', titleColor='#5276A7')\n)\nchart = alt.layer(bar, line).resolve_scale(\n    y='independent'\n)\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___layered_chart_with_dual-axis.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "concert_singer",
        "chart_category": "Distributions",
        "chart_type": "2d_histogram_heatmap",
        "NLQ": "Can you change my chart to show concert data instead of movie ratings? I want to see how many concerts happen each year in stadiums of different sizes. Put the years on the x-axis and stadium capacity on the y-axis, and use color to show the number of concerts. Please use a greenblue color scheme and add a title that says \"Distribution of Concerts by Year and Stadium Capacity\". Also, can you pull this data from my concert_singer database instead of using random numbers?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/concert_singer.sqlite')\n\nquery = '''\nSELECT \n    c.Year AS Year,\n    s.Capacity AS Capacity\nFROM \n    concert AS c\nJOIN \n    stadium AS s\nON \n    c.Stadium_ID = s.Stadium_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_rect().encode(\n    alt.X('Year:O').title('Year'),\n    alt.Y('Capacity:Q').bin(maxbins=30).title('Stadium Capacity'),\n    alt.Color('count():Q').scale(scheme='greenblue').title('Concert Count')\n).properties(\n    title='Distribution of Concerts by Year and Stadium Capacity'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___2d_histogram_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "concert_singer",
        "chart_category": "Distributions",
        "chart_type": "2d_histogram_heatmap",
        "NLQ": "Can you change my movie ratings heatmap to show concert data instead? I'd like to see how many concerts happen each year in stadiums of different sizes, with colors showing the number of concerts. Use a greenblue color scheme and title it \"Distribution of Concerts by Year and Stadium Capacity\". The data should come from my concert database instead of the random movie ratings.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/concert_singer.sqlite')\nquery = '''\nSELECT \n    c.Year AS Year,\n    s.Capacity AS Capacity\nFROM \n    concert AS c\nJOIN \n    stadium AS s\nON \n    c.Stadium_ID = s.Stadium_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_rect().encode(\n    alt.X('Year:O').title('Year'),\n    alt.Y('Capacity:Q').bin(maxbins=30).title('Stadium Capacity'),\n    alt.Color('count():Q').scale(scheme='greenblue').title('Concert Count')\n).properties(\n    title='Distribution of Concerts by Year and Stadium Capacity'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___2d_histogram_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "culture_company",
        "chart_category": "Advanced Calculations",
        "chart_type": "ranged_dot_plot",
        "NLQ": "Can you create a chart that shows movie budgets and worldwide earnings side by side? I'd like to see each movie title listed vertically, with two dots for each movie - one showing the budget in millions and another showing the gross worldwide earnings - connected by a line. Please use reddish colors, with a lighter shade for the budget and a darker red for the earnings. I have a database with movie information that you can pull the data from instead of using the sample country data.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/culture_company.sqlite')\nquery = '''\nSELECT Title, Budget_million, Gross_worldwide\nFROM movie\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = pd.melt(df, id_vars=['Title'], value_vars=['Budget_million', 'Gross_worldwide'], var_name='Measure', value_name='Value')\n\nchart = alt.Chart(df_melted).mark_line(color=\"#db646f\").encode(\n    y=alt.Y('Title:N'),\n    x=alt.X('Value:Q'),\n    detail='Title:N'\n)\n\npoints = alt.Chart(df_melted).mark_point(\n    size=100,\n    opacity=1,\n    filled=True,\n).encode(\n    y=alt.Y('Title:N'),\n    x=alt.X('Value:Q'),\n    color=alt.Color('Measure:N').scale(domain=['Budget_million', 'Gross_worldwide'], range=[\"#e6959c\", \"#911a24\"])\n)\n\nfinal_chart = (chart + points)\nfinal_chart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___ranged_dot_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "culture_company",
        "chart_category": "Advanced Calculations",
        "chart_type": "ranged_dot_plot",
        "NLQ": "I want to create a chart that shows how movie budgets and earnings compare for different films. Can you make it so that each movie has two dots connected by a line, with one dot for the budget and another for the total earnings? I'd like to use data from our company's database instead of the life expectancy data. Also, can you use reddish colors - maybe a darker red for the worldwide gross and a lighter red for the budget, with the connecting lines in a medium red shade? I want to see the movie titles listed on the y-axis and the dollar values on the x-axis.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/culture_company.sqlite')\n\nquery = '''\nSELECT Title, Budget_million, Gross_worldwide\nFROM movie\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = pd.melt(df, id_vars=['Title'], value_vars=['Budget_million', 'Gross_worldwide'], var_name='Measure', value_name='Value')\n\nchart = alt.Chart(df_melted).mark_line(color=\"#db646f\").encode(\n    y=alt.Y('Title:N'),\n    x=alt.X('Value:Q'),\n    detail='Title:N'\n)\n\npoints = alt.Chart(df_melted).mark_point(\n    size=100,\n    opacity=1,\n    filled=True,\n).encode(\n    y=alt.Y('Title:N'),\n    x=alt.X('Value:Q'),\n    color=alt.Color('Measure:N').scale(domain=['Budget_million', 'Gross_worldwide'], range=[\"#e6959c\", \"#911a24\"])\n)\n\nfinal_chart = (chart + points)\nfinal_chart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___ranged_dot_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "customers_and_addresses",
        "chart_category": "Advanced Calculations",
        "chart_type": "sorted_error_bars_showing_confidence_interval",
        "NLQ": "I have this chart showing crop yields for different varieties, but I'd like to create a similar chart using my customer database instead. Can you make a chart that shows the average order quantity for each product, with those horizontal lines showing the confidence intervals? Make sure the products are sorted from highest to lowest average order quantity, use filled black dots for the points, and give it a proper title like \"Average Order Quantity\" on the x-axis. Could you also make the chart a bit wider and taller, maybe around 400 by 250?",
        "code": "import altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/customers_and_addresses.sqlite')\nquery = \"\"\"\nSELECT\n    P.product_details,\n    OI.order_quantity\nFROM Order_Items AS OI\nJOIN Products AS P\n    ON OI.product_id = P.product_id;\n\"\"\"\ndf = pd.read_sql_query(query, conn)\ndf['order_quantity'] = pd.to_numeric(df['order_quantity'])\nconn.close()\n\npoints = alt.Chart(df).mark_point(\n    filled=True,\n    color='black'\n).encode(\n    x=alt.X('mean(order_quantity)').title('Average Order Quantity'),\n    y=alt.Y('product_details').sort(\n        field='order_quantity',\n        op='mean',\n        order='descending'\n    )\n).properties(\n    width=400,\n    height=250\n)\n\nerror_bars = points.mark_rule().encode(\n    x='ci0(order_quantity)',\n    x2='ci1(order_quantity)',\n)\n\npoints + error_bars",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___sorted_error_bars_showing_confidence_interval.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "customers_and_addresses",
        "chart_category": "Advanced Calculations",
        "chart_type": "sorted_error_bars_showing_confidence_interval",
        "NLQ": "I noticed my code creates a chart showing barley yield for different varieties with error bars. Could you make something similar but use data from our customer database instead? I'd like to see the average order quantity for each product, sorted from highest to lowest. Keep the black dots and those horizontal lines showing the confidence intervals, just like in my original chart. Also, can you label the x-axis as \"Average Order Quantity\" instead of \"Barley Yield\"?",
        "code": "import altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/customers_and_addresses.sqlite')\n\nquery = \"\"\"\nSELECT\n    P.product_details,\n    OI.order_quantity\nFROM Order_Items AS OI\nJOIN Products AS P\n    ON OI.product_id = P.product_id;\n\"\"\"\n\ndf = pd.read_sql_query(query, conn)\ndf['order_quantity'] = pd.to_numeric(df['order_quantity'])\n\nconn.close()\n\npoints = alt.Chart(df).mark_point(\n    filled=True,\n    color='black'\n).encode(\n    x=alt.X('mean(order_quantity)').title('Average Order Quantity'),\n    y=alt.Y('product_details').sort(\n        field='order_quantity',\n        op='mean',\n        order='descending'\n    )\n).properties(\n    width=400,\n    height=250\n)\n\nerror_bars = points.mark_rule().encode(\n    x='ci0(order_quantity)',\n    x2='ci1(order_quantity)',\n)\n\npoints + error_bars",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___sorted_error_bars_showing_confidence_interval.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "customers_and_invoices",
        "chart_category": "Advanced Calculations",
        "chart_type": "sorted_error_bars_showing_confidence_interval",
        "NLQ": "Can you create a chart showing the average derived total cost for each product from our customer database? I'd like to see the products sorted from highest to lowest cost, with black dots showing the average and lines showing the confidence interval for each product. Make the chart about 400 pixels wide by 250 pixels tall, and label the x-axis as \"Average Derived Total Cost\" instead of just showing the raw values.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/customers_and_invoices.sqlite')\n\nquery = '''\nSELECT product_title, derived_total_cost\nFROM Invoice_Line_Items\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\npoints = alt.Chart(df).mark_point(\n    filled=True,\n    color='black'\n).encode(\n    x=alt.X('mean(derived_total_cost)').title('Average Derived Total Cost'),\n    y=alt.Y('product_title').sort(\n        field='derived_total_cost',\n        op='mean',\n        order='descending'\n    )\n).properties(\n    width=400,\n    height=250\n)\n\nerror_bars = points.mark_rule().encode(\n    x='ci0(derived_total_cost)',\n    x2='ci1(derived_total_cost)',\n)\n\npoints + error_bars",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___sorted_error_bars_showing_confidence_interval.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "customers_and_invoices",
        "chart_category": "Advanced Calculations",
        "chart_type": "sorted_error_bars_showing_confidence_interval",
        "NLQ": "I'd like to switch from matplotlib to Altair for my visualization. Instead of showing barley yields by variety, I want to display the average derived total cost for each product from my database. Can you pull this data from my SQLite database called 'customers_and_invoices.sqlite'? Keep the same style with black points and horizontal error bars showing the confidence intervals, and sort the products from highest to lowest average cost. Make sure the chart has a reasonable width and height, and label the x-axis as \"Average Derived Total Cost\".",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/customers_and_invoices.sqlite')\n\nquery = '''\nSELECT product_title, derived_total_cost\nFROM Invoice_Line_Items\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\npoints = alt.Chart(df).mark_point(\n    filled=True,\n    color='black'\n).encode(\n    x=alt.X('mean(derived_total_cost)').title('Average Derived Total Cost'),\n    y=alt.Y('product_title').sort(\n        field='derived_total_cost',\n        op='mean',\n        order='descending'\n    )\n).properties(\n    width=400,\n    height=250\n)\n\nerror_bars = points.mark_rule().encode(\n    x='ci0(derived_total_cost)',\n    x2='ci1(derived_total_cost)',\n)\n\npoints + error_bars",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___sorted_error_bars_showing_confidence_interval.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "customer_deliveries",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_items",
        "NLQ": "Instead of showing movie ratings, can you create a chart that shows the top 5 most expensive products from our customer deliveries database? I'd like to see the product names and their prices as bars, sorted from highest to lowest price. Also, could you add color to the bars that changes based on the price values? Just pull the data directly from the database instead of using random values.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customer_deliveries.sqlite')\n\nquery = '''\nSELECT product_name, product_price\nFROM Products\nORDER BY product_price DESC\nLIMIT 5\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X('product_name:N').sort('-y'),\n    alt.Y('product_price:Q'),\n    alt.Color('product_price:Q')\n).transform_window(\n    rank='rank(product_price)',\n    sort=[alt.SortField('product_price', order='descending')]\n).transform_filter(\n    (alt.datum.rank < 6)\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___top_k_items.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "customer_deliveries",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_items",
        "NLQ": "Instead of showing movie ratings from my dataset, could you create a chart that shows the top 5 most expensive products from my customer deliveries database? I'd like to keep the same style with colored bars sorted from highest to lowest price, but use the product names and prices from my SQLite database instead of the movie data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/customer_deliveries.sqlite')\nquery = '''\nSELECT product_name, product_price\nFROM Products\nORDER BY product_price DESC\nLIMIT 5\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X('product_name:N').sort('-y'),\n    alt.Y('product_price:Q'),\n    alt.Color('product_price:Q')\n).transform_window(\n    rank='rank(product_price)',\n    sort=[alt.SortField('product_price', order='descending')]\n).transform_filter(\n    (alt.datum.rank < 6)\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___top_k_items.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "debate",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_items",
        "NLQ": "Can you help me make a chart that shows the top 5 debate venues by audience size? I'd like the bars to be sorted from highest to lowest, use a color gradient to highlight the audience size, and include a title that says 'Top 5 Debates by Audience Size'. I need to pull this data from my debate database instead of using the movie ratings data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/debate.sqlite')\n\nquery = '''\nSELECT Debate_ID, Venue, Date, Num_of_Audience\nFROM debate\nORDER BY Num_of_Audience DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X('Venue:N').sort('-y'),\n    alt.Y('Num_of_Audience:Q', title='Number of Audience'),\n    alt.Color('Num_of_Audience:Q', title='Audience Size')\n).transform_window(\n    rank='rank(Num_of_Audience)',\n    sort=[alt.SortField('Num_of_Audience', order='descending')]\n).transform_filter(\n    (alt.datum.rank < 6)\n).properties(\n    title='Top 5 Debates by Audience Size'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Advanced Calculations___top_k_items.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "debate",
        "chart_category": "Advanced Calculations",
        "chart_type": "top_k_items",
        "NLQ": "Can you change my movie ratings chart to show debate data instead? I'd like to see the top 5 debate venues with the largest audience sizes. Sort the bars by audience size, keep the color gradient for the bars, and add a title that says \"Top 5 Debates by Audience Size\". Also, can you pull this data directly from my debate database instead of using random numbers?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/debate.sqlite')\n\nquery = '''\nSELECT Debate_ID, Venue, Date, Num_of_Audience\nFROM debate\nORDER BY Num_of_Audience DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X('Venue:N').sort('-y'),\n    alt.Y('Num_of_Audience:Q', title='Number of Audience'),\n    alt.Color('Num_of_Audience:Q', title='Audience Size')\n).transform_window(\n    rank='rank(Num_of_Audience)',\n    sort=[alt.SortField('Num_of_Audience', order='descending')]\n).transform_filter(\n    (alt.datum.rank < 6)\n).properties(\n    title='Top 5 Debates by Audience Size'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Advanced Calculations___top_k_items.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "device",
        "chart_category": "Distributions",
        "chart_type": "faceted_histogram",
        "NLQ": "Can you create a chart that shows the distribution of device quantities grouped by software platform? I'd like to see a histogram with separate rows for each platform type, similar to how the original chart showed car horsepower by country of origin. But instead of using the sample data, please pull the actual device and stock information from our SQLite database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/device.sqlite')\n\nquery = '''\nSELECT \n    d.Software_Platform, \n    s.Quantity\nFROM \n    stock AS s\nJOIN \n    device AS d ON s.Device_ID = d.Device_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"Quantity:Q\").bin(),\n    y=\"count()\",\n    row=\"Software_Platform:N\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___faceted_histogram.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "device",
        "chart_category": "Distributions",
        "chart_type": "faceted_histogram",
        "NLQ": "Can you create a chart that shows the distribution of device quantities in our inventory database? I'd like to see separate histograms for each software platform, stacked vertically like panels. For each platform, show how many devices fall into different quantity ranges. Make it similar to that car horsepower chart I have, but use our device database instead of the sample data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/device.sqlite')\n\nquery = '''\nSELECT \n    d.Software_Platform, \n    s.Quantity\nFROM \n    stock AS s\nJOIN \n    device AS d ON s.Device_ID = d.Device_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"Quantity:Q\").bin(),\n    y=\"count()\",\n    row=\"Software_Platform:N\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___faceted_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "dog_kennels",
        "chart_category": "Distributions",
        "chart_type": "faceted_histogram",
        "NLQ": "Instead of using the car horsepower data, can you create a similar chart using our dog kennel database? I'd like to see the treatment costs grouped into ranges and count how many treatments fall into each cost range, with separate rows for each treatment type. Keep the same bar chart style, but use the treatment data from our database instead.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/dog_kennels.sqlite')\n\nquery = '''\nSELECT \n    T1.treatment_type_description AS treatment_type,\n    T2.cost_of_treatment AS cost\nFROM \n    Treatment_Types AS T1\nJOIN \n    Treatments AS T2\nON \n    T1.treatment_type_code = T2.treatment_type_code\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"cost:Q\").bin(),\n    y=\"count()\",\n    row=\"treatment_type:N\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___faceted_histogram.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "dog_kennels",
        "chart_category": "Distributions",
        "chart_type": "faceted_histogram",
        "NLQ": "I have data about dog kennel treatments in a database. Can you create a chart that shows the distribution of treatment costs? I'd like to see how many treatments fall into different cost ranges, with separate histograms for each treatment type. Please use the treatment_type_description from the Treatment_Types table and the cost_of_treatment from the Treatments table in the dog_kennels database. Make it similar to those stacked histograms I've seen before, but organize them in rows by treatment type.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/dog_kennels.sqlite')\nquery = '''\nSELECT \n    T1.treatment_type_description AS treatment_type,\n    T2.cost_of_treatment AS cost\nFROM \n    Treatment_Types AS T1\nJOIN \n    Treatments AS T2\nON \n    T1.treatment_type_code = T2.treatment_type_code\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\nchart = alt.Chart(df).mark_bar().encode(\n    alt.X(\"cost:Q\").bin(),\n    y=\"count()\",\n    row=\"treatment_type:N\"\n)\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___faceted_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "driving_school",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_sequence_generator",
        "NLQ": "Can you create a line chart that shows the cumulative total of customer payments over time? I'd like to see how payments add up by date, with different colored lines for each payment method. Please pull this data from our driving school database, showing payment dates on the x-axis and the running total amount on the y-axis. Make sure to label the axes properly with \"Payment Date\" and \"Cumulative Payment Amount\" and include a legend that shows the different payment methods.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/driving_school.sqlite')\nquery = '''\nSELECT \n    DATE(datetime_payment) AS payment_date,\n    payment_method_code,\n    SUM(amount_payment) AS total_payment\nFROM \n    Customer_Payments\nGROUP BY \n    payment_date, payment_method_code\nORDER BY \n    payment_date\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nline_chart = alt.Chart(df).mark_line().encode(\n    x=alt.X('payment_date:T', title='Payment Date'),\n    y=alt.Y('sum(total_payment):Q', title='Cumulative Payment Amount'),\n    color=alt.Color('payment_method_code:N', title='Payment Method')\n).transform_window(\n    cumulative_sum='sum(total_payment)',\n    frame=[None, 0],\n    groupby=['payment_method_code']\n).encode(\n    y=alt.Y('cumulative_sum:Q', title='Cumulative Payment Amount')\n)\n\nline_chart",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_sequence_generator.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "driving_school",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_sequence_generator",
        "NLQ": "Instead of the sine and cosine graph, could you create a chart that shows how the total payments from customers change over time? I'd like to see cumulative payment amounts over time, split by payment method, with different colored lines for each payment method. Get the data from our driving school database and use the payment dates on the x-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/driving_school.sqlite')\n\nquery = '''\nSELECT \n    DATE(datetime_payment) AS payment_date,\n    payment_method_code,\n    SUM(amount_payment) AS total_payment\nFROM \n    Customer_Payments\nGROUP BY \n    payment_date, payment_method_code\nORDER BY \n    payment_date\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nline_chart = alt.Chart(df).mark_line().encode(\n    x=alt.X('payment_date:T', title='Payment Date'),\n    y=alt.Y('sum(total_payment):Q', title='Cumulative Payment Amount'),\n    color=alt.Color('payment_method_code:N', title='Payment Method')\n).transform_window(\n    cumulative_sum='sum(total_payment)',\n    frame=[None, 0],\n    groupby=['payment_method_code']\n).encode(\n    y=alt.Y('cumulative_sum:Q', title='Cumulative Payment Amount')\n)\n\nline_chart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_sequence_generator.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "election_representative",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_a_global_mean_overlay",
        "NLQ": "Can you create a histogram showing the distribution of vote percentages from our election database? I'd like to see the frequency of different vote percentages with bins that aren't too narrow or wide. Please add a thick red line showing the average vote percentage, and make sure the axes are labeled as \"Vote Percentage\" and \"Frequency\".",
        "code": "import altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/election_representative.sqlite')\n\nquery = '''\nSELECT Vote_Percent\nFROM election;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df)\n\nbar = base.mark_bar().encode(\n    alt.X('Vote_Percent:Q', bin=alt.Bin(maxbins=30), title='Vote Percentage'),\n    alt.Y('count()', title='Frequency')\n)\n\nrule = base.mark_rule(color='red').encode(\n    alt.X('mean(Vote_Percent):Q', title='Average Vote Percentage'),\n    size=alt.value(5)\n)\n\nchart = bar + rule\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___histogram_with_a_global_mean_overlay.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "election_representative",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_a_global_mean_overlay",
        "NLQ": "Instead of using the IMDB ratings data with a simple histogram, could you create a chart showing the distribution of vote percentages from our election database? I'd like to see a histogram with about 30 bins that shows the frequency of different vote percentages. Please keep the red line showing the average vote percentage, and make it a bit thicker so it stands out. Also, can you label the x-axis as \"Vote Percentage\" and the y-axis as \"Frequency\"?",
        "code": "import altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/election_representative.sqlite')\nquery = '''\nSELECT Vote_Percent\nFROM election;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df)\nbar = base.mark_bar().encode(\n    alt.X('Vote_Percent:Q', bin=alt.Bin(maxbins=30), title='Vote Percentage'),\n    alt.Y('count()', title='Frequency')\n)\nrule = base.mark_rule(color='red').encode(\n    alt.X('mean(Vote_Percent):Q', title='Average Vote Percentage'),\n    size=alt.value(5)\n)\nchart = bar + rule\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___histogram_with_a_global_mean_overlay.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "election_representative",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_stroked_point_markers",
        "NLQ": "Instead of using the stock price data I created before, can you make a line chart that shows how the number of votes changes over time for each political party? I need to pull this data from my election database. The chart should still have those little dots on the lines and use different colors for each party. Also, please add a title that says \"Votes Trend Over Time by Party\" at the top of the chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/election_representative.sqlite')\nquery = '''\nSELECT E.Date, E.Votes, R.Party\nFROM election AS E\nJOIN representative AS R ON E.Representative_ID = R.Representative_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndef convert_to_datetime(date_str):\n    try:\n        return pd.to_datetime(date_str, format='%B %Y')\n    except ValueError:\n        try:\n            return pd.to_datetime(date_str, format='%Y')\n        except ValueError:\n            try:\n                return pd.to_datetime(date_str)\n            except:\n                return pd.to_datetime(date_str + ' January 1', format='%Y %B %d')\ndf['Date'] = df['Date'].apply(convert_to_datetime)\n\nalt.Chart(df).mark_line(point=True).encode(\n    x='Date:T',\n    y='Votes:Q',\n    color='Party:N'\n).properties(\n    title='Votes Trend Over Time by Party'\n)",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_stroked_point_markers.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "election_representative",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_stroked_point_markers",
        "NLQ": "Instead of using my stock price data, can you create a line chart that shows how the number of votes changes over time for each political party? I need to pull this data from my election database. Make sure to add dots at each data point on the lines and give the chart a title that says \"Votes Trend Over Time by Party\". Each party should be shown in different colors so it's easy to tell them apart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/election_representative.sqlite')\n\nquery = '''\nSELECT E.Date, E.Votes, R.Party\nFROM election AS E\nJOIN representative AS R ON E.Representative_ID = R.Representative_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndef convert_to_datetime(date_str):\n    try:\n        return pd.to_datetime(date_str, format='%B %Y')\n    except ValueError:\n        try:\n            return pd.to_datetime(date_str, format='%Y')\n        except ValueError:\n            try:\n                return pd.to_datetime(date_str)\n            except:\n                return pd.to_datetime(date_str + ' January 1', format='%Y %B %d')\ndf['Date'] = df['Date'].apply(convert_to_datetime)\n\nalt.Chart(df).mark_line(point=True).encode(\n    x='Date:T',\n    y='Votes:Q',\n    color='Party:N'\n).properties(\n    title='Votes Trend Over Time by Party'\n)",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_stroked_point_markers.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "employee_hire_evaluation",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_a_global_mean_overlay",
        "NLQ": "Can you change this chart to show employee ages instead of IMDB ratings? I need to pull the data from our employee database instead of using random numbers. Please add tooltips so I can see the count and age when I hover over the bars. Also, make the line showing the average thicker and red so it stands out better. And can you add a proper label for the x-axis that says \"Employee Age\"?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/employee_hire_evaluation.sqlite')\nquery = \"SELECT Age FROM employee;\"\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df)\nbar = base.mark_bar().encode(\n    alt.X('Age:Q', bin=alt.Bin(maxbins=30), title='Employee Age'),\n    y='count()',\n    tooltip=['count()', 'Age']\n)\nrule = base.mark_rule(color='red').encode(\n    x='mean(Age):Q',\n    size=alt.value(5)\n)\nchart = bar + rule\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___histogram_with_a_global_mean_overlay.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "employee_hire_evaluation",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_a_global_mean_overlay",
        "NLQ": "Can you change this movie ratings histogram to show employee ages from our database instead? I'd like to keep the same style with the bars and the red line showing the average. Also, can you make it interactive so I can see the count and age when I hover over the bars? Maybe use about 30 bins for better detail.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/employee_hire_evaluation.sqlite')\nquery = \"SELECT Age FROM employee;\"\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df)\n\nbar = base.mark_bar().encode(\n    alt.X('Age:Q', bin=alt.Bin(maxbins=30), title='Employee Age'),\n    y='count()',\n    tooltip=['count()', 'Age']\n)\n\nrule = base.mark_rule(color='red').encode(\n    x='mean(Age):Q',\n    size=alt.value(5)\n)\n\nchart = bar + rule\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___histogram_with_a_global_mean_overlay.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "entrepreneur",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_gradient_color",
        "NLQ": "Can you create a histogram showing the distribution of weights from the people table in my entrepreneur database? I'd like to see how frequently different weight values occur, with about 20 bins. Also, please use a pink-yellow-green color gradient for the bars instead of the default colors.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/entrepreneur.sqlite')\n\nquery = '''\nSELECT Weight\nFROM people\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nalt.Chart(df).mark_bar().encode(\n    alt.X(\"Weight:Q\").bin(maxbins=20),\n    alt.Y('count()'),\n    alt.Color(\"Weight:Q\").bin(maxbins=20).scale(scheme='pinkyellowgreen')\n)",
        "reference_path": "./vis_bench/code/altair/Distributions___histogram_with_gradient_color.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "entrepreneur",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_gradient_color",
        "NLQ": "Can you create a histogram showing the distribution of weights from our entrepreneur database? I'd like to use about 20 bins and color them with a pink-yellow-green gradient. Instead of using matplotlib like in the example, let's use Altair for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/entrepreneur.sqlite')\nquery = '''\nSELECT Weight\nFROM people\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nalt.Chart(df).mark_bar().encode(\n    alt.X(\"Weight:Q\").bin(maxbins=20),\n    alt.Y('count()'),\n    alt.Color(\"Weight:Q\").bin(maxbins=20).scale(scheme='pinkyellowgreen')\n)",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___histogram_with_gradient_color.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "epinions_1",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_varying_size",
        "NLQ": "I have this chart showing wheat production over time with a trail visualization. Could you help me create a similar graph but for user trust data from my database instead? I'd like to show source user IDs on the x-axis and their trust ratings on the y-axis, with thicker lines representing stronger trust relationships. Please add proper titles for the axes and the size legend too.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/epinions_1.sqlite')\n\nquery = '''\nSELECT \n    T.source_u_id AS source_user,\n    T.trust AS trust_rating\nFROM \n    trust AS T\nORDER BY \n    T.source_u_id\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_trail().encode(\n    x=alt.X('source_user:O', title='Source User ID'),\n    y=alt.Y('trust_rating:Q', title='Trust Rating'),\n    size=alt.Size('trust_rating:Q', title='Strength of Trust')\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_varying_size.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "epinions_1",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_varying_size",
        "NLQ": "I have this visualization showing wheat production over years with varying line thickness, but I'd like to change it completely. Could you help me create a graph that shows how much people trust each other, using a similar style with varying line thickness? I'd like to pull data from my SQLite database about trust ratings between users, and display each person's ID on one side and their trust ratings on the other, with thicker lines for stronger trust levels. Instead of matplotlib, can you use Altair for this?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/epinions_1.sqlite')\n\nquery = '''\nSELECT \n    T.source_u_id AS source_user,\n    T.trust AS trust_rating\nFROM \n    trust AS T\nORDER BY \n    T.source_u_id\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_trail().encode(\n    x=alt.X('source_user:O', title='Source User ID'),\n    y=alt.Y('trust_rating:Q', title='Trust Rating'),\n    size=alt.Size('trust_rating:Q', title='Strength of Trust')\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_varying_size.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "e_learning",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_responsive_bins",
        "NLQ": "I have data on student registrations by hour from our e-learning database. Can you create a chart showing how many students sign up during each hour of the day? I'd like it to have two parts - one on top that can zoom in on specific time periods, and one below showing the full 24-hour distribution. Make the charts wider (about 600px) but not too tall (around 100px each). Instead of using random data like in my example, please pull the actual registration counts from our SQLite database and group them by hour.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/e_learning.sqlite')\n\nquery = '''\nSELECT \n    strftime('%H', date_of_registration) AS hour_of_registration,\n    COUNT(*) AS registration_count\nFROM Students\nGROUP BY hour_of_registration\nORDER BY hour_of_registration\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval(encodings=['x'])\n\nbase = alt.Chart(df).mark_bar().encode(\n    y='registration_count:Q'\n).properties(\n    width=600,\n    height=100\n)\n\nchart = alt.vconcat(\n    base.encode(\n        alt.X('hour_of_registration:Q')\n          .bin(maxbins=24, extent=brush)\n          .scale(domain=brush),\n        y='registration_count:Q'\n    ),\n    base.encode(\n        alt.X('hour_of_registration:Q').bin(maxbins=24),\n        y='registration_count:Q'\n    ).add_params(brush)\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___histogram_with_responsive_bins.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "e_learning",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_responsive_bins",
        "NLQ": "Can you create a chart showing student registrations by hour of the day using real data from our e-learning database instead of random data? I'd like to keep the interactive zoom feature where I can select a time range to focus on, but make it cleaner and simpler. Let's use Altair instead of Matplotlib for a more modern look.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/e_learning.sqlite')\n\nquery = '''\nSELECT \n    strftime('%H', date_of_registration) AS hour_of_registration,\n    COUNT(*) AS registration_count\nFROM Students\nGROUP BY hour_of_registration\nORDER BY hour_of_registration\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval(encodings=['x'])\n\nbase = alt.Chart(df).mark_bar().encode(\n    y='registration_count:Q'\n).properties(\n    width=600,\n    height=100\n)\n\nchart = alt.vconcat(\n    base.encode(\n        alt.X('hour_of_registration:Q')\n          .bin(maxbins=24, extent=brush)\n          .scale(domain=brush),\n        y='registration_count:Q'\n    ),\n    base.encode(\n        alt.X('hour_of_registration:Q').bin(maxbins=24),\n        y='registration_count:Q'\n    ).add_params(brush)\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___histogram_with_responsive_bins.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "farm",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_responsive_bins",
        "NLQ": "Using the code I shared as a starting point, can you create a chart that shows how many farms have certain numbers of cattle instead of using random time data? I'd like to keep the same interactive two-section layout where I can select ranges in the bottom chart to zoom in on the top chart. Please connect to our farm database and use the Total_Cattle column from the farm table. Also, make the charts a bit wider - about 600 pixels should work well.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/farm.sqlite')\n\nquery = '''\nSELECT Total_Cattle\nFROM farm\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval(encodings=['x'])\n\nbase = alt.Chart(df).mark_bar().encode(\n    y='count():Q'\n).properties(\n    width=600,\n    height=100\n)\n\nchart = alt.vconcat(\n    base.encode(\n        alt.X('Total_Cattle:Q')\n            .bin(maxbins=30, extent=brush)\n            .scale(domain=brush)\n    ),\n    base.encode(\n        alt.X('Total_Cattle:Q').bin(maxbins=30),\n    ).add_params(brush)\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___histogram_with_responsive_bins.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "farm",
        "chart_category": "Distributions",
        "chart_type": "histogram_with_responsive_bins",
        "NLQ": "Can you create a chart that shows the distribution of cattle across farms? I'd like to see a histogram with two panels stacked vertically, where I can select a range in the bottom panel to zoom in on that specific range in the top panel. Instead of using matplotlib, could you use Altair for this visualization and connect it to my farm database to pull the Total_Cattle data? Keep the interactive brushing feature so I can explore different ranges of the data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/farm.sqlite')\n\nquery = '''\nSELECT Total_Cattle\nFROM farm\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval(encodings=['x'])\n\nbase = alt.Chart(df).mark_bar().encode(\n    y='count():Q'\n).properties(\n    width=600,\n    height=100\n)\n\nchart = alt.vconcat(\n    base.encode(\n        alt.X('Total_Cattle:Q')\n            .bin(maxbins=30, extent=brush)\n            .scale(domain=brush)\n    ),\n    base.encode(\n        alt.X('Total_Cattle:Q').bin(maxbins=30),\n    ).add_params(brush)\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___histogram_with_responsive_bins.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "farm",
        "chart_category": "Line Charts",
        "chart_type": "multiple_series_line_chart",
        "NLQ": "I have this chart showing stock prices for Apple, Google, and Microsoft over a few days in January 2023. Could you change it to show the total number of horses and cattle on a farm over different years instead? I'd like to pull this data from my farm database rather than using random numbers. Keep the same line chart style with different colors for each animal type.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/farm.sqlite')\n\nquery = '''\nSELECT Year, Total_Horses, Total_Cattle\nFROM farm\nORDER BY Year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['Year'], value_vars=['Total_Horses', 'Total_Cattle'], \n                    var_name='Animal_Type', value_name='Count')\n\nchart = alt.Chart(df_melted).mark_line().encode(\n    x='Year:T',\n    y='Count:Q',\n    color='Animal_Type:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Line Charts___multiple_series_line_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "farm",
        "chart_category": "Line Charts",
        "chart_type": "multiple_series_line_chart",
        "NLQ": "I have this stock price chart showing AAPL, GOOG, and MSFT prices over a few days in January 2023. Could you change it to show the total number of horses and cattle on a farm over multiple years instead? I'd like to pull this data from my farm database rather than using the random stock data. Keep the same line chart style with different colors for each animal type, but use Altair instead of Matplotlib for creating the visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/farm.sqlite')\n\nquery = '''\nSELECT Year, Total_Horses, Total_Cattle\nFROM farm\nORDER BY Year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['Year'], value_vars=['Total_Horses', 'Total_Cattle'], \n                    var_name='Animal_Type', value_name='Count')\n\nchart = alt.Chart(df_melted).mark_line().encode(\n    x='Year:T',\n    y='Count:Q',\n    color='Animal_Type:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___multiple_series_line_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "game_injury",
        "chart_category": "Line Charts",
        "chart_type": "step_chart",
        "NLQ": "Can you create a chart showing the total number of injuries per season from my game injury database? I'd like to see a step chart where the line jumps at each season change, with clear labels for seasons on the x-axis and injury counts on the y-axis. Please title it \"Total Injuries Per Season\" and make sure the visualization clearly shows how injury numbers change from one season to the next.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/game_injury.sqlite')\n\nquery = '''\nSELECT \n    g.Season AS season,\n    COUNT(i.id) AS injury_count\nFROM \n    game AS g\nJOIN \n    injury_accident AS i ON g.id = i.game_id\nGROUP BY \n    g.Season\nORDER BY \n    g.Season\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line(interpolate='step-after').encode(\n    x=alt.X('season:O', title='Season'),\n    y=alt.Y('injury_count:Q', title='Total Injuries')\n).properties(\n    title='Total Injuries Per Season'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___step_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "game_injury",
        "chart_category": "Line Charts",
        "chart_type": "step_chart",
        "NLQ": "Can you create a step chart showing the total number of injuries per season from our game injury database? I'd like to see how injuries trend across different seasons, with a clear title \"Total Injuries Per Season\" and properly labeled axes. Please make sure the x-axis shows the seasons and the y-axis shows the injury counts. I want the visualization to use step lines that change at the end of each season rather than connecting points directly.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/game_injury.sqlite')\nquery = '''\nSELECT \n    g.Season AS season,\n    COUNT(i.id) AS injury_count\nFROM \n    game AS g\nJOIN \n    injury_accident AS i ON g.id = i.game_id\nGROUP BY \n    g.Season\nORDER BY \n    g.Season\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\nchart = alt.Chart(df).mark_line(interpolate='step-after').encode(\n    x=alt.X('season:O', title='Season'),\n    y=alt.Y('injury_count:Q', title='Total Injuries')\n).properties(\n    title='Total Injuries Per Season'\n)\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___step_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "game_injury",
        "chart_category": "Distributions",
        "chart_type": "quantile-quantile_plot",
        "NLQ": "Instead of using random normal data, could you create QQ plots using real stadium attendance data from my database? I'd like to see two side-by-side charts comparing Average Attendance and Total Attendance against a uniform distribution. Please add clear titles to each chart showing what's being compared, and label the axes properly so I can understand what the quantiles represent.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/game_injury.sqlite')\nquery = '''\nSELECT Average_Attendance, Total_Attendance\nFROM stadium\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase_avg_attendance = alt.Chart(df).transform_quantile(\n    'Average_Attendance',\n    step=0.01,\n    as_ = ['p', 'v']\n).transform_calculate(\n    uniform = 'quantileUniform(datum.p)'\n).mark_point().encode(\n    alt.Y('v:Q', title='Average Attendance Quantiles'),\n    alt.X('uniform:Q', title='Uniform Distribution Quantiles')\n).properties(\n    title='QQ-Plot of Average Attendance vs. Uniform Distribution'\n)\n\nbase_total_attendance = alt.Chart(df).transform_quantile(\n    'Total_Attendance',\n    step=0.01,\n    as_ = ['p', 'v']\n).transform_calculate(\n    uniform = 'quantileUniform(datum.p)'\n).mark_point().encode(\n    alt.Y('v:Q', title='Total Attendance Quantiles'),\n    alt.X('uniform:Q', title='Uniform Distribution Quantiles')\n).properties(\n    title='QQ-Plot of Total Attendance vs. Uniform Distribution'\n)\n\nchart = base_avg_attendance | base_total_attendance\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___quantile-quantile_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "game_injury",
        "chart_category": "Distributions",
        "chart_type": "quantile-quantile_plot",
        "NLQ": "Could you create a visualization that shows QQ-plots for stadium attendance data from our database? I'd like to see two charts side by side - one showing Average Attendance and the other showing Total Attendance - both compared against a uniform distribution. Please use Altair instead of matplotlib, add proper titles to each chart, and make sure the axes are clearly labeled with \"Uniform Distribution Quantiles\" on the x-axis and the appropriate attendance quantiles on the y-axis.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/game_injury.sqlite')\n\nquery = '''\nSELECT Average_Attendance, Total_Attendance\nFROM stadium\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase_avg_attendance = alt.Chart(df).transform_quantile(\n    'Average_Attendance',\n    step=0.01,\n    as_=['p', 'v']\n).transform_calculate(\n    uniform='quantileUniform(datum.p)'\n).mark_point().encode(\n    alt.Y('v:Q', title='Average Attendance Quantiles'),\n    alt.X('uniform:Q', title='Uniform Distribution Quantiles')\n).properties(\n    title='QQ-Plot of Average Attendance vs. Uniform Distribution'\n)\n\nbase_total_attendance = alt.Chart(df).transform_quantile(\n    'Total_Attendance',\n    step=0.01,\n    as_=['p', 'v']\n).transform_calculate(\n    uniform='quantileUniform(datum.p)'\n).mark_point().encode(\n    alt.Y('v:Q', title='Total Attendance Quantiles'),\n    alt.X('uniform:Q', title='Uniform Distribution Quantiles')\n).properties(\n    title='QQ-Plot of Total Attendance vs. Uniform Distribution'\n)\n\nchart = base_avg_attendance | base_total_attendance\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___quantile-quantile_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "insurance_and_eClaims",
        "chart_category": "Scatter Plots",
        "chart_type": "brushing_scatter_plot_to_show_data_on_a_table",
        "NLQ": "Can you change my car performance chart to show insurance claim data instead? I want to see the relationship between the amount claimed and amount paid, with a scatter plot that still has those interactive blue dots. Instead of showing horsepower, MPG and origin in the side table, I'd like to see claim type and settlement date. Also, can you make the chart a bit bigger and add tooltips so I can see more details when I hover over the dots?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_and_eClaims.sqlite')\n\nquery = '''\nSELECT \n    ch.Claim_Header_ID,\n    ch.Amount_Claimed,\n    ch.Amount_Piad AS Amount_Paid,\n    ch.Claim_Type_Code,\n    ch.Date_of_Settlement\nFROM \n    Claim_Headers AS ch\nWHERE \n    ch.Amount_Claimed IS NOT NULL AND ch.Amount_Piad IS NOT NULL\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(df).mark_point().encode(\n    x=alt.X('Amount_Claimed:Q', title='Amount Claimed'),\n    y=alt.Y('Amount_Paid:Q', title='Amount Paid'),\n    color=alt.condition(brush, alt.value(\"steelblue\"), alt.value(\"grey\")),\n    tooltip=['Claim_Type_Code:N', 'Date_of_Settlement:T']\n).add_params(brush).properties(\n    width=400,\n    height=400\n)\n\nranked_text = alt.Chart(df).mark_text(align='right').encode(\n    y=alt.Y('row_number:O').axis(None)\n).transform_filter(\n    brush\n).transform_window(\n    row_number='row_number()'\n).transform_filter(\n    alt.datum.row_number < 15\n)\n\nclaim_type = ranked_text.encode(text='Claim_Type_Code:N').properties(\n    title=alt.Title(text='Claim Type', align='right')\n)\nsettlement_date = ranked_text.encode(text='Date_of_Settlement:T').properties(\n    title=alt.Title(text='Settlement Date', align='right')\n)\ntext = alt.hconcat(claim_type, settlement_date)\n\nchart = alt.hconcat(\n    points,\n    text\n).resolve_legend(\n    color=\"independent\"\n).configure_view(\n    stroke=None\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___brushing_scatter_plot_to_show_data_on_a_table.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "insurance_fnol",
        "chart_category": "Scatter Plots",
        "chart_type": "bubble_plot",
        "NLQ": "Can you create a bubble chart using our insurance claims database instead of the car data? I'd like to see how many claims each customer has made on the x-axis, their total settlement amount on the y-axis, and use the bubble size to show the average time it takes to settle their claims. Please add a title \"Claims vs. Settlements with Average Settlement Time\" and make it so I can hover over each bubble to see the customer name and all their details.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_fnol.sqlite')\n\nquery = '''\nSELECT \n    c.Customer_name AS Customer,\n    COUNT(cl.Claim_ID) AS Number_of_Claims,\n    SUM(s.Settlement_Amount) AS Total_Settlement_Amount,\n    AVG(julianday(s.Effective_Date) - julianday(cl.Effective_Date)) AS Avg_Settlement_Time\nFROM \n    Customers AS c\nJOIN \n    First_Notification_of_Loss AS fnol ON c.Customer_ID = fnol.Customer_ID\nJOIN \n    Claims AS cl ON fnol.FNOL_ID = cl.FNOL_ID\nJOIN \n    Settlements AS s ON cl.Claim_ID = s.Claim_ID\nGROUP BY \n    c.Customer_name\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_point().encode(\n    x='Number_of_Claims:Q',\n    y='Total_Settlement_Amount:Q',\n    size='Avg_Settlement_Time:Q',\n    tooltip=['Customer:N', 'Number_of_Claims:Q', 'Total_Settlement_Amount:Q', 'Avg_Settlement_Time:Q']\n).properties(\n    title=\"Claims vs. Settlements with Average Settlement Time\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___bubble_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "insurance_fnol",
        "chart_category": "Scatter Plots",
        "chart_type": "bubble_plot",
        "NLQ": "Can you create a scatter plot using my insurance claims database instead of the car data? I'd like to see how many claims each customer has made on the x-axis and their total settlement amounts on the y-axis. Make the size of each bubble represent the average time it takes to settle their claims. Please add a title \"Claims vs. Settlements with Average Settlement Time\" and include tooltips so I can see the customer name and all the details when I hover over each point.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_fnol.sqlite')\nquery = '''\nSELECT \n    c.Customer_name AS Customer,\n    COUNT(cl.Claim_ID) AS Number_of_Claims,\n    SUM(s.Settlement_Amount) AS Total_Settlement_Amount,\n    AVG(julianday(s.Effective_Date) - julianday(cl.Effective_Date)) AS Avg_Settlement_Time\nFROM \n    Customers AS c\nJOIN \n    First_Notification_of_Loss AS fnol ON c.Customer_ID = fnol.Customer_ID\nJOIN \n    Claims AS cl ON fnol.FNOL_ID = cl.FNOL_ID\nJOIN \n    Settlements AS s ON cl.Claim_ID = s.Claim_ID\nGROUP BY \n    c.Customer_name\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_point().encode(\n    x='Number_of_Claims:Q',\n    y='Total_Settlement_Amount:Q',\n    size='Avg_Settlement_Time:Q',\n    tooltip=['Customer:N', 'Number_of_Claims:Q', 'Total_Settlement_Amount:Q', 'Avg_Settlement_Time:Q']\n).properties(\n    title=\"Claims vs. Settlements with Average Settlement Time\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___bubble_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "insurance_policies",
        "chart_category": "Scatter Plots",
        "chart_type": "bubble_plot",
        "NLQ": "Could you create a bubble chart showing the relationship between amount claimed and amount settled for our insurance policies in 2017? I'd like the size of each bubble to represent the difference between claimed and settled amounts, and use different colors to distinguish between policy types. Please add a title that explains what the chart is showing.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_policies.sqlite')\n\nquery = '''\nSELECT \n    Claims.Claim_ID,\n    Claims.Amount_Claimed,\n    Claims.Amount_Settled,\n    (Claims.Amount_Claimed - Claims.Amount_Settled) AS Difference,\n    Customer_Policies.Policy_Type_Code\nFROM \n    Claims\nJOIN \n    Customer_Policies ON Claims.Policy_ID = Customer_Policies.Policy_ID\nWHERE \n    strftime('%Y', Claims.Date_Claim_Made) = '2017'\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_point().encode(\n    x='Amount_Claimed:Q',\n    y='Amount_Settled:Q',\n    size='Difference:Q',\n    color='Policy_Type_Code:N'\n).properties(\n    title='Relationship Between Amount Claimed and Amount Settled (2017)'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___bubble_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "insurance_policies",
        "chart_category": "Scatter Plots",
        "chart_type": "bubble_plot",
        "NLQ": "Could you create a bubble chart showing the relationship between insurance claim amounts and settlement amounts from our 2017 data? I'd like to see how much customers claimed versus how much they actually got paid. Make the bubble size represent the difference between claimed and settled amounts, and use different colors to show the different policy types. Please add a title that explains what the chart is showing.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/insurance_policies.sqlite')\n\nquery = '''\nSELECT \n    Claims.Claim_ID,\n    Claims.Amount_Claimed,\n    Claims.Amount_Settled,\n    (Claims.Amount_Claimed - Claims.Amount_Settled) AS Difference,\n    Customer_Policies.Policy_Type_Code\nFROM \n    Claims\nJOIN \n    Customer_Policies ON Claims.Policy_ID = Customer_Policies.Policy_ID\nWHERE \n    strftime('%Y', Claims.Date_Claim_Made) = '2017'\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_point().encode(\n    x='Amount_Claimed:Q',\n    y='Amount_Settled:Q',\n    size='Difference:Q',\n    color='Policy_Type_Code:N'\n).properties(\n    title='Relationship Between Amount Claimed and Amount Settled (2017)'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___bubble_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "medicine_enzyme_interaction",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels",
        "NLQ": "I have data about medicines and enzymes in my database. Could you create a horizontal bar chart showing how many medicines interact with each enzyme, grouped by the type of interaction? I'd like the enzymes sorted by the number of medicines, with the highest counts at the top. Please color the bars based on the interaction type, add a title \"Medicine-Enzyme Interaction Counts by Type\", and display the count numbers next to each bar for clarity. Also, make sure the x-axis is labeled \"Number of Medicines\" and the y-axis is labeled \"Enzyme Name\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/medicine_enzyme_interaction.sqlite')\n\nquery = '''\nSELECT \n    e.name AS enzyme_name,\n    mei.interaction_type,\n    COUNT(m.id) AS medicine_count\nFROM \n    medicine_enzyme_interaction AS mei\nJOIN \n    enzyme AS e ON mei.enzyme_id = e.id\nJOIN \n    medicine AS m ON mei.medicine_id = m.id\nGROUP BY \n    e.name, mei.interaction_type\nORDER BY \n    e.name, medicine_count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('medicine_count:Q', title='Number of Medicines'),\n    y=alt.Y('enzyme_name:N', title='Enzyme Name', sort='-x'),\n    color=alt.Color('interaction_type:N', title='Interaction Type'),\n    text='medicine_count:Q'\n)\n\nchart = base.mark_bar() + base.mark_text(align='left', dx=2)\nchart.properties(title=\"Medicine-Enzyme Interaction Counts by Type\")",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_labels.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "medicine_enzyme_interaction",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels",
        "NLQ": "I have this horizontal bar chart showing wheat values by year, but I'd like to change it completely. Can you create a new chart that shows how many medicines interact with each enzyme, grouped by the type of interaction? I want to use data from my medicine_enzyme_interaction database instead. Please make it a horizontal bar chart with enzyme names on the y-axis, sorted by the number of medicines. Color the bars based on interaction type, add a clear title like \"Medicine-Enzyme Interaction Counts by Type\", and display the count numbers next to each bar. Also, can you use Altair instead of Matplotlib?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/medicine_enzyme_interaction.sqlite')\n\nquery = '''\nSELECT \n    e.name AS enzyme_name,\n    mei.interaction_type,\n    COUNT(m.id) AS medicine_count\nFROM \n    medicine_enzyme_interaction AS mei\nJOIN \n    enzyme AS e ON mei.enzyme_id = e.id\nJOIN \n    medicine AS m ON mei.medicine_id = m.id\nGROUP BY \n    e.name, mei.interaction_type\nORDER BY \n    e.name, medicine_count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('medicine_count:Q', title='Number of Medicines'),\n    y=alt.Y('enzyme_name:N', title='Enzyme Name', sort='-x'),\n    color=alt.Color('interaction_type:N', title='Interaction Type'),\n    text='medicine_count:Q'\n)\n\nchart = base.mark_bar() + base.mark_text(align='left', dx=2)\nchart.properties(title=\"Medicine-Enzyme Interaction Counts by Type\")",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_labels.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "mountain_photos",
        "chart_category": "Scatter Plots",
        "chart_type": "scatter_plot_with_href",
        "NLQ": "I have this scatter plot showing horsepower vs miles per gallon for different car origins. Could you change it to show data about mountains in Ethiopia instead? I'd like to see the height vs prominence of mountains, with points colored by mountain range. Please add a clear title like \"Height vs Prominence of Mountains in Ethiopia\" and make sure the axis labels show the measurement units in meters. Also, could you add tooltips that show the mountain name, height and prominence when I hover over a point? And one more thing - make each point clickable so it opens a Google search for that mountain name.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/mountain_photos.sqlite')\nquery = '''\nSELECT name, Height, Prominence, Range\nFROM mountain\nWHERE Country = 'Ethiopia'\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_calculate(\n    url='https://www.google.com/search?q=' + alt.datum.name\n).mark_point().encode(\n    x=alt.X('Height:Q', title='Mountain Height (m)'),\n    y=alt.Y('Prominence:Q', title='Mountain Prominence (m)'),\n    color=alt.Color('Range:N', title='Mountain Range'),\n    href='url:N',\n    tooltip=['name:N', 'Height:Q', 'Prominence:Q']\n).properties(\n    title='Height vs Prominence of Mountains in Ethiopia'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___scatter_plot_with_href.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "mountain_photos",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels",
        "NLQ": "I want to create a horizontal bar chart that shows how many photos were taken for each mountain range. Can you sort the mountain ranges by the number of photos from highest to lowest? Please add a clear title like \"Total Photos Taken per Mountain Range\" and make sure the axis labels are descriptive (like \"Mountain Range\" and \"Number of Photos\"). Also, could you add the actual count numbers as text labels next to each bar instead of on top of them?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/mountain_photos.sqlite')\n\nquery = '''\nSELECT \n    m.Range AS mountain_range, \n    COUNT(p.id) AS photo_count\nFROM \n    mountain AS m\nJOIN \n    photos AS p ON m.id = p.mountain_id\nGROUP BY \n    m.Range\nORDER BY \n    photo_count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('photo_count:Q', title='Number of Photos'),\n    y=alt.Y('mountain_range:N', sort='-x', title='Mountain Range'),\n    text='photo_count:Q'\n)\n\nchart = base.mark_bar() + base.mark_text(align='left', dx=2)\nchart.properties(title=\"Total Photos Taken per Mountain Range\")",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_labels.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "mountain_photos",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels",
        "NLQ": "Instead of showing wheat values by year, I'd like to create a horizontal bar chart showing the number of photos taken for each mountain range. Can you pull this data from my mountain_photos database? I want the mountain ranges sorted by the number of photos from highest to lowest, with the count displayed next to each bar. Please add a clear title \"Total Photos Taken per Mountain Range\" and make sure the axes are properly labeled as \"Mountain Range\" and \"Number of Photos\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/mountain_photos.sqlite')\n\nquery = '''\nSELECT \n    m.Range AS mountain_range, \n    COUNT(p.id) AS photo_count\nFROM \n    mountain AS m\nJOIN \n    photos AS p ON m.id = p.mountain_id\nGROUP BY \n    m.Range\nORDER BY \n    photo_count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('photo_count:Q', title='Number of Photos'),\n    y=alt.Y('mountain_range:N', sort='-x', title='Mountain Range'),\n    text='photo_count:Q'\n)\n\nchart = base.mark_bar() + base.mark_text(align='left', dx=2)\nchart.properties(title=\"Total Photos Taken per Mountain Range\")",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_labels.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "movie_1",
        "chart_category": "Scatter Plots",
        "chart_type": "scatter_plot_with_href",
        "NLQ": "Instead of showing car data, can you create a scatter plot that shows movie ratings over the years? I want each point to represent a movie, with the x-axis showing the release year and the y-axis showing the average rating. Color-code the points by director, and make it interactive so when I click on a movie point, it searches for that movie on Google. Also, add tooltips that show the movie title, director, and rating when I hover over a point.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/movie_1.sqlite')\nquery = '''\nSELECT \n    M.year AS release_year,\n    AVG(R.stars) AS avg_rating,\n    M.director AS director,\n    M.title AS title\nFROM \n    Movie AS M\nJOIN \n    Rating AS R ON M.mID = R.mID\nGROUP BY \n    M.mID, M.year, M.director, M.title\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_calculate(\n    url='https://www.google.com/search?q=' + alt.datum.title\n).mark_point().encode(\n    x=alt.X('release_year:Q', title='Release Year'),\n    y=alt.Y('avg_rating:Q', title='Average Rating'),\n    color=alt.Color('director:N', title='Director'),\n    href='url:N',\n    tooltip=['title:N', 'director:N', 'avg_rating:Q']\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___scatter_plot_with_href.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "museum_visit",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels_based_on_measured_luminance",
        "NLQ": "Can you create a horizontal bar chart showing the total number of tickets sold for each museum? I need to pull this data from our museum database. Please sort the museums from highest to lowest ticket sales, and add a title \"Total Tickets Sold Per Museum\". Make the bars blue with different shades based on the number of tickets sold. I'd like to see the actual ticket numbers displayed on each bar, and when I hover over a bar, it should show me the exact ticket count. Can you make the chart wider and taller too? Also, please label the axes as \"Museum\" and \"Total Tickets Sold\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/museum_visit.sqlite')\n\nquery = '''\nSELECT \n    m.Name AS Museum_Name, \n    SUM(v.Num_of_Ticket) AS Total_Tickets\nFROM \n    visit AS v\nJOIN \n    museum AS m ON v.Museum_ID = m.Museum_ID\nGROUP BY \n    m.Name\nORDER BY \n    Total_Tickets DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('Total_Tickets:Q', title='Total Tickets Sold'),\n    y=alt.Y('Museum_Name:O', sort='-x', title='Museum'),\n    text=alt.Text('Total_Tickets:Q', format='.0f')\n)\n\nbars = base.mark_bar().encode(\n    color=alt.Color('Total_Tickets:Q', scale=alt.Scale(scheme='blues'), title='Tickets Sold'),\n    tooltip=alt.Tooltip('Total_Tickets:Q', format='.0f')\n)\n\ntext = base.mark_text(\n    align='left',\n    dx=3,\n    color=alt.expr(\"luminance(scale('color', datum.Total_Tickets)) > 0.5 ? 'black' : 'white'\")\n)\n\nchart = bars + text\n\nchart.properties(\n    title='Total Tickets Sold Per Museum',\n    width=600,\n    height=400\n)",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_labels_based_on_measured_luminance.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "museum_visit",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_labels_based_on_measured_luminance",
        "NLQ": "Can you create a chart showing total ticket sales for each museum instead of crop yields by site? I'd like to keep the horizontal bar chart style with the blue color gradient, but use my museum database to get the data. Please add a proper title \"Total Tickets Sold Per Museum\" and make the chart wider (about 600x400). Also, I'd like to add tooltips when hovering over the bars, and keep the text labels on the bars that change color based on the background. Make sure the museums are sorted from highest to lowest ticket sales.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/museum_visit.sqlite')\n\nquery = '''\nSELECT \n    m.Name AS Museum_Name, \n    SUM(v.Num_of_Ticket) AS Total_Tickets\nFROM \n    visit AS v\nJOIN \n    museum AS m ON v.Museum_ID = m.Museum_ID\nGROUP BY \n    m.Name\nORDER BY \n    Total_Tickets DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nbase = alt.Chart(df).encode(\n    x=alt.X('Total_Tickets:Q', title='Total Tickets Sold'),\n    y=alt.Y('Museum_Name:O', sort='-x', title='Museum'),\n    text=alt.Text('Total_Tickets:Q', format='.0f')\n)\n\nbars = base.mark_bar().encode(\n    color=alt.Color('Total_Tickets:Q', scale=alt.Scale(scheme='blues'), title='Tickets Sold'),\n    tooltip=alt.Tooltip('Total_Tickets:Q', format='.0f')\n)\n\ntext = base.mark_text(\n    align='left',\n    dx=3,\n    color=alt.expr(\"luminance(scale('color', datum.Total_Tickets)) > 0.5 ? 'black' : 'white'\")\n)\n\nchart = bars + text\n\nchart.properties(\n    title='Total Tickets Sold Per Museum',\n    width=600,\n    height=400\n)",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___bar_chart_with_labels_based_on_measured_luminance.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "museum_visit",
        "chart_category": "Scatter Plots",
        "chart_type": "scatter_plot_with_href",
        "NLQ": "I have this chart showing horsepower and miles per gallon for different cars, but I'd like to create something similar for museum data instead. Can you make a scatter plot that shows the number of tickets sold and total amount spent at different museums? I want each point to represent a museum, and when you hover over a point, it should show the museum name, number of tickets, and total spent. Also, could you make each point clickable so that when someone clicks on it, it takes them to a Google search for that museum? I have the museum data stored in a database if that helps.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/museum_visit.sqlite')\n\nquery = '''\nSELECT \n    m.Name AS Museum_Name,\n    v.Num_of_Ticket,\n    v.Total_spent\nFROM \n    visit AS v\nJOIN \n    museum AS m ON v.Museum_ID = m.Museum_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_calculate(\n    url='https://www.google.com/search?q=' + alt.datum.Museum_Name\n).mark_point().encode(\n    x='Num_of_Ticket:Q',\n    y='Total_spent:Q',\n    href='url:N',\n    tooltip=['Museum_Name:N', 'Num_of_Ticket:Q', 'Total_spent:Q']\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___scatter_plot_with_href.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "orchestra",
        "chart_category": "Scatter Plots",
        "chart_type": "scatter_plot_with_shaded_area",
        "NLQ": "Using the conductor information from my database, can you create a scatter plot that shows how their age relates to their years of work? I want to see points representing each conductor with age on the x-axis and years of work on the y-axis. Also, could you add a red shaded vertical area highlighting ages 40-42? Make sure to label the axes properly as \"Conductor Age\" and \"Years of Work\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/orchestra.sqlite')\nquery = '''\nSELECT Age, Year_of_Work\nFROM conductor\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nshaded_area = pd.DataFrame({\n    \"x1\": [40],\n    \"x2\": [42]\n})\n\npoints = alt.Chart(df).mark_point().encode(\n    x=alt.X(\"Age:Q\", title=\"Conductor Age\"),\n    y=alt.Y(\"Year_of_Work:Q\", title=\"Years of Work\")\n)\n\ninterval = alt.Chart(shaded_area).mark_rect(opacity=0.3, color=\"#FF0000\").encode(\n    x=\"x1:Q\",\n    x2=\"x2:Q\"\n)\n\nchart = points + interval\nchart",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___scatter_plot_with_shaded_area.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "orchestra",
        "chart_category": "Scatter Plots",
        "chart_type": "scatter_plot_with_shaded_area",
        "NLQ": "Can you create a scatter plot using my orchestra database that shows the relationship between conductor age and their years of work? I'd like to see points for each conductor and highlight a specific age range between 40 and 42 with a red shaded area. Please make sure to label the axes clearly as \"Conductor Age\" and \"Years of Work\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/orchestra.sqlite')\nquery = '''\nSELECT Age, Year_of_Work\nFROM conductor\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nshaded_area = pd.DataFrame({\n    \"x1\": [40],\n    \"x2\": [42]\n})\n\npoints = alt.Chart(df).mark_point().encode(\n    x=alt.X(\"Age:Q\", title=\"Conductor Age\"),\n    y=alt.Y(\"Year_of_Work:Q\", title=\"Years of Work\")\n)\n\ninterval = alt.Chart(shaded_area).mark_rect(opacity=0.3, color=\"#FF0000\").encode(\n    x=\"x1:Q\",\n    x2=\"x2:Q\"\n)\n\nchart = points + interval\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___scatter_plot_with_shaded_area.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "phone_1",
        "chart_category": "Simple Charts",
        "chart_type": "simple_bar_chart",
        "NLQ": "Can you create a bar chart showing how many phone models were launched each year? I need to pull this data from my phone database. Please make sure to label the x-axis as \"Launch Year\" and the y-axis as \"Total Models Launched\", and add a title that says \"Total Phone Models Launched Each Year\". I want it to look organized with clear labels.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/phone_1.sqlite')\n\nquery = '''\nSELECT Launch_year, COUNT(Model_name) AS Total_Models\nFROM chip_model\nGROUP BY Launch_year\nORDER BY Launch_year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Launch_year:O', title='Launch Year'),\n    y=alt.Y('Total_Models:Q', title='Total Models Launched')\n).properties(\n    title='Total Phone Models Launched Each Year'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "phone_1",
        "chart_category": "Simple Charts",
        "chart_type": "simple_bar_chart",
        "NLQ": "Instead of using the sample data in my bar chart, can you create a chart that shows how many phone models were launched each year? Get the data from the phone database by counting models grouped by launch year. Make sure to include a clear title like \"Total Phone Models Launched Each Year\" and label the x-axis as \"Launch Year\" and the y-axis as \"Total Models Launched\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/phone_1.sqlite')\n\nquery = '''\nSELECT Launch_year, COUNT(Model_name) AS Total_Models\nFROM chip_model\nGROUP BY Launch_year\nORDER BY Launch_year\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Launch_year:O', title='Launch Year'),\n    y=alt.Y('Total_Models:Q', title='Total Models Launched')\n).properties(\n    title='Total Phone Models Launched Each Year'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "phone_market",
        "chart_category": "Simple Charts",
        "chart_type": "simple_bar_chart",
        "NLQ": "Can you create a bar chart showing the total number of phones in stock for each district? I need to pull this data from our phone_market database by joining the phone_market and market tables. The chart should display districts on the x-axis and the total stock count on the y-axis. Please sort the districts by their total stock in descending order, and make sure to label the axes properly as \"District\" and \"Total Phones in Stock\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/phone_market.sqlite')\n\nquery = '''\nSELECT \n    m.District AS District, \n    SUM(pm.Num_of_stock) AS Total_Stock\nFROM \n    phone_market AS pm\nJOIN \n    market AS m ON pm.Market_ID = m.Market_ID\nGROUP BY \n    m.District\nORDER BY \n    Total_Stock DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('District:N', title='District'),\n    y=alt.Y('Total_Stock:Q', title='Total Phones in Stock')\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "phone_market",
        "chart_category": "Simple Charts",
        "chart_type": "simple_bar_chart",
        "NLQ": "I want to create a bar chart showing the total number of phones in stock for each district. Can you pull this data from our phone_market database by joining the phone_market and market tables? I need to see the districts on the x-axis and the total stock quantities on the y-axis. Please sort the districts by their total stock in descending order so we can easily see which districts have the most inventory. Make sure to label the axes clearly as \"District\" and \"Total Phones in Stock\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/phone_market.sqlite')\n\nquery = '''\nSELECT \n    m.District AS District, \n    SUM(pm.Num_of_stock) AS Total_Stock\nFROM \n    phone_market AS pm\nJOIN \n    market AS m ON pm.Market_ID = m.Market_ID\nGROUP BY \n    m.District\nORDER BY \n    Total_Stock DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('District:N', title='District'),\n    y=alt.Y('Total_Stock:Q', title='Total Phones in Stock')\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "phone_market",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_crossfilter",
        "NLQ": "Instead of using the flight data with distance, delay, and time, can you create a similar interactive chart but using our phone market database? I want to see the distribution of number of employees, number of shops, and rankings. Keep the same interactive filtering where I can select a range, but make the unselected bars gray and the selected ones blue. Also, can you make the charts a bit smaller so they fit better on my screen?",
        "code": "import altair as alt\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/phone_market.sqlite')\nquery = '''\nSELECT Num_of_employees, Num_of_shops, Ranking\nFROM market\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval(encodings=['x'])\nbase = alt.Chart(width=160, height=130).mark_bar().encode(\n    x=alt.X(alt.repeat('column')).bin(maxbins=20),\n    y='count()'\n)\nbackground = base.encode(\n    color=alt.value('#ddd')\n).add_params(brush)\nhighlight = base.transform_filter(brush)\n\nalt.layer(\n    background,\n    highlight,\n    data=df\n).repeat(column=[\"Num_of_employees\", \"Num_of_shops\", \"Ranking\"])",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_crossfilter.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "poker_player",
        "chart_category": "Simple Charts",
        "chart_type": "simple_heatmap",
        "NLQ": "Could you help me create a colorful heatmap that shows how much money poker players from different countries have earned based on how many final tables they've made? I want to use our poker database to show nationalities on one axis and final tables made on the other axis, with colors representing the total earnings. Please make it a good size with a clear title explaining what the visualization shows, and use a nice color scheme like viridis to represent the earnings amounts.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/poker_player.sqlite')\nquery = '''\nSELECT \n    p.Nationality,\n    pp.Final_Table_Made,\n    SUM(pp.Earnings) AS Total_Earnings\nFROM \n    poker_player AS pp\nJOIN \n    people AS p ON pp.People_ID = p.People_ID\nGROUP BY \n    p.Nationality, pp.Final_Table_Made\nORDER BY \n    p.Nationality, pp.Final_Table_Made;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nheatmap = alt.Chart(df).mark_rect().encode(\n    x=alt.X('Final_Table_Made:O', title='Final Tables Made'),\n    y=alt.Y('Nationality:O', title='Nationality'),\n    color=alt.Color('Total_Earnings:Q', title='Total Earnings', scale=alt.Scale(scheme='viridis'))\n).properties(\n    width=600,\n    height=400,\n    title=\"Heatmap of Poker Players' Earnings by Nationality and Final Tables Made\"\n)\n\nheatmap",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "poker_player",
        "chart_category": "Simple Charts",
        "chart_type": "simple_heatmap",
        "NLQ": "Could you create a heatmap showing poker players' earnings by nationality and how many final tables they've made? I'd like to see the total earnings represented by different colors, with nationalities listed on one axis and the number of final tables made on the other. Please pull this data from our poker player database and make the visualization large enough to read easily with a clear title explaining what we're looking at.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/poker_player.sqlite')\n\nquery = '''\nSELECT \n    p.Nationality,\n    pp.Final_Table_Made,\n    SUM(pp.Earnings) AS Total_Earnings\nFROM \n    poker_player AS pp\nJOIN \n    people AS p ON pp.People_ID = p.People_ID\nGROUP BY \n    p.Nationality, pp.Final_Table_Made\nORDER BY \n    p.Nationality, pp.Final_Table_Made;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nheatmap = alt.Chart(df).mark_rect().encode(\n    x=alt.X('Final_Table_Made:O', title='Final Tables Made'),\n    y=alt.Y('Nationality:O', title='Nationality'),\n    color=alt.Color('Total_Earnings:Q', title='Total Earnings', scale=alt.Scale(scheme='viridis'))\n).properties(\n    width=600,\n    height=400,\n    title=\"Heatmap of Poker Players' Earnings by Nationality and Final Tables Made\"\n)\n\nheatmap",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "products_gen_characteristics",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_rounded_edges",
        "NLQ": "I have a simple bar chart showing weather counts by month, but I'd like to create a new chart using my product database instead. Can you make a bar chart that shows how many products we have in each category, and color-code the bars by price range (low, medium, high)? Please add rounded corners to the bars, give it a clear title like \"Count of Products by Category and Selling Price Range\", and make sure the axes have proper labels like \"Product Category\" and \"Number of Products\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/products_gen_characteristics.sqlite')\nquery = '''\nSELECT \n    T1.product_category_description AS category,\n    CASE \n        WHEN CAST(T2.typical_selling_price AS FLOAT) < 100 THEN 'Low'\n        WHEN CAST(T2.typical_selling_price AS FLOAT) BETWEEN 100 AND 1000 THEN 'Medium'\n        ELSE 'High'\n    END AS price_range\nFROM Ref_Product_Categories AS T1\nJOIN Products AS T2 ON T1.product_category_code = T2.product_category_code\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar(\n    cornerRadiusTopLeft=3,\n    cornerRadiusTopRight=3\n).encode(\n    x=alt.X('category:N', title='Product Category'),\n    y=alt.Y('count():Q', title='Number of Products'),\n    color=alt.Color('price_range:N', title='Selling Price Range')\n).properties(\n    title='Count of Products by Category and Selling Price Range'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_rounded_edges.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "product_catalog",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_legend",
        "NLQ": "Can you create a streamgraph showing how the total stock in each catalog section changes over the years? I want to use data from our product catalog database instead of the sample data. Use a blue color scheme for the different catalog levels, remove the axis lines and tick marks to make it cleaner, and keep that interactive legend that highlights each section when I click on it.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/product_catalog.sqlite')\n\nquery = '''\nSELECT \n    T2.catalog_level_name AS level_name,\n    strftime('%Y', T1.date_of_publication) AS year,\n    COUNT(T3.catalog_entry_id) AS total_stock\nFROM \n    Catalogs AS T1\nJOIN \n    Catalog_Structure AS T2 ON T1.catalog_id = T2.catalog_id\nJOIN \n    Catalog_Contents AS T3 ON T2.catalog_level_number = T3.catalog_level_number\nGROUP BY \n    T2.catalog_level_name, strftime('%Y', T1.date_of_publication)\nORDER BY \n    year ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nselection = alt.selection_point(fields=['level_name'], bind='legend')\n\nchart = alt.Chart(df).mark_area().encode(\n    alt.X('year:T').axis(domain=False, format='%Y', tickSize=0),\n    alt.Y('sum(total_stock):Q').stack('center').axis(None),\n    alt.Color('level_name:N').scale(scheme='category20b'),\n    opacity=alt.condition(selection, alt.value(1), alt.value(0.2))\n).add_params(\n    selection\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_legend.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "program_share",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_rectangular_brush",
        "NLQ": "Can you help me create a chart that shows how the launch year of programs relates to their share percentages, with colors changing based on where the programs come from? I want it to look like the interactive one in the code I shared, where you can click and drag to highlight points, and hovering over them shows more details. Instead of using the car data, I need to use my program share data from my SQLite database. Make the chart bigger with a width of 600 and height of 400, and add a title that says \"Program Share Percentage vs Launch Year\". When someone hovers over a point, I want them to see the program name, origin, launch year, and share percentage.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/program_share.sqlite')\n\nquery = '''\nSELECT p.Program_ID, p.Name, p.Origin, p.Launch, b.Share_in_percent\nFROM program AS p\nJOIN broadcast_share AS b ON p.Program_ID = b.Program_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval()\n\nchart = alt.Chart(df).mark_point().encode(\n    x='Launch:Q',\n    y='Share_in_percent:Q',\n    color=alt.condition(brush, 'Origin:N', alt.value('grey')),\n    tooltip=['Name:N', 'Origin:N', 'Launch:Q', 'Share_in_percent:Q']\n).add_params(\n    brush\n).properties(\n    width=600,\n    height=400,\n    title=\"Program Share Percentage vs Launch Year\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_rectangular_brush.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "program_share",
        "chart_category": "Bar Charts",
        "chart_type": "bar_chart_with_rounded_edges",
        "NLQ": "Could you create a chart showing the average share percentage for TV programs at different times of day? I want to see how each program performs throughout the day. Please use bar charts with rounded corners at the top, and color-code the bars by program name. Add a clear title like \"Average Share Percentage by Time of Day and Program\" and make sure the axes are properly labeled as \"Time of Day\" and \"Average Share Percentage\". I need to pull this data from our program_share database instead of using the sample weather data in the example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/program_share.sqlite')\n\nquery = '''\nSELECT \n    b.Time_of_day AS Time_of_day,\n    p.Name AS Program_Name,\n    AVG(bs.Share_in_percent) AS Avg_Share_Percent\nFROM \n    broadcast AS b\nJOIN \n    program AS p ON b.Program_ID = p.Program_ID\nJOIN \n    broadcast_share AS bs ON b.Channel_ID = bs.Channel_ID AND b.Program_ID = bs.Program_ID\nGROUP BY \n    b.Time_of_day, p.Name\nORDER BY \n    b.Time_of_day;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar(\n    cornerRadiusTopLeft=3,\n    cornerRadiusTopRight=3\n).encode(\n    x=alt.X('Time_of_day:O', title='Time of Day'),\n    y=alt.Y('Avg_Share_Percent:Q', title='Average Share Percentage'),\n    color=alt.Color('Program_Name:N', title='Program Name')\n).properties(\n    title='Average Share Percentage by Time of Day and Program'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___bar_chart_with_rounded_edges.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "protein_institute",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_rectangular_brush",
        "NLQ": "Can you create a scatter plot showing building heights versus number of floors? I'd like to be able to select points interactively, and color-code them based on how many years each building was the tallest in the world. Also, please add tooltips so I can see building names and other details when I hover over points, and add a title that explains what the chart is showing.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/protein_institute.sqlite')\nquery = '''\nSELECT Name, Height_feet, Floors, Years_as_tallest\nFROM building\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval()\n\nchart = alt.Chart(df).mark_point().encode(\n    x='Height_feet:Q',\n    y='Floors:Q',\n    color=alt.condition(brush, 'Years_as_tallest:N', alt.value('grey')),\n    tooltip=['Name:N', 'Height_feet:Q', 'Floors:Q', 'Years_as_tallest:N']\n).add_params(\n    brush\n).properties(\n    title=\"Building Height vs. Number of Floors with Highlight for Tallest Buildings\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_rectangular_brush.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "protein_institute",
        "chart_category": "Bar Charts",
        "chart_type": "calculating_percentage_of_total",
        "NLQ": "Can you change my activity time chart to show building heights instead? I need to pull data from my protein institute database to display the percentage of total height for each building. Make sure the x-axis shows the values as percentages with a % symbol. Keep the same bar chart style that shows how each building's height compares to the total.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/protein_institute.sqlite')\n\nquery = '''\nSELECT Name, Height_feet\nFROM building\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_joinaggregate(\n    TotalHeight='sum(Height_feet)',\n).transform_calculate(\n    PercentOfTotal=\"datum.Height_feet / datum.TotalHeight\"\n).mark_bar().encode(\n    alt.X('PercentOfTotal:Q').axis(format='.0%'),\n    y='Name:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___calculating_percentage_of_total.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "protein_institute",
        "chart_category": "Bar Charts",
        "chart_type": "calculating_percentage_of_total",
        "NLQ": "Instead of showing how people spend their time, can you create a horizontal bar chart that shows the percentage of total height for each building from our protein institute database? I want to see how each building's height compares to the overall total height of all buildings. Keep the percentage format on the x-axis like in my original chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/protein_institute.sqlite')\nquery = '''\nSELECT Name, Height_feet\nFROM building\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_joinaggregate(\n    TotalHeight='sum(Height_feet)',\n).transform_calculate(\n    PercentOfTotal=\"datum.Height_feet / datum.TotalHeight\"\n).mark_bar().encode(\n    alt.X('PercentOfTotal:Q').axis(format='.0%'),\n    y='Name:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___calculating_percentage_of_total.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "race_track",
        "chart_category": "Bar Charts",
        "chart_type": "calculating_percentage_of_total",
        "NLQ": "I want to create a chart that shows the percentage of races held at different track locations. Can you pull this data from our race_track database by joining the race and track tables? I'd like to count the number of races at each location and display it as a percentage of total races. Make it look like a horizontal bar chart with the track locations on the y-axis and the percentages on the x-axis. Also, can you format the x-axis to show percentages with the % symbol instead of decimal values?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/race_track.sqlite')\nquery = '''\nSELECT \n    t.Location AS Track_Location,\n    COUNT(r.Race_ID) AS Race_Count\nFROM \n    race AS r\nJOIN \n    track AS t\nON \n    r.Track_ID = t.Track_ID\nGROUP BY \n    t.Location\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).transform_joinaggregate(\n    TotalRaces='sum(Race_Count)',\n).transform_calculate(\n    PercentOfTotal=\"datum.Race_Count / datum.TotalRaces\"\n).mark_bar().encode(\n    alt.X('PercentOfTotal:Q').axis(format='.0%'),\n    y='Track_Location:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___calculating_percentage_of_total.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "race_track",
        "chart_category": "Bar Charts",
        "chart_type": "calculating_percentage_of_total",
        "NLQ": "I want to create a horizontal bar chart showing the percentage of races held at different track locations. Instead of using the sample activity data in the example, can you pull the actual race data from our SQLite database? I need it to count how many races happened at each track location, then calculate what percentage of total races that represents. Keep the same layout with locations on the left and percentage bars extending to the right, with percentages formatted as whole numbers with a percent sign.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/race_track.sqlite')\n\nquery = '''\nSELECT \n    t.Location AS Track_Location,\n    COUNT(r.Race_ID) AS Race_Count\nFROM \n    race AS r\nJOIN \n    track AS t\nON \n    r.Track_ID = t.Track_ID\nGROUP BY \n    t.Location\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).transform_joinaggregate(\n    TotalRaces='sum(Race_Count)',\n).transform_calculate(\n    PercentOfTotal=\"datum.Race_Count / datum.TotalRaces\"\n).mark_bar().encode(\n    alt.X('PercentOfTotal:Q').axis(format='.0%'),\n    y='Track_Location:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___calculating_percentage_of_total.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "race_track",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_rectangular_brush",
        "NLQ": "I want to create a chart that shows how seating capacity and the year a track opened are related, but only for races in the DP/GT class. Can you make it look like the interactive one in my code, where you can click and drag to highlight points, and the colors change based on the track name? Also, add tooltips so I can see the track name, seating capacity, and year opened when I hover over a point. Instead of using random data, please pull the information from our race_track database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/race_track.sqlite')\n\nquery = '''\nSELECT T.Track_ID, T.Name AS Track_Name, T.Seating, T.Year_Opened\nFROM track AS T\nJOIN race AS R ON T.Track_ID = R.Track_ID\nWHERE R.Class = 'DP/GT'\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval()\n\nchart = alt.Chart(df).mark_point().encode(\n    x='Seating:Q',\n    y='Year_Opened:Q',\n    color=alt.condition(brush, 'Track_Name:N', alt.value('grey')),\n    tooltip=['Track_Name:N', 'Seating:Q', 'Year_Opened:Q']\n).add_params(brush)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_rectangular_brush.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "restaurant_1",
        "chart_category": "Bar Charts",
        "chart_type": "compact_faceted_grid_of_bar_charts",
        "NLQ": "Can you create a chart showing the average amount spent by gender at different restaurant types? I'd like to see small horizontal bar charts with each restaurant type in its own row. Please color-code the bars by gender with the legend at the bottom, and show the average amount spent on the x-axis. Make the chart compact with short bars, and don't show the gender labels next to each bar since they'll be color-coded. Also, make sure the restaurant type labels are displayed horizontally for better readability.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/restaurant_1.sqlite')\n\nquery = '''\nSELECT \n    RT.ResTypeName AS Restaurant_Type,\n    S.Sex AS Gender,\n    AVG(VR.Spent) AS Average_Spent\nFROM \n    Visits_Restaurant AS VR\nJOIN \n    Student AS S ON VR.StuID = S.StuID\nJOIN \n    Type_Of_Restaurant AS TOR ON VR.ResID = TOR.ResID\nJOIN \n    Restaurant_Type AS RT ON TOR.ResTypeID = RT.ResTypeID\nGROUP BY \n    RT.ResTypeName, S.Sex\nORDER BY \n    RT.ResTypeName, S.Sex;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, width=60, height=alt.Step(8)).mark_bar().encode(\n    alt.Y(\"Gender:N\").axis(None),\n    alt.X(\"Average_Spent:Q\").title(\"Average Amount Spent\"),\n    alt.Color(\"Gender:N\").title(\"Gender\").legend(orient=\"bottom\", titleOrient=\"left\"),\n    alt.Row(\"Restaurant_Type:N\").title(\"Restaurant Type\").header(labelAngle=0)\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___compact_faceted_grid_of_bar_charts.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "restaurant_1",
        "chart_category": "Bar Charts",
        "chart_type": "compact_faceted_grid_of_bar_charts",
        "NLQ": "Can you create a chart showing the average amount spent by gender at different restaurant types? I'd like to use data from my restaurant database instead of the sample data in my current chart. Please organize it with horizontal bars for each gender, color-coded to distinguish between them, with a legend at the bottom. Group the bars by restaurant type in rows, and make sure each bar shows the average amount spent clearly. The chart should be compact with small bars.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/restaurant_1.sqlite')\n\nquery = '''\nSELECT \n    RT.ResTypeName AS Restaurant_Type,\n    S.Sex AS Gender,\n    AVG(VR.Spent) AS Average_Spent\nFROM \n    Visits_Restaurant AS VR\nJOIN \n    Student AS S ON VR.StuID = S.StuID\nJOIN \n    Type_Of_Restaurant AS TOR ON VR.ResID = TOR.ResID\nJOIN \n    Restaurant_Type AS RT ON TOR.ResTypeID = RT.ResTypeID\nGROUP BY \n    RT.ResTypeName, S.Sex\nORDER BY \n    RT.ResTypeName, S.Sex;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df, width=60, height=alt.Step(8)).mark_bar().encode(\n    alt.Y(\"Gender:N\").axis(None),\n    alt.X(\"Average_Spent:Q\").title(\"Average Amount Spent\"),\n    alt.Color(\"Gender:N\").title(\"Gender\").legend(orient=\"bottom\", titleOrient=\"left\"),\n    alt.Row(\"Restaurant_Type:N\").title(\"Restaurant Type\").header(labelAngle=0)\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___compact_faceted_grid_of_bar_charts.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "restaurant_1",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_scatter_plot_and_linked_layered_histogram",
        "NLQ": "Can you change my visualization to show restaurant data instead of height and weight? I'd like to see how much students spend on average at restaurants based on their age and gender, and include a breakdown of restaurant ratings. Please use teal and purple colors for gender instead of the default colors, make the points bigger and filled, and add proper axis labels like \"Student Age\" and \"Average Amount Spent ($)\". For the histogram on the right, can you show restaurant ratings from 0-5 instead of age, and make the bars semi-transparent?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/restaurant_1.sqlite')\nquery = '''\nSELECT \n    S.Age,\n    S.Sex AS Gender,\n    AVG(V.Spent) AS AvgSpent,\n    R.Rating\nFROM \n    Student AS S\nJOIN \n    Visits_Restaurant AS V ON S.StuID = V.StuID\nJOIN \n    Restaurant AS R ON V.ResID = R.ResID\nGROUP BY \n    S.Age, S.Sex, R.Rating\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nselector = alt.selection_point(fields=['Gender'])\ncolor_scale = alt.Scale(domain=['M', 'F'], range=['#1FC3AA', '#8624F5'])\ncolor = (\n    alt.when(selector)\n    .then(alt.Color(\"Gender:N\").scale(color_scale))\n    .otherwise(alt.value(\"lightgray\"))\n)\n\nbase = alt.Chart(df).properties(\n    width=250,\n    height=250\n).add_params(selector)\n\npoints = base.mark_point(filled=True, size=200).encode(\n    alt.X('Age:Q').title('Student Age'),\n    alt.Y('AvgSpent:Q').title('Average Amount Spent ($)'),\n    color=color\n)\n\nhists = base.mark_bar(opacity=0.5, thickness=100).encode(\n    alt.X('Rating:Q')\n        .bin(step=1)\n        .scale(domain=[0, 5]),\n    alt.Y('count()')\n        .stack(None),\n    alt.Color('Gender:N').scale(color_scale)\n).transform_filter(\n    selector\n)\n\npoints | hists",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_scatter_plot_and_linked_layered_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "riding_club",
        "chart_category": "Bar Charts",
        "chart_type": "compact_faceted_grid_of_bar_charts",
        "NLQ": "Can you create a chart showing total votes by gender for each rank? I'd like to see the data from our riding club database instead of the sample data. Make each rank a separate row, with horizontal bars showing votes for each gender. Please use different colors for male and female, with a legend at the bottom. Keep it compact with narrow bars, remove the y-axis labels since they're redundant, and don't show x-axis titles since it's clear we're looking at vote counts.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/riding_club.sqlite')\n\nquery = '''\nSELECT Gender, Rank, SUM(Votes) AS Total_Votes\nFROM player\nGROUP BY Gender, Rank\nORDER BY Rank\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, width=60, height=alt.Step(8)).mark_bar().encode(\n    alt.Y(\"Gender:N\").axis(None),\n    alt.X(\"Total_Votes:Q\").title(None),\n    alt.Color(\"Gender:N\").title(\"Gender\").legend(orient=\"bottom\", titleOrient=\"left\"),\n    alt.Row(\"Rank:N\").title(\"Rank\").header(labelAngle=0)\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___compact_faceted_grid_of_bar_charts.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "riding_club",
        "chart_category": "Bar Charts",
        "chart_type": "compact_faceted_grid_of_bar_charts",
        "NLQ": "Instead of using the sample data from the previous chart, can you create a visualization using data from our riding club database? I need to see the total votes for each gender, broken down by rank. Make it a horizontal bar chart with ranks organized in rows, and use different colors for each gender. Keep it simple with a clean layout - no need for axis titles, and put the gender legend at the bottom. Each rank should be clearly labeled.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/riding_club.sqlite')\nquery = '''\nSELECT Gender, Rank, SUM(Votes) AS Total_Votes\nFROM player\nGROUP BY Gender, Rank\nORDER BY Rank\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, width=60, height=alt.Step(8)).mark_bar().encode(\n    alt.Y(\"Gender:N\").axis(None),\n    alt.X(\"Total_Votes:Q\").title(None),\n    alt.Color(\"Gender:N\").title(\"Gender\").legend(orient=\"bottom\", titleOrient=\"left\"),\n    alt.Row(\"Rank:N\").title(\"Rank\").header(labelAngle=0)\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___compact_faceted_grid_of_bar_charts.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "riding_club",
        "chart_category": "Interactive Charts",
        "chart_type": "interactive_selection_of_columns",
        "NLQ": "Can you modify my chart to visualize medal data from our riding club database? I want to see Gold, Big Silver, and Small Silver medals over time, with a correlation heatmap using blue and orange colors. Please add clear titles to the charts - \"Click a tile to compare timeseries\" for the heatmap and \"Individual timeseries\" for the line chart. Also, can you show the difference between selected medal types with a grey line and a dynamic title that updates to show which medals are being compared? Make the layout cleaner with better spacing and remove unnecessary axis labels where they're not needed.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/riding_club.sqlite')\n\nquery = '''\nSELECT Gold, Big_Silver, Small_Silver, Club_ID\nFROM match_result\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ndf['date'] = pd.date_range(start='1/1/2023', periods=len(df), freq='D')\ndf['date'] = df['date'].dt.strftime('%Y-%m-%d')\n\nselect_x = alt.selection_point(fields=['level_0'], name='select_x', value='Gold')\nselect_y = alt.selection_point(fields=['level_1'], name='select_y', value='Big_Silver')\nheatmap = alt.Chart(\n    df.drop(columns=['date', 'Club_ID']).corr().stack().reset_index().rename(columns={0: 'correlation'}),\n    title='Click a tile to compare timeseries',\n    height=250,\n    width=250,\n).mark_rect().encode(\n    alt.X('level_0').title(None),\n    alt.Y('level_1').title(None),\n    alt.Color('correlation').scale(domain=[-1, 1], scheme='blueorange'),\n    opacity=alt.when(select_x, select_y).then(alt.value(1)).otherwise(alt.value(0.4)),\n).add_params(\n    select_x, select_y\n)\n\nbase = alt.Chart(\n    df.melt(\n        id_vars=['date', 'Club_ID'],\n        var_name='category',\n        value_name='value',\n    ),\n    height=100,\n    width=300,\n    title='Individual timeseries',\n)\nlines = base.transform_filter(\n    'indexof(datum.category, select_x.level_0) !== -1'\n   '| indexof(datum.category, select_y.level_1) !== -1'\n).mark_line().encode(\n    alt.X('date:T').axis(labels=False).title(None),\n    alt.Y('value'),\n    alt.Color('category').legend(orient='top', offset=-20).title(None)\n)\n\ndynamic_title = alt.Title(alt.expr(f'\"Difference \" + {select_x.name}.level_0 + \" - \" + {select_y.name}.level_1'))\nlines_diff = base.transform_pivot(\n    'category', 'value', groupby=['date', 'Club_ID']\n).transform_calculate(\n    difference = f'datum[{select_x.name}.level_0] - datum[{select_y.name}.level_1]'\n).mark_line(color='grey').encode(\n    alt.X('date:T').axis(format='%Y-%m-%d').title(None),\n    alt.Y('difference:Q'),\n).properties(\n    title=dynamic_title\n)\n\n(lines & lines_diff) | heatmap",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interactive_selection_of_columns.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "school_bus",
        "chart_category": "Bar Charts",
        "chart_type": "diverging_stacked_bar_chart",
        "NLQ": "Can you change this survey results chart to show school bus driver data instead? I want to see how many drivers from each political party fall into different experience ranges (0-5 years, 6-10 years, and 11+ years). Keep the same centered bar layout, but use a blue and orange color scheme instead of the default colors. Also, can you change the y-axis title to \"Political Party\" and make the x-axis show percentages? I need the data to come from my school bus database rather than the survey data that's currently being used.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/school_bus.sqlite')\nquery = '''\nSELECT \n    d.Party AS Party,\n    CASE \n        WHEN sb.Years_Working BETWEEN 0 AND 5 THEN '0-5 years'\n        WHEN sb.Years_Working BETWEEN 6 AND 10 THEN '6-10 years'\n        ELSE '11+ years'\n    END AS Experience_Range,\n    COUNT(*) AS Driver_Count\nFROM \n    driver AS d\nJOIN \n    school_bus AS sb ON d.Driver_ID = sb.Driver_ID\nGROUP BY \n    d.Party, Experience_Range\nORDER BY \n    d.Party, Experience_Range;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\ndf['Experience_Code'] = df['Experience_Range'].map({'0-5 years': 1, '6-10 years': 2, '11+ years': 3})\n\ndef compute_percentages(group):\n    group = group.set_index('Experience_Code').sort_index()\n    perc = (group['Driver_Count'] / group['Driver_Count'].sum()) * 100\n    group['Percentage'] = perc\n    group['Percentage_End'] = perc.cumsum() - (perc.sum() / 2)\n    group['Percentage_Start'] = group['Percentage_End'] - perc\n    return group\n\ndf = df.groupby('Party').apply(compute_percentages).reset_index(drop=True)\ncolor_scale = alt.Scale(\n    domain=['0-5 years', '6-10 years', '11+ years'],\n    range=['#f3a583', '#cccccc', '#94c6da']\n)\ny_axis = alt.Axis(title=\"Political Party\", offset=5, ticks=False, minExtent=60, domain=False)\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"Percentage_Start:Q\", title=\"Percentage\"),\n    x2=\"Percentage_End:Q\",\n    y=alt.Y(\"Party:N\").axis(y_axis),\n    color=alt.Color(\"Experience_Range:N\").title(\"Experience Range\").scale(color_scale)\n)\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___diverging_stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "school_bus",
        "chart_category": "Bar Charts",
        "chart_type": "diverging_stacked_bar_chart",
        "NLQ": "Can you change this survey response chart to show school bus driver data instead? I want to see how many drivers from each political party fall into different experience ranges (0-5 years, 6-10 years, and 11+ years). Use a diverging color scheme with orange for less experienced drivers, gray for middle experience, and blue for most experienced drivers. The chart should still have the bars spreading out from the center like this one, but I need it to pull data from my school_bus database instead of using the survey data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/school_bus.sqlite')\n\nquery = '''\nSELECT \n    d.Party AS Party,\n    CASE \n        WHEN sb.Years_Working BETWEEN 0 AND 5 THEN '0-5 years'\n        WHEN sb.Years_Working BETWEEN 6 AND 10 THEN '6-10 years'\n        ELSE '11+ years'\n    END AS Experience_Range,\n    COUNT(*) AS Driver_Count\nFROM \n    driver AS d\nJOIN \n    school_bus AS sb ON d.Driver_ID = sb.Driver_ID\nGROUP BY \n    d.Party, Experience_Range\nORDER BY \n    d.Party, Experience_Range;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\ndf['Experience_Code'] = df['Experience_Range'].map({'0-5 years': 1, '6-10 years': 2, '11+ years': 3})\n\ndef compute_percentages(group):\n    group = group.set_index('Experience_Code').sort_index()\n    perc = (group['Driver_Count'] / group['Driver_Count'].sum()) * 100\n    group['Percentage'] = perc\n    group['Percentage_End'] = perc.cumsum() - (perc.sum() / 2)\n    group['Percentage_Start'] = group['Percentage_End'] - perc\n    return group\n\ndf = df.groupby('Party').apply(compute_percentages).reset_index(drop=True)\n\ncolor_scale = alt.Scale(\n    domain=['0-5 years', '6-10 years', '11+ years'],\n    range=['#f3a583', '#cccccc', '#94c6da']\n)\n\ny_axis = alt.Axis(title=\"Political Party\", offset=5, ticks=False, minExtent=60, domain=False)\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X(\"Percentage_Start:Q\", title=\"Percentage\"),\n    x2=\"Percentage_End:Q\",\n    y=alt.Y(\"Party:N\").axis(y_axis),\n    color=alt.Color(\"Experience_Range:N\").title(\"Experience Range\").scale(color_scale)\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___diverging_stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "school_bus",
        "chart_category": "Interactive Charts",
        "chart_type": "interval_selection_with_initial_date_range",
        "NLQ": "I want to create a bar chart showing how many school bus drivers we have for each year of experience. Can you make it interactive with a slider at the bottom that lets me focus on specific ranges of years? I'd like to be able to select a range like 5-10 years of experience and see that zoomed in on the top chart. The chart should have clear labels showing \"Years Working\" on the x-axis and \"Number of Drivers\" on the y-axis. Please pull this data from our school bus database by joining the school_bus and driver tables.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/school_bus.sqlite')\n\nquery = '''\nSELECT sb.Years_Working, COUNT(*) AS Driver_Count\nFROM school_bus AS sb\nJOIN driver AS d ON sb.Driver_ID = d.Driver_ID\nGROUP BY sb.Years_Working\nORDER BY sb.Years_Working\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ninitial_range = (5, 10)\nbrush = alt.selection_interval(encodings=['x'], value={'x': initial_range})\n\nbase = alt.Chart(df, width=600, height=200).mark_bar().encode(\n    x=alt.X('Years_Working:Q', title='Years Working'),\n    y=alt.Y('Driver_Count:Q', title='Number of Drivers')\n)\n\nupper = base.encode(\n    alt.X('Years_Working:Q').scale(domain=brush)\n)\n\nlower = base.properties(\n    height=60\n).add_params(brush)\n\nchart = upper & lower\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interval_selection_with_initial_date_range.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "school_finance",
        "chart_category": "Interactive Charts",
        "chart_type": "interval_selection_with_initial_date_range",
        "NLQ": "Can you create a chart showing our school's budget data instead of those random price values? I need to see the total budgeted amounts by year from our school finance database. Make the chart blue and use a line chart instead of an area chart for the main view, but keep that interactive zoom feature where I can select a date range at the bottom. Also, can you make the bottom selection area smaller and semi-transparent? Please add proper labels like \"Year\" for the x-axis and \"Amount ($)\" for the y-axis, and make the chart a bit wider.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\nimport datetime as dt\n\nconn = sqlite3.connect('database/school_finance.sqlite')\n\nquery = '''\nSELECT \n    b.Year, \n    SUM(b.Budgeted) AS Total_Budgeted, \n    SUM(b.Invested) AS Total_Invested\nFROM \n    budget AS b\nGROUP BY \n    b.Year\nORDER BY \n    b.Year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndate_range = (dt.date(df['Year'].min(), 1, 1), dt.date(df['Year'].max(), 1, 1))\n\nbrush = alt.selection_interval(encodings=['x'], value={'x': date_range})\n\nbase = alt.Chart(df, width=600, height=200).mark_line().encode(\n    x=alt.X('Year:T', title='Year'),\n    y=alt.Y('Total_Budgeted:Q', title='Amount ($)'),\n    color=alt.value('blue')\n)\n\nupper = base.encode(\n    alt.X('Year:T').scale(domain=brush)\n)\n\nlower = base.mark_area(opacity=0.5).properties(\n    height=60\n).add_params(brush)\n\nchart = upper & lower\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interval_selection_with_initial_date_range.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "school_finance",
        "chart_category": "Simple Charts",
        "chart_type": "simple_stacked_area_chart",
        "NLQ": "I have a chart showing energy generation by source over time, but I need to create something different. Could you help me create a chart that shows how each school's budget and investments change over the years? I'd like to see the data from our school finance database, with different colors for each school. Also, could you split it into two separate sections - one showing the budgeted amounts and another showing the invested amounts? I want to be able to compare these two categories easily.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/school_finance.sqlite')\n\nquery = '''\nSELECT \n    S.School_name AS School,\n    B.Year AS Year,\n    SUM(B.Budgeted) AS Total_Budgeted,\n    SUM(B.Invested) AS Total_Invested\nFROM \n    budget AS B\nJOIN \n    School AS S ON B.School_id = S.School_id\nGROUP BY \n    S.School_name, B.Year\nORDER BY \n    B.Year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['School', 'Year'], value_vars=['Total_Budgeted', 'Total_Invested'], \n                    var_name='Category', value_name='Amount')\n\nchart = alt.Chart(df_melted).mark_area().encode(\n    x=alt.X(\"Year:O\", title=\"Year\"),\n    y=alt.Y(\"Amount:Q\", title=\"Amount\"),\n    color=alt.Color(\"School:N\", title=\"School\"),\n    row=alt.Row(\"Category:N\", title=\"Category\")\n).properties(\n    width=600,\n    height=150\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_stacked_area_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "school_finance",
        "chart_category": "Simple Charts",
        "chart_type": "simple_stacked_area_chart",
        "NLQ": "Instead of showing energy generation by source, can you create a chart using my school finance database that shows how each school's budget and investments change over the years? I'd like to see the total budgeted and invested amounts for each school, with different colors for each school. Could you organize it into two separate panels - one showing budgeted amounts and one showing invested amounts? Also, can you make it wider and use Altair instead of Matplotlib?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/school_finance.sqlite')\n\nquery = '''\nSELECT \n    S.School_name AS School,\n    B.Year AS Year,\n    SUM(B.Budgeted) AS Total_Budgeted,\n    SUM(B.Invested) AS Total_Invested\nFROM \n    budget AS B\nJOIN \n    School AS S ON B.School_id = S.School_id\nGROUP BY \n    S.School_name, B.Year\nORDER BY \n    B.Year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['School', 'Year'], value_vars=['Total_Budgeted', 'Total_Invested'], \n                    var_name='Category', value_name='Amount')\n\nchart = alt.Chart(df_melted).mark_area().encode(\n    x=alt.X(\"Year:O\", title=\"Year\"),\n    y=alt.Y(\"Amount:Q\", title=\"Amount\"),\n    color=alt.Color(\"School:N\", title=\"School\"),\n    row=alt.Row(\"Category:N\", title=\"Category\")\n).properties(\n    width=600,\n    height=150\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_stacked_area_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "school_finance",
        "chart_category": "Bar Charts",
        "chart_type": "faceted_stacked_bar_chart",
        "NLQ": "Can you create a chart showing school finance data instead of crop yields? I want to see how much money each school budgeted versus how much they actually invested from 1999 to 2001. Please organize it with schools as columns and years on the y-axis, with different colors for budgeted and invested amounts. Add a clear title like \"Comparison of Budgeted and Invested Amounts by School\" and proper axis labels including dollar signs for the amounts. Make the chart wide enough to easily read each school's data.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/school_finance.sqlite')\n\nquery = '''\nSELECT \n    S.School_name AS School,\n    B.Year AS Year,\n    B.Budgeted AS Budgeted,\n    B.Invested AS Invested\nFROM \n    School AS S\nJOIN \n    budget AS B\nON \n    S.School_id = B.School_id\nWHERE \n    B.Year BETWEEN 1999 AND 2001\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['School', 'Year'], value_vars=['Budgeted', 'Invested'], \n                    var_name='Category', value_name='Amount')\n\nchart = alt.Chart(df_melted).mark_bar().encode(\n    column=alt.Column(\"School:N\", title=\"School\"),\n    x=alt.X(\"Amount:Q\", title=\"Amount ($)\"),\n    y=alt.Y(\"Year:O\", title=\"Year\"),\n    color=alt.Color(\"Category:N\", title=\"Category\")\n).properties(\n    width=200,\n    title=\"Comparison of Budgeted and Invested Amounts by School (1999-2001)\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___faceted_stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "school_finance",
        "chart_category": "Bar Charts",
        "chart_type": "faceted_stacked_bar_chart",
        "NLQ": "I'd like to change this barley yield visualization to show school finance data instead. Can you create a chart that shows how much money schools planned to spend versus what they actually spent, broken down by year and school? I want to see the budgeted and invested amounts for each school from 1999 to 2001, with different colors for each category. Please organize it with schools as separate columns, years on the y-axis, and the dollar amounts on the x-axis. Add a title that explains what we're looking at.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/school_finance.sqlite')\n\nquery = '''\nSELECT \n    S.School_name AS School,\n    B.Year AS Year,\n    B.Budgeted AS Budgeted,\n    B.Invested AS Invested\nFROM \n    School AS S\nJOIN \n    budget AS B\nON \n    S.School_id = B.School_id\nWHERE \n    B.Year BETWEEN 1999 AND 2001\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['School', 'Year'], value_vars=['Budgeted', 'Invested'], \n                    var_name='Category', value_name='Amount')\n\nchart = alt.Chart(df_melted).mark_bar().encode(\n    column=alt.Column(\"School:N\", title=\"School\"),\n    x=alt.X(\"Amount:Q\", title=\"Amount ($)\"),\n    y=alt.Y(\"Year:O\", title=\"Year\"),\n    color=alt.Color(\"Category:N\", title=\"Category\")\n).properties(\n    width=200,\n    title=\"Comparison of Budgeted and Invested Amounts by School (1999-2001)\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___faceted_stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "school_player",
        "chart_category": "Simple Charts",
        "chart_type": "simple_strip_plot",
        "NLQ": "Could you make a chart that looks like the one in my code, but instead of showing horsepower and cylinders, it shows how many students are enrolled in each school grouped by their denomination? I'd like it to have the same kind of layout where the denominations are listed vertically and the enrollment numbers spread out horizontally. Also, could you pull this data from my school_player database instead of using random numbers?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/school_player.sqlite')\nquery = '''\nSELECT Enrollment, Denomination\nFROM school\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_tick().encode(\n    x='Enrollment:Q',\n    y='Denomination:O'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_strip_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "school_player",
        "chart_category": "Simple Charts",
        "chart_type": "simple_strip_plot",
        "NLQ": "Could you change this chart to show school enrollment numbers instead of horsepower and cylinders? I'd like to see the enrollment numbers spread out horizontally, with different school denominations listed vertically on the y-axis. Instead of using our test data, could you pull the actual enrollment and denomination information from our school database? Keep the same strip/tick mark style that shows the distribution.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/school_player.sqlite')\n\nquery = '''\nSELECT Enrollment, Denomination\nFROM school\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_tick().encode(\n    x='Enrollment:Q',\n    y='Denomination:O'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_strip_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "school_player",
        "chart_category": "Bar Charts",
        "chart_type": "faceted_stacked_bar_chart",
        "NLQ": "Can you create a chart showing the number of players in each position for different schools? I'd like to see the schools displayed in separate columns, with positions on the y-axis and the number of players on the x-axis. Please color-code the bars by team and add a title \"Distribution of Players by Position Across Schools\". Also, make sure to label the axes properly - \"School\" for columns, \"Position\" for y-axis, and \"Number of Players\" for x-axis. The data should come from my school_player database instead of the sample data in the original chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/school_player.sqlite')\n\nquery = '''\nSELECT \n    s.School AS School_Name,\n    p.Position,\n    p.Team,\n    COUNT(p.Player_ID) AS Player_Count\nFROM \n    player AS p\nJOIN \n    school AS s ON p.School_ID = s.School_ID\nGROUP BY \n    s.School, p.Position, p.Team\nORDER BY \n    s.School, p.Position\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    column=alt.Column(\"School_Name:N\", title=\"School\"),\n    x=alt.X(\"Player_Count:Q\", title=\"Number of Players\"),\n    y=alt.Y(\"Position:N\", title=\"Position\"),\n    color=alt.Color(\"Team:N\", title=\"Team\")\n).properties(\n    width=200,\n    title=\"Distribution of Players by Position Across Schools\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___faceted_stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "school_player",
        "chart_category": "Bar Charts",
        "chart_type": "faceted_stacked_bar_chart",
        "NLQ": "I have this barplot showing crop yields for different barley varieties across multiple sites and years. Could you change it to show the number of players in each position for different schools instead? I'd like to use data from our school database, with each school in its own column, positions on the y-axis, and bars colored by team. Make the chart title \"Distribution of Players by Position Across Schools\" and use Altair instead of matplotlib.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/school_player.sqlite')\n\nquery = '''\nSELECT \n    s.School AS School_Name,\n    p.Position,\n    p.Team,\n    COUNT(p.Player_ID) AS Player_Count\nFROM \n    player AS p\nJOIN \n    school AS s ON p.School_ID = s.School_ID\nGROUP BY \n    s.School, p.Position, p.Team\nORDER BY \n    s.School, p.Position\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    column=alt.Column(\"School_Name:N\", title=\"School\"),\n    x=alt.X(\"Player_Count:Q\", title=\"Number of Players\"),\n    y=alt.Y(\"Position:N\", title=\"Position\"),\n    color=alt.Color(\"Team:N\", title=\"Team\")\n).properties(\n    width=200,\n    title=\"Distribution of Players by Position Across Schools\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___faceted_stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "school_player",
        "chart_category": "Interactive Charts",
        "chart_type": "interval_selection_with_initial_date_range",
        "NLQ": "Can you create a line chart instead of an area chart that shows school enrollment numbers over time? I'd like to see the enrollment for each school plotted against the year they entered competition. Please add data points on the line and include tooltips so I can see the school name, year, and enrollment when I hover. Keep the interactive zoom feature that lets me focus on specific time periods, but make the charts wider (about 600px) and make the bottom overview chart shorter (about 60px). Also, please use more descriptive axis labels like \"Year Entered Competition\" and \"Enrollment\" instead of the default ones.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\nimport datetime as dt\n\nconn = sqlite3.connect('database/school_player.sqlite')\n\nquery = '''\nSELECT School, Year_Entered_Competition, Enrollment\nFROM school\nWHERE Year_Entered_Competition IS NOT NULL AND Enrollment IS NOT NULL\nORDER BY Year_Entered_Competition\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndate_range = (dt.date(1900, 1, 1), dt.date(2000, 1, 1))\nbrush = alt.selection_interval(encodings=['x'], value={'x': date_range})\n\nbase = alt.Chart(df, width=600, height=200).mark_line(point=True).encode(\n    x=alt.X('Year_Entered_Competition:T', title='Year Entered Competition'),\n    y=alt.Y('Enrollment:Q', title='Enrollment'),\n    tooltip=['School:N', 'Year_Entered_Competition:T', 'Enrollment:Q']\n)\n\nupper = base.encode(\n    alt.X('Year_Entered_Competition:T').scale(domain=brush)\n)\n\nlower = base.properties(\n    height=60\n).add_params(brush)\n\nchart = upper & lower\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___interval_selection_with_initial_date_range.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "scientist_1",
        "chart_category": "Simple Charts",
        "chart_type": "simple_strip_plot",
        "NLQ": "I have this chart showing horsepower for different numbers of cylinders. Could you create a similar chart but use my project data from the database instead? I'd like to see the project codes on the y-axis and the hours spent on each project on the x-axis. Just keep the same simple tick mark style.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/scientist_1.sqlite')\n\nquery = '''\nSELECT Code, Hours\nFROM Projects\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_tick().encode(\n    x='Hours:Q',\n    y='Code:O'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_strip_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "scientist_1",
        "chart_category": "Simple Charts",
        "chart_type": "simple_strip_plot",
        "NLQ": "I have this scatter plot showing horsepower and cylinders for cars, but I'd like to change it to show my project data instead. Can you create a strip plot that displays project codes on the y-axis and the hours spent on each project on the x-axis? I need to pull this data from my SQLite database called 'scientist_1.sqlite' instead of using random numbers. Please keep it simple and clean looking.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/scientist_1.sqlite')\nquery = '''\nSELECT Code, Hours\nFROM Projects\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_tick().encode(\n    x='Hours:Q',\n    y='Code:O'\n)\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_strip_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "scientist_1",
        "chart_category": "Bar Charts",
        "chart_type": "faceted_stacked_bar_chart",
        "NLQ": "I want to change my barley yield visualization to show data about scientists and their projects instead. Can you create a chart that shows how much time each scientist spent on different projects? I'd like to organize it so that each scientist has their own column, with bars showing the hours spent on each project. The bars should be colored by project name, and I want to include a title that says \"Total Hours Spent by Scientists on Projects\". Also, can you make each column a bit wider, around 200 pixels? The data should come from my scientist database instead of the CSV file.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/scientist_1.sqlite')\n\nquery = '''\nSELECT \n    S.Name AS ScientistName,\n    P.Name AS ProjectName,\n    SUM(P.Hours) AS TotalHours\nFROM \n    AssignedTo AS A\nJOIN \n    Scientists AS S ON A.Scientist = S.SSN\nJOIN \n    Projects AS P ON A.Project = P.Code\nGROUP BY \n    S.Name, P.Name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    column=alt.Column(\"ScientistName:N\", title=\"Scientist\"),\n    x=\"TotalHours:Q\",\n    y=\"ProjectName:N\",\n    color=\"ProjectName:N\"\n).properties(\n    width=200,\n    title=\"Total Hours Spent by Scientists on Projects\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___faceted_stacked_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "scientist_1",
        "chart_category": "Bar Charts",
        "chart_type": "faceted_stacked_bar_chart",
        "NLQ": "Instead of showing barley yields by variety and year, can you create a chart that shows how much time each scientist spent on different projects? I'd like to see each scientist have their own column with horizontal bars showing hours spent on each project. Please color-code the bars by project name and make the chart title \"Total Hours Spent by Scientists on Projects\". The data should come from our scientist database rather than using random numbers.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/scientist_1.sqlite')\n\nquery = '''\nSELECT \n    S.Name AS ScientistName,\n    P.Name AS ProjectName,\n    SUM(P.Hours) AS TotalHours\nFROM \n    AssignedTo AS A\nJOIN \n    Scientists AS S ON A.Scientist = S.SSN\nJOIN \n    Projects AS P ON A.Project = P.Code\nGROUP BY \n    S.Name, P.Name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    column=alt.Column(\"ScientistName:N\", title=\"Scientist\"),\n    x=\"TotalHours:Q\",\n    y=\"ProjectName:N\",\n    color=\"ProjectName:N\"\n).properties(\n    width=200,\n    title=\"Total Hours Spent by Scientists on Projects\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___faceted_stacked_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "ship_1",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart",
        "NLQ": "Can you change this bar chart to show the number of captains by their rank and ship class? I'd like to use real data from our ship database instead of the random crop yield data. Please add a title \"Number of Captains Grouped by Rank and Ship Class\" and make sure the x-axis shows captain ranks with proper labels. Keep the same layout with columns for different ship classes, but update the color coding to represent captain ranks instead of years. Also, can you label the y-axis as \"Number of Captains\"?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/ship_1.sqlite')\nquery = '''\nSELECT \n    c.Rank AS Captain_Rank, \n    c.Class AS Ship_Class, \n    COUNT(c.Captain_ID) AS Captain_Count\nFROM \n    captain AS c\nGROUP BY \n    c.Rank, c.Class\nORDER BY \n    c.Rank, c.Class;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Captain_Rank:N', title='Captain Rank'),\n    y=alt.Y('sum(Captain_Count):Q', title='Number of Captains'),\n    color=alt.Color('Captain_Rank:N', legend=alt.Legend(title=\"Rank\")),\n    column=alt.Column('Ship_Class:N', title='Ship Class')\n).properties(\n    title=\"Number of Captains Grouped by Rank and Ship Class\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___grouped_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "ship_1",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart",
        "NLQ": "Can you change my bar chart to show the number of captains by their rank and ship class? I'd like to pull this data from our ship database instead of using random numbers. Please organize it so we have separate columns for each ship class, with colored bars representing different captain ranks. Also, add a proper title that explains what we're looking at, and make sure the legend shows the different ranks clearly.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/ship_1.sqlite')\n\nquery = '''\nSELECT \n    c.Rank AS Captain_Rank, \n    c.Class AS Ship_Class, \n    COUNT(c.Captain_ID) AS Captain_Count\nFROM \n    captain AS c\nGROUP BY \n    c.Rank, c.Class\nORDER BY \n    c.Rank, c.Class;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Captain_Rank:N', title='Captain Rank'),\n    y=alt.Y('sum(Captain_Count):Q', title='Number of Captains'),\n    color=alt.Color('Captain_Rank:N', legend=alt.Legend(title=\"Rank\")),\n    column=alt.Column('Ship_Class:N', title='Ship Class')\n).properties(\n    title=\"Number of Captains Grouped by Rank and Ship Class\"\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___grouped_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "ship_1",
        "chart_category": "Interactive Charts",
        "chart_type": "multi-line_highlight",
        "NLQ": "Instead of using the stock price data in my example, can you create a line chart showing the number of ships built each year for different ship classes? I need to pull this data from my ship database using SQL. Keep the interactive hover effect that highlights the line when I mouse over it, and make the chart a bit wider at 600 pixels.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/ship_1.sqlite')\n\nquery = '''\nSELECT \n    Built_Year AS year,\n    Class AS ship_class,\n    COUNT(*) AS ship_count\nFROM \n    Ship\nGROUP BY \n    Built_Year, Class\nORDER BY \n    Built_Year ASC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nhighlight = alt.selection_point(on='pointerover', fields=['ship_class'], nearest=True)\n\nbase = alt.Chart(df).encode(\n    x='year:T',\n    y='ship_count:Q',\n    color='ship_class:N'\n)\n\npoints = base.mark_circle().encode(\n    opacity=alt.value(0)\n).add_params(\n    highlight\n).properties(\n    width=600\n)\n\nlines = base.mark_line().encode(\n    size=alt.when(~highlight).then(alt.value(1)).otherwise(alt.value(3))\n)\n\nchart = points + lines\nchart",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multi-line_highlight.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "ship_mission",
        "chart_category": "Interactive Charts",
        "chart_type": "multi-line_highlight",
        "NLQ": "Can you create a chart showing the average tonnage of ships by nationality across different years? I want to use my ship mission database instead of the stock data in the example. Only include ships launched after 1920, and group the data by both launch year and nationality. Keep the interactive feature where hovering over a line highlights it, and make the chart a bit wider than the default size.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/ship_mission.sqlite')\n\nquery = '''\nSELECT\n    M.Launched_Year,\n    S.Nationality,\n    AVG(S.Tonnage) AS AverageTonnage\nFROM ship AS S\nJOIN mission AS M\n    ON S.Ship_ID = M.Ship_ID\nWHERE M.Launched_Year > 1920\nGROUP BY\n    M.Launched_Year,\n    S.Nationality\nORDER BY\n    M.Launched_Year,\n    S.Nationality;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nhighlight = alt.selection_point(on='pointerover', fields=['Nationality'], nearest=True)\n\nbase = alt.Chart(df).encode(\n    x='Launched_Year:O',\n    y='AverageTonnage:Q',\n    color='Nationality:N'\n)\n\npoints = base.mark_circle().encode(\n    opacity=alt.value(0)\n).add_params(\n    highlight\n).properties(\n    width=600\n)\n\nlines = base.mark_line().encode(\n    size=alt.when(~highlight).then(alt.value(1)).otherwise(alt.value(3))\n)\n\npoints + lines",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multi-line_highlight.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "ship_mission",
        "chart_category": "Tables",
        "chart_type": "annual_weather_heatmap",
        "NLQ": "I need to create a heatmap showing the number of missions launched each year by different nationalities. Can you pull this data from our ship mission database? I'd like the years to be on the x-axis, nationalities on the y-axis, and the color intensity to represent the mission count. Please add a clear title like \"Number of Missions Launched Each Year by Nationality\" and make sure the axes are properly labeled as \"Launch Year\" and \"Nationality\". When users hover over the cells, they should see tooltips with the year, nationality, and exact mission count. Also, can you make the grid look clean by removing grid lines and borders?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/ship_mission.sqlite')\nquery = '''\nSELECT \n    s.Nationality AS Nationality,\n    m.Launched_Year AS Launched_Year,\n    COUNT(m.Mission_ID) AS Mission_Count\nFROM \n    mission AS m\nJOIN \n    ship AS s\nON \n    m.Ship_ID = s.Ship_ID\nGROUP BY \n    s.Nationality, m.Launched_Year\nORDER BY \n    s.Nationality, m.Launched_Year;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, title=\"Number of Missions Launched Each Year by Nationality\").mark_rect().encode(\n    alt.X(\"Launched_Year:O\").title(\"Launch Year\"),\n    alt.Y(\"Nationality:O\").title(\"Nationality\"),\n    alt.Color(\"Mission_Count:Q\").title(\"Missions\"),\n    tooltip=[\n        alt.Tooltip(\"Launched_Year\", title=\"Launch Year\"),\n        alt.Tooltip(\"Nationality\", title=\"Nationality\"),\n        alt.Tooltip(\"Mission_Count\", title=\"Mission Count\"),\n    ],\n).configure_view(\n    step=13,\n    strokeWidth=0\n).configure_axis(\n    domain=False\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Tables___annual_weather_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "ship_mission",
        "chart_category": "Tables",
        "chart_type": "annual_weather_heatmap",
        "NLQ": "Can you create a heatmap showing the number of missions launched each year by different nationalities? I need to pull this data from my ship_mission database. The chart should have launch years on the x-axis and nationalities on the y-axis, with colors representing the mission count. Please add a title \"Number of Missions Launched Each Year by Nationality\" and include tooltips so I can see the exact mission count when I hover over each cell. Make it clean-looking without grid lines or borders.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/ship_mission.sqlite')\n\nquery = '''\nSELECT \n    s.Nationality AS Nationality,\n    m.Launched_Year AS Launched_Year,\n    COUNT(m.Mission_ID) AS Mission_Count\nFROM \n    mission AS m\nJOIN \n    ship AS s\nON \n    m.Ship_ID = s.Ship_ID\nGROUP BY \n    s.Nationality, m.Launched_Year\nORDER BY \n    s.Nationality, m.Launched_Year;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, title=\"Number of Missions Launched Each Year by Nationality\").mark_rect().encode(\n    alt.X(\"Launched_Year:O\").title(\"Launch Year\"),\n    alt.Y(\"Nationality:O\").title(\"Nationality\"),\n    alt.Color(\"Mission_Count:Q\").title(\"Missions\"),\n    tooltip=[\n        alt.Tooltip(\"Launched_Year\", title=\"Launch Year\"),\n        alt.Tooltip(\"Nationality\", title=\"Nationality\"),\n        alt.Tooltip(\"Mission_Count\", title=\"Mission Count\"),\n    ],\n).configure_view(\n    step=13,\n    strokeWidth=0\n).configure_axis(\n    domain=False\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Tables___annual_weather_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "ship_mission",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart",
        "NLQ": "Instead of showing crop yields by year for different farm sites, can you create a chart that shows the total tonnage for each type of ship grouped by nationality? I want to pull this data from our ship mission database rather than using random data. Keep the same bar chart format with columns, but use nationality for the x-axis and color coding, and ship type for the column categories. Make sure to show the total tonnage on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/ship_mission.sqlite')\n\nquery = '''\nSELECT \n    Type, \n    Nationality, \n    SUM(Tonnage) AS Total_Tonnage\nFROM \n    ship\nGROUP BY \n    Type, \n    Nationality\nORDER BY \n    Type, \n    Nationality;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Nationality:N',\n    y='Total_Tonnage:Q',\n    color='Nationality:N',\n    column='Type:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___grouped_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "ship_mission",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart",
        "NLQ": "Instead of showing crop yields for different sites by year, can you create a chart that shows the total tonnage for each type of ship grouped by nationality? I'd like to see the data from our ship mission database, with each ship type in its own column, and bars colored by nationality so I can easily compare which countries have the most tonnage for each type of ship.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/ship_mission.sqlite')\n\nquery = '''\nSELECT \n    Type, \n    Nationality, \n    SUM(Tonnage) AS Total_Tonnage\nFROM \n    ship\nGROUP BY \n    Type, \n    Nationality\nORDER BY \n    Type, \n    Nationality;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Nationality:N',\n    y='Total_Tonnage:Q',\n    color='Nationality:N',\n    column='Type:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___grouped_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "shop_membership",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart",
        "NLQ": "Can you create a chart showing the number of member registrations by year for each city from 2016 to 2018? I'd like to see the data from our shop membership database with different colored bars for each year and separate panels for each city. I want to compare registration counts across different locations over these three years.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/shop_membership.sqlite')\n\nquery = '''\nSELECT \n    b.City AS City, \n    mrb.Register_Year AS Register_Year, \n    COUNT(mrb.Member_ID) AS Registration_Count\nFROM \n    membership_register_branch AS mrb\nJOIN \n    branch AS b ON mrb.Branch_ID = b.Branch_ID\nWHERE \n    mrb.Register_Year BETWEEN '2016' AND '2018'\nGROUP BY \n    b.City, mrb.Register_Year\nORDER BY \n    b.City, mrb.Register_Year;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Register_Year:O',\n    y='sum(Registration_Count):Q',\n    color='Register_Year:N',\n    column='City:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___grouped_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "shop_membership",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart",
        "NLQ": "Can you change my chart to show membership registration counts by city from 2016 to 2018? I'd like to see the data from our shop membership database instead of using random numbers. Please create separate columns for each city, color-code the bars by year, and pull the actual registration counts from our database. I want to see how many people signed up in different cities over those three years.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/shop_membership.sqlite')\nquery = '''\nSELECT \n    b.City AS City, \n    mrb.Register_Year AS Register_Year, \n    COUNT(mrb.Member_ID) AS Registration_Count\nFROM \n    membership_register_branch AS mrb\nJOIN \n    branch AS b ON mrb.Branch_ID = b.Branch_ID\nWHERE \n    mrb.Register_Year BETWEEN '2016' AND '2018'\nGROUP BY \n    b.City, mrb.Register_Year\nORDER BY \n    b.City, mrb.Register_Year;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Register_Year:O',\n    y='sum(Registration_Count):Q',\n    color='Register_Year:N',\n    column='City:N'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___grouped_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "shop_membership",
        "chart_category": "Tables",
        "chart_type": "annual_weather_heatmap",
        "NLQ": "Can you change this temperature calendar chart to show total purchase amounts by branch and year instead? I'd like a heatmap with branches on the y-axis and years on the x-axis, using different shades of blue to represent the purchase amounts in pounds. Please add a title \"Total Purchase Amounts by Branch and Year\" and make sure I can hover over each cell to see the branch name, year, and the exact purchase amount with two decimal places. Also, can you pull this data from my shop membership database instead of using the random temperature data?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/shop_membership.sqlite')\n\nquery = '''\nSELECT \n    b.Name AS Branch_Name,\n    p.Year AS Purchase_Year,\n    SUM(p.Total_pounds) AS Total_Purchase_Amount\nFROM \n    purchase AS p\nJOIN \n    branch AS b ON p.Branch_ID = b.Branch_ID\nGROUP BY \n    b.Name, p.Year\nORDER BY \n    b.Name, p.Year;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, title=\"Total Purchase Amounts by Branch and Year\").mark_rect().encode(\n    alt.X(\"Purchase_Year:O\").title(\"Year\"),\n    alt.Y(\"Branch_Name:O\").title(\"Branch\"),\n    alt.Color(\"Total_Purchase_Amount:Q\").title(\"Total Purchase Amount (£)\").scale(scheme=\"blues\"),\n    tooltip=[\n        alt.Tooltip(\"Branch_Name\", title=\"Branch\"),\n        alt.Tooltip(\"Purchase_Year\", title=\"Year\"),\n        alt.Tooltip(\"Total_Purchase_Amount\", title=\"Total Purchase Amount (£)\", format=\".2f\"),\n    ],\n).configure_view(\n    step=13,\n    strokeWidth=0\n).configure_axis(\n    domain=False\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Tables___annual_weather_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "shop_membership",
        "chart_category": "Tables",
        "chart_type": "annual_weather_heatmap",
        "NLQ": "Can you change this temperature heatmap to show total purchase amounts by branch and year instead? I'd like to use a database query to get the data from our shop membership database. Please use different shades of blue instead of the current color scheme, and add a proper title \"Total Purchase Amounts by Branch and Year\". Also, make it interactive so I can hover over each cell to see the branch name, year, and exact purchase amount in pounds. Can you label the axes as \"Year\" and \"Branch\" too?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/shop_membership.sqlite')\n\nquery = '''\nSELECT \n    b.Name AS Branch_Name,\n    p.Year AS Purchase_Year,\n    SUM(p.Total_pounds) AS Total_Purchase_Amount\nFROM \n    purchase AS p\nJOIN \n    branch AS b ON p.Branch_ID = b.Branch_ID\nGROUP BY \n    b.Name, p.Year\nORDER BY \n    b.Name, p.Year;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, title=\"Total Purchase Amounts by Branch and Year\").mark_rect().encode(\n    alt.X(\"Purchase_Year:O\").title(\"Year\"),\n    alt.Y(\"Branch_Name:O\").title(\"Branch\"),\n    alt.Color(\"Total_Purchase_Amount:Q\").title(\"Total Purchase Amount (£)\").scale(scheme=\"blues\"),\n    tooltip=[\n        alt.Tooltip(\"Branch_Name\", title=\"Branch\"),\n        alt.Tooltip(\"Purchase_Year\", title=\"Year\"),\n        alt.Tooltip(\"Total_Purchase_Amount\", title=\"Total Purchase Amount (£)\", format=\".2f\"),\n    ],\n).configure_view(\n    step=13,\n    strokeWidth=0\n).configure_axis(\n    domain=False\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Tables___annual_weather_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "singer",
        "chart_category": "Tables",
        "chart_type": "annual_weather_heatmap",
        "NLQ": "I want to create a heatmap showing the best chart positions achieved by songs, organized by the singer's birth year. Instead of using the temperature data from the example, can you use my singer database to show song titles on the x-axis and birth years on the y-axis? The color should represent the highest chart position each song reached. Please add a title \"Best Chart Positions by Singer Birth Year\" and make sure the axis titles are clear. I'd also like to remove grid lines and axis borders to make it look cleaner.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/singer.sqlite')\n\nquery = '''\nSELECT \n    s.Birth_Year AS Singer_Birth_Year,\n    so.Title AS Song_Title,\n    MIN(so.Highest_Position) AS Best_Position\nFROM \n    singer AS s\nJOIN \n    song AS so\nON \n    s.Singer_ID = so.Singer_ID\nGROUP BY \n    s.Birth_Year, so.Title\nORDER BY \n    s.Birth_Year ASC, Best_Position ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, title=\"Best Chart Positions by Singer Birth Year\").mark_rect().encode(\n    alt.X(\"Song_Title:N\").title(\"Song Title\"),\n    alt.Y(\"Singer_Birth_Year:N\").title(\"Singer Birth Year\"),\n    alt.Color(\"Best_Position:Q\").title(\"Highest Position\"),\n    tooltip=[\n        alt.Tooltip(\"Song_Title\", title=\"Song Title\"),\n        alt.Tooltip(\"Singer_Birth_Year\", title=\"Singer Birth Year\"),\n        alt.Tooltip(\"Best_Position\", title=\"Best Position\"),\n    ],\n).configure_view(\n    step=13,\n    strokeWidth=0\n).configure_axis(\n    domain=False\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Tables___annual_weather_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "singer",
        "chart_category": "Tables",
        "chart_type": "annual_weather_heatmap",
        "NLQ": "Instead of showing temperature data by month and day, can you create a heatmap that shows song performance data? I'd like to see the best chart positions achieved by songs, organized by the singer's birth year. Use data from the singer database instead of the random temperature data. Make sure to include the song title on one axis and the singer's birth year on the other axis, with colors representing the highest chart position each song reached. Also, add tooltips so I can see more details when I hover over each cell, and give the chart a clear title like \"Best Chart Positions by Singer Birth Year\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/singer.sqlite')\n\nquery = '''\nSELECT \n    s.Birth_Year AS Singer_Birth_Year,\n    so.Title AS Song_Title,\n    MIN(so.Highest_Position) AS Best_Position\nFROM \n    singer AS s\nJOIN \n    song AS so\nON \n    s.Singer_ID = so.Singer_ID\nGROUP BY \n    s.Birth_Year, so.Title\nORDER BY \n    s.Birth_Year ASC, Best_Position ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, title=\"Best Chart Positions by Singer Birth Year\").mark_rect().encode(\n    alt.X(\"Song_Title:N\").title(\"Song Title\"),\n    alt.Y(\"Singer_Birth_Year:N\").title(\"Singer Birth Year\"),\n    alt.Color(\"Best_Position:Q\").title(\"Highest Position\"),\n    tooltip=[\n        alt.Tooltip(\"Song_Title\", title=\"Song Title\"),\n        alt.Tooltip(\"Singer_Birth_Year\", title=\"Singer Birth Year\"),\n        alt.Tooltip(\"Best_Position\", title=\"Best Position\"),\n    ],\n).configure_view(\n    step=13,\n    strokeWidth=0\n).configure_axis(\n    domain=False\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Tables___annual_weather_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "singer",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_error_bars",
        "NLQ": "Could you help me create a chart that shows the average net worth of singers grouped by where they're from, with some indication of how much the values vary? I'd like to see bars in different colors for each country, with error bars showing the minimum and maximum net worth values instead of standard deviation. Please add a clear title like \"Comparison of Average Net Worth by Citizenship with Variability\" and make sure the y-axis is labeled as \"Average Net Worth (Millions)\". I need this data to come from the singer database we have, not the sample data in the previous chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/singer.sqlite')\nquery = '''\nSELECT Citizenship, AVG(Net_Worth_Millions) AS Avg_Net_Worth, \n       COUNT(*) AS Singer_Count, \n       MIN(Net_Worth_Millions) AS Min_Net_Worth, \n       MAX(Net_Worth_Millions) AS Max_Net_Worth\nFROM singer\nGROUP BY Citizenship\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbars = alt.Chart(df).mark_bar().encode(\n    x='Citizenship:N',\n    y=alt.Y('Avg_Net_Worth:Q').title('Average Net Worth (Millions)'),\n    color='Citizenship:N'\n)\n\nerror_bars = alt.Chart(df).mark_errorbar(extent='ci').encode(\n    x='Citizenship:N',\n    y=alt.Y('Min_Net_Worth:Q').title('Net Worth Range'),\n    y2='Max_Net_Worth:Q'\n)\n\nchart = alt.layer(bars, error_bars).properties(\n    title='Comparison of Average Net Worth by Citizenship with Variability'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___grouped_bar_chart_with_error_bars.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "singer",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_error_bars",
        "NLQ": "Could you help me create a chart that shows the average net worth of singers grouped by where they're from, with some indication of how much the values vary? I'd like it to have bars in different colors for each citizenship group and lines showing the range of their net worth. Please pull the data from the singer database and give the chart a clear title that explains what we're looking at.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/singer.sqlite')\n\nquery = '''\nSELECT Citizenship, AVG(Net_Worth_Millions) AS Avg_Net_Worth, \n       COUNT(*) AS Singer_Count, \n       MIN(Net_Worth_Millions) AS Min_Net_Worth, \n       MAX(Net_Worth_Millions) AS Max_Net_Worth\nFROM singer\nGROUP BY Citizenship\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbars = alt.Chart(df).mark_bar().encode(\n    x='Citizenship:N',\n    y=alt.Y('Avg_Net_Worth:Q').title('Average Net Worth (Millions)'),\n    color='Citizenship:N'\n)\n\nerror_bars = alt.Chart(df).mark_errorbar(extent='ci').encode(\n    x='Citizenship:N',\n    y=alt.Y('Min_Net_Worth:Q').title('Net Worth Range'),\n    y2='Max_Net_Worth:Q'\n)\n\nchart = alt.layer(bars, error_bars).properties(\n    title='Comparison of Average Net Worth by Citizenship with Variability'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___grouped_bar_chart_with_error_bars.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "soccer_1",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_error_bars",
        "NLQ": "Can you change this chart to show soccer player data instead of crop yields? I want to compare the average overall rating and potential rating for players based on their preferred foot (left or right). Keep the bar chart with error bars showing variation, but organize it so we can see the ratings side by side for each foot preference. Get the data from my soccer database instead of using random numbers. Also, please add proper titles for the axes - \"Preferred Foot\" on the x-axis and \"Average Rating\" on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/soccer_1.sqlite')\nquery = '''\nSELECT \n    preferred_foot,\n    AVG(overall_rating) AS avg_overall_rating,\n    AVG(potential) AS avg_potential,\n    COUNT(*) AS count\nFROM Player_Attributes\nWHERE overall_rating IS NOT NULL AND potential IS NOT NULL\nGROUP BY preferred_foot\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['preferred_foot'], \n                    value_vars=['avg_overall_rating', 'avg_potential'], \n                    var_name='rating_type', \n                    value_name='average_value')\n\nbars = alt.Chart(df_melted).mark_bar().encode(\n    x=alt.X('preferred_foot:N').title('Preferred Foot'),\n    y=alt.Y('average_value:Q').title('Average Rating'),\n    color=alt.Color('rating_type:N').title('Rating Type')\n)\n\nerror_bars = alt.Chart(df_melted).mark_errorbar(extent='stdev').encode(\n    x=alt.X('preferred_foot:N'),\n    y=alt.Y('average_value:Q')\n)\n\nchart = alt.layer(bars, error_bars).facet(\n    column=alt.Column('rating_type:N').title('Rating Type')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___grouped_bar_chart_with_error_bars.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "soccer_1",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_error_bars",
        "NLQ": "Can you create a chart that shows soccer player statistics instead of crop yields? I'd like to compare the average overall rating and potential rating for players based on their preferred foot (left or right). Please use data from the soccer database and display it as a grouped bar chart with error bars. Instead of having multiple small charts side by side, I'd prefer to have the rating types (overall and potential) separated into different columns. Also, can you add proper titles for the axes and include a color legend to distinguish between the rating types?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/soccer_1.sqlite')\nquery = '''\nSELECT \n    preferred_foot,\n    AVG(overall_rating) AS avg_overall_rating,\n    AVG(potential) AS avg_potential,\n    COUNT(*) AS count\nFROM Player_Attributes\nWHERE overall_rating IS NOT NULL AND potential IS NOT NULL\nGROUP BY preferred_foot\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=['preferred_foot'], \n                    value_vars=['avg_overall_rating', 'avg_potential'], \n                    var_name='rating_type', \n                    value_name='average_value')\n\nbars = alt.Chart(df_melted).mark_bar().encode(\n    x=alt.X('preferred_foot:N').title('Preferred Foot'),\n    y=alt.Y('average_value:Q').title('Average Rating'),\n    color=alt.Color('rating_type:N').title('Rating Type')\n)\n\nerror_bars = alt.Chart(df_melted).mark_errorbar(extent='stdev').encode(\n    x=alt.X('preferred_foot:N'),\n    y=alt.Y('average_value:Q')\n)\n\nchart = alt.layer(bars, error_bars).facet(\n    column=alt.Column('rating_type:N').title('Rating Type')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___grouped_bar_chart_with_error_bars.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "sports_competition",
        "chart_category": "Tables",
        "chart_type": "lasagna_plot_dense_time-series_heatmap",
        "NLQ": "I'd like to create a heatmap showing total medals won by sports clubs over the years. Can you use our sports competition database instead of the stock price data? I want to see each club listed vertically and years horizontally, with a blue color scheme where darker blues represent more medals. Please add a clear title \"Total Medals Won by Clubs Over Time\" and proper axis labels for \"Year\" and \"Club\". Make the chart about 400 pixels wide and 200 pixels tall.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/sports_competition.sqlite')\n\nquery = '''\nSELECT \n    c.name AS Club_Name,\n    cr.Year AS Year,\n    SUM(clr.Gold + clr.Silver + clr.Bronze) AS Total_Medals\nFROM \n    club AS c\nJOIN \n    club_rank AS clr ON c.Club_ID = clr.Club_ID\nJOIN \n    competition AS cr ON cr.Competition_ID = clr.Club_ID\nGROUP BY \n    c.name, cr.Year\nORDER BY \n    cr.Year, c.name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = (\n    alt.Chart(df, width=400, height=200)\n    .mark_rect()\n    .encode(\n        alt.X(\"Year:O\").title(\"Year\"),\n        alt.Y(\"Club_Name:N\").title(\"Club\"),\n        alt.Color(\"Total_Medals:Q\")\n        .title(\"Total Medals\")\n        .scale(scheme=\"blues\"),\n    )\n    .properties(title=\"Total Medals Won by Clubs Over Time\")\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Tables___lasagna_plot_dense_time-series_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "sports_competition",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_xoffset",
        "NLQ": "Can you create a chart showing the medal counts for the top 3 clubs in our sports competition? I'd like to see how many gold, silver, and bronze medals each club has won, displayed as grouped bars. Please use different colors for each medal type, put the club names along the bottom axis, and label the vertical axis as \"Medal Count\". Also, add a title that says \"Medal Counts by Top 3 Clubs\". You'll need to pull this data from our sports competition database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/sports_competition.sqlite')\n\nquery = '''\nSELECT \n    c.name AS Club_Name,\n    cr.Gold,\n    cr.Silver,\n    cr.Bronze\nFROM \n    club_rank AS cr\nJOIN \n    club AS c ON cr.Club_ID = c.Club_ID\nWHERE \n    cr.Rank <= 3\nORDER BY \n    cr.Rank;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=[\"Club_Name\"], value_vars=[\"Gold\", \"Silver\", \"Bronze\"], \n                    var_name=\"Medal_Type\", value_name=\"Count\")\n\nchart = alt.Chart(df_melted).mark_bar().encode(\n    x=alt.X(\"Club_Name:N\", title=\"Club\"),\n    y=alt.Y(\"Count:Q\", title=\"Medal Count\"),\n    xOffset=\"Medal_Type:N\",\n    color=alt.Color(\"Medal_Type:N\", title=\"Medal Type\")\n).properties(\n    title=\"Medal Counts by Top 3 Clubs\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___grouped_bar_chart_with_xoffset.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "sports_competition",
        "chart_category": "Bar Charts",
        "chart_type": "grouped_bar_chart_with_xoffset",
        "NLQ": "I want to create a chart showing medal counts for the top 3 clubs in our sports competition. Can you make a grouped bar chart that displays gold, silver, and bronze medals for each club? I need to pull this data from our sports_competition database instead of using the sample data in the example. Please label the x-axis as \"Club\" and the y-axis as \"Medal Count\", and add a title \"Medal Counts by Top 3 Clubs\". Make sure each medal type has a different color and include a legend showing what each color represents.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/sports_competition.sqlite')\n\nquery = '''\nSELECT \n    c.name AS Club_Name,\n    cr.Gold,\n    cr.Silver,\n    cr.Bronze\nFROM \n    club_rank AS cr\nJOIN \n    club AS c ON cr.Club_ID = c.Club_ID\nWHERE \n    cr.Rank <= 3\nORDER BY \n    cr.Rank;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\ndf_melted = df.melt(id_vars=[\"Club_Name\"], value_vars=[\"Gold\", \"Silver\", \"Bronze\"], \n                    var_name=\"Medal_Type\", value_name=\"Count\")\n\nchart = alt.Chart(df_melted).mark_bar().encode(\n    x=alt.X(\"Club_Name:N\", title=\"Club\"),\n    y=alt.Y(\"Count:Q\", title=\"Medal Count\"),\n    xOffset=\"Medal_Type:N\",\n    color=alt.Color(\"Medal_Type:N\", title=\"Medal Type\")\n).properties(\n    title=\"Medal Counts by Top 3 Clubs\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___grouped_bar_chart_with_xoffset.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "station_weather",
        "chart_category": "Tables",
        "chart_type": "lasagna_plot_dense_time-series_heatmap",
        "NLQ": "Can you create a heatmap showing high temperatures by day of the week for different weather stations? I'd like to see each station listed on the y-axis and the days of the week across the x-axis. Use color to represent the temperature values, with a color scale that shows how hot it gets. Please add proper titles to the chart and axes - call it \"High Temperatures by Station and Day of Week\" and make sure the x-axis says \"Day of Week\", the y-axis says \"Station\", and the color legend says \"High Temperature (°F)\". Can you pull this data from my weather database instead of using the stock data in my example?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/station_weather.sqlite')\n\nquery = '''\nSELECT \n    s.network_name AS station_name,\n    w.day_of_week,\n    w.high_temperature\nFROM \n    weekly_weather AS w\nJOIN \n    station AS s\nON \n    w.station_id = s.id\nORDER BY \n    s.network_name, \n    CASE w.day_of_week \n        WHEN 'Monday' THEN 1\n        WHEN 'Tuesday' THEN 2\n        WHEN 'Wednesday' THEN 3\n        WHEN 'Thursday' THEN 4\n        WHEN 'Friday' THEN 5\n        WHEN 'Saturday' THEN 6\n        WHEN 'Sunday' THEN 7\n    END\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, width=400, height=200).mark_rect().encode(\n    alt.X(\"day_of_week:N\").title(\"Day of Week\"),\n    alt.Y(\"station_name:N\").title(\"Station\"),\n    alt.Color(\"high_temperature:Q\").title(\"High Temperature (°F)\").scale(scheme=\"viridis\")\n).properties(\n    title=\"High Temperatures by Station and Day of Week\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Tables___lasagna_plot_dense_time-series_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "storm_record",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_bar_chart",
        "NLQ": "I want to create a horizontal bar chart showing how many cities were affected by storms in different regions. Can you pull this data from the storm_record database? I'd like the regions listed on the y-axis and the number of affected cities on the x-axis. Please sort the regions so the ones with the most affected cities appear at the top, and add appropriate titles for the chart and axes. The chart should be titled \"Total Cities Affected by Storms in Each Region\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/storm_record.sqlite')\n\nquery = '''\nSELECT \n    r.Region_name AS Region,\n    SUM(ar.Number_city_affected) AS Total_Cities_Affected\nFROM \n    affected_region AS ar\nJOIN \n    region AS r ON ar.Region_id = r.Region_id\nGROUP BY \n    r.Region_name\nORDER BY \n    Total_Cities_Affected DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Total_Cities_Affected:Q', title='Total Cities Affected'),\n    y=alt.Y('Region:O', sort='-x', title='Region')\n).properties(\n    title='Total Cities Affected by Storms in Each Region'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Bar Charts___horizontal_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "storm_record",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_bar_chart",
        "NLQ": "Instead of showing wheat production by year, I want to create a chart that shows how many cities were affected by storms in different regions. Can you pull this data from the storm_record database? I'd like horizontal bars where the regions are listed on the side and the number of cities affected is shown across. Also, can the regions be sorted so the ones with the most affected cities appear at the top? And please add a title that says \"Total Cities Affected by Storms in Each Region.\"",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/storm_record.sqlite')\n\nquery = '''\nSELECT \n    r.Region_name AS Region,\n    SUM(ar.Number_city_affected) AS Total_Cities_Affected\nFROM \n    affected_region AS ar\nJOIN \n    region AS r ON ar.Region_id = r.Region_id\nGROUP BY \n    r.Region_name\nORDER BY \n    Total_Cities_Affected DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('Total_Cities_Affected:Q', title='Total Cities Affected'),\n    y=alt.Y('Region:O', sort='-x', title='Region')\n).properties(\n    title='Total Cities Affected by Storms in Each Region'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___horizontal_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "student_assessment",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_bar_chart",
        "NLQ": "Can you create a horizontal bar chart that shows how many courses each student has registered for? I'd like to see the student names listed on the y-axis and the number of courses they've taken on the x-axis. Please sort it so students with the most courses appear at the top. Add a title that says \"Number of Courses Registered per Student\" and make sure the axis labels are clear. You'll need to pull this data from our student database - specifically connecting student names with how many courses they've registered for.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/student_assessment.sqlite')\n\nquery = '''\nSELECT \n    s.student_id,\n    p.first_name || ' ' || p.last_name AS student_name,\n    COUNT(sc.course_id) AS course_count\nFROM \n    Students AS s\nJOIN \n    People AS p ON s.student_id = p.person_id\nLEFT JOIN \n    Student_Course_Registrations AS sc ON s.student_id = sc.student_id\nGROUP BY \n    s.student_id, student_name\nORDER BY \n    course_count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('course_count:Q', title='Number of Courses Registered'),\n    y=alt.Y('student_name:O', sort='-x', title='Student Name')\n).properties(\n    title='Number of Courses Registered per Student'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___horizontal_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "student_assessment",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_bar_chart",
        "NLQ": "Can you create a horizontal bar chart that shows how many courses each student has registered for? I'd like to see the student names listed on the y-axis and the number of courses on the x-axis. Please sort it so students with the most courses appear at the top. Add a clear title like \"Number of Courses Registered per Student\" and make sure the axis labels are descriptive. I need this data to come from our student database, specifically showing each student's full name and their course count.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/student_assessment.sqlite')\n\nquery = '''\nSELECT \n    s.student_id,\n    p.first_name || ' ' || p.last_name AS student_name,\n    COUNT(sc.course_id) AS course_count\nFROM \n    Students AS s\nJOIN \n    People AS p ON s.student_id = p.person_id\nLEFT JOIN \n    Student_Course_Registrations AS sc ON s.student_id = sc.student_id\nGROUP BY \n    s.student_id, student_name\nORDER BY \n    course_count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x=alt.X('course_count:Q', title='Number of Courses Registered'),\n    y=alt.Y('student_name:O', sort='-x', title='Student Name')\n).properties(\n    title='Number of Courses Registered per Student'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___horizontal_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "student_assessment",
        "chart_category": "Interactive Charts",
        "chart_type": "multiple_interactions",
        "NLQ": "I have a student assessment database that I'd like to visualize. Can you create a scatter plot showing the relationship between when students attended courses and when they took their assessments? I want to be able to filter the chart by qualification type using a dropdown menu, and I'd like to highlight whether students passed or failed their assessments using green and red colors with a radio button selector. Also, could you add a checkbox that lets me resize the points based on how many courses each student has taken? Make sure to include tooltips with student ID, course ID, qualification, and assessment outcome when hovering over points.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/student_assessment.sqlite')\n\nquery = '''\nSELECT \n    sca.student_id,\n    sca.course_id,\n    sca.date_of_attendance,\n    ca.qualification,\n    ca.assessment_date,\n    ca.asessment_outcome_code,\n    COUNT(sca.course_id) OVER (PARTITION BY sca.student_id) AS course_count\nFROM \n    Student_Course_Attendance AS sca\nJOIN \n    Candidates AS c ON sca.student_id = c.candidate_id\nJOIN \n    Candidate_Assessments AS ca ON c.candidate_id = ca.candidate_id\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\ndf['date_of_attendance'] = pd.to_datetime(df['date_of_attendance'])\ndf['assessment_date'] = pd.to_datetime(df['assessment_date'])\n\nbase = alt.Chart(df).mark_circle().encode(\n    x=alt.X('date_of_attendance:T', title='Date of Attendance'),\n    y=alt.Y('assessment_date:T', title='Assessment Date'),\n    tooltip=['student_id:N', 'course_id:N', 'qualification:N', 'asessment_outcome_code:N']\n)\n\nqualification_dropdown = alt.binding_select(options=df['qualification'].unique().tolist(), name=\"Qualification: \")\nqualification_select = alt.selection_point(fields=['qualification'], bind=qualification_dropdown)\n\nfilter_qualification = base.add_params(\n    qualification_select\n).transform_filter(\n    qualification_select\n).properties(title=\"Filter by Qualification\")\n\noutcome_radio = alt.binding_radio(options=['Pass', 'Fail'], name=\"Outcome: \")\noutcome_select = alt.selection_point(fields=['asessment_outcome_code'], bind=outcome_radio)\n\ncolor_condition = (\n    alt.when(outcome_select)\n    .then(alt.Color('asessment_outcome_code:N').scale(domain=['Pass', 'Fail'], range=['green', 'red']))\n    .otherwise(alt.value('lightgray'))\n)\n\nhighlight_outcomes = base.add_params(\n    outcome_select\n).encode(\n    color=color_condition\n).properties(title=\"Highlight by Outcome\")\n\nsize_checkbox = alt.binding_checkbox(name=\"Highlight Multiple Course Attendees: \")\nsize_select = alt.param(bind=size_checkbox)\n\nsize_condition = (\n    alt.when(size_select)\n    .then(alt.Size('course_count:Q').scale(range=[50, 200]))\n    .otherwise(alt.value(50))\n)\n\ntoggle_size = base.add_params(\n    size_select\n).encode(\n    size=size_condition\n).properties(title=\"Toggle Size by Course Count\")\n\n(filter_qualification | highlight_outcomes) & toggle_size",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___multiple_interactions.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "student_assessment",
        "chart_category": "Tables",
        "chart_type": "text_over_a_heatmap",
        "NLQ": "Can you create a heatmap showing the average attendance for courses in different cities? I'd like to have course names along the bottom and cities on the left side. Use a viridis color scheme where darker colors represent higher attendance values, and include the actual attendance numbers on each cell formatted with two decimal places. Make the text black for values above the average attendance and white for values below. Also, please add a title at the top that says \"Average Course Attendance by City and Course Name\" and label the color legend as \"Average Attendance\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/student_assessment.sqlite')\n\nquery = '''\nSELECT \n    a.city AS City,\n    c.course_name AS Course_Name,\n    COUNT(sca.student_id) * 1.0 / COUNT(DISTINCT sca.student_id) AS Avg_Attendance\nFROM \n    Student_Course_Attendance sca\nJOIN \n    Courses c ON sca.course_id = c.course_id\nJOIN \n    Students s ON sca.student_id = s.student_id\nJOIN \n    People p ON s.student_id = p.person_id\nJOIN \n    People_Addresses pa ON p.person_id = pa.person_id\nJOIN \n    Addresses a ON pa.address_id = a.address_id\nGROUP BY \n    a.city, c.course_name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.X('Course_Name:O', title='Course Name'),\n    alt.Y('City:O', title='City')\n)\n\nheatmap = base.mark_rect().encode(\n    alt.Color('Avg_Attendance:Q')\n        .scale(scheme='viridis')\n        .title(\"Average Attendance\")\n)\n\ntext = base.mark_text(baseline='middle').encode(\n    alt.Text('Avg_Attendance:Q', format=\".2f\"),\n    color=alt.condition(\n        alt.datum.Avg_Attendance > df['Avg_Attendance'].mean(),\n        alt.value(\"black\"),\n        alt.value(\"white\")\n    )\n)\n\nchart = heatmap + text\nchart.properties(title=\"Average Course Attendance by City and Course Name\")",
        "reference_path": "./vis_bench/code/altair/Tables___text_over_a_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "student_assessment",
        "chart_category": "Tables",
        "chart_type": "text_over_a_heatmap",
        "NLQ": "Can you change my heatmap to show average course attendance by city instead of horsepower by car origin and cylinders? I need to pull the data from our student assessment database instead of using the car data. Keep the color gradient style but make the title \"Average Course Attendance by City and Course Name\". Also, can you make it so the text on each cell is white when the value is below average and black when it's above average? And display the attendance values with two decimal places instead of whole numbers.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/student_assessment.sqlite')\n\nquery = '''\nSELECT \n    a.city AS City,\n    c.course_name AS Course_Name,\n    COUNT(sca.student_id) * 1.0 / COUNT(DISTINCT sca.student_id) AS Avg_Attendance\nFROM \n    Student_Course_Attendance sca\nJOIN \n    Courses c ON sca.course_id = c.course_id\nJOIN \n    Students s ON sca.student_id = s.student_id\nJOIN \n    People p ON s.student_id = p.person_id\nJOIN \n    People_Addresses pa ON p.person_id = pa.person_id\nJOIN \n    Addresses a ON pa.address_id = a.address_id\nGROUP BY \n    a.city, c.course_name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.X('Course_Name:O', title='Course Name'),\n    alt.Y('City:O', title='City')\n)\n\nheatmap = base.mark_rect().encode(\n    alt.Color('Avg_Attendance:Q')\n        .scale(scheme='viridis')\n        .title(\"Average Attendance\")\n)\n\ntext = base.mark_text(baseline='middle').encode(\n    alt.Text('Avg_Attendance:Q', format=\".2f\"),\n    color=alt.condition(\n        alt.datum.Avg_Attendance > df['Avg_Attendance'].mean(),\n        alt.value(\"black\"),\n        alt.value(\"white\")\n    )\n)\n\nchart = heatmap + text\nchart.properties(title=\"Average Course Attendance by City and Course Name\")",
        "reference_path": "./vis_bench/code/matplotlib/Tables___text_over_a_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "student_transcripts_tracking",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_bar_chart",
        "NLQ": "Can you change this bar chart to show how many courses each student is enrolled in, grouped by their degree program? I want to see the degree programs on the y-axis and the number of courses on the x-axis. Please sort it so the degree programs with the highest course counts appear at the top. Use different colors for each degree program and make it so when I hover over a bar, I can see the student's name and how many courses they're taking. Also, add a title that says \"Number of Courses Enrolled per Student Grouped by Degree Program\". The data should come from my student database instead of the random wheat values.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/student_transcripts_tracking.sqlite')\n\nquery = '''\nSELECT \n    dp.degree_summary_name AS Degree_Program,\n    s.first_name || ' ' || s.last_name AS Student_Name,\n    COUNT(sec.course_id) AS Course_Count\nFROM \n    Student_Enrolment AS se\nJOIN \n    Degree_Programs AS dp ON se.degree_program_id = dp.degree_program_id\nJOIN \n    Students AS s ON se.student_id = s.student_id\nJOIN \n    Student_Enrolment_Courses AS sec ON se.student_enrolment_id = sec.student_enrolment_id\nGROUP BY \n    dp.degree_summary_name, s.student_id\nORDER BY \n    dp.degree_summary_name, Course_Count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Course_Count:Q',\n    y=alt.Y('Degree_Program:N', sort='-x'),\n    color='Degree_Program:N',\n    tooltip=['Student_Name:N', 'Course_Count:Q']\n).properties(\n    title=\"Number of Courses Enrolled per Student Grouped by Degree Program\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___horizontal_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "student_transcripts_tracking",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_bar_chart",
        "NLQ": "Can you help me create a chart that shows how many courses each student is enrolled in, grouped by their degree program? I'd like to see a horizontal bar chart where the degree programs are sorted by the number of courses, with different colors for each degree program. When I hover over the bars, I want to see the student name and the exact number of courses they're taking. Please pull this data from our student database and give the chart a clear title that explains what we're looking at.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/student_transcripts_tracking.sqlite')\n\nquery = '''\nSELECT \n    dp.degree_summary_name AS Degree_Program,\n    s.first_name || ' ' || s.last_name AS Student_Name,\n    COUNT(sec.course_id) AS Course_Count\nFROM \n    Student_Enrolment AS se\nJOIN \n    Degree_Programs AS dp ON se.degree_program_id = dp.degree_program_id\nJOIN \n    Students AS s ON se.student_id = s.student_id\nJOIN \n    Student_Enrolment_Courses AS sec ON se.student_enrolment_id = sec.student_enrolment_id\nGROUP BY \n    dp.degree_summary_name, s.student_id\nORDER BY \n    dp.degree_summary_name, Course_Count DESC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Course_Count:Q',\n    y=alt.Y('Degree_Program:N', sort='-x'),\n    color='Degree_Program:N',\n    tooltip=['Student_Name:N', 'Course_Count:Q']\n).properties(\n    title=\"Number of Courses Enrolled per Student Grouped by Degree Program\"\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___horizontal_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "student_transcripts_tracking",
        "chart_category": "Tables",
        "chart_type": "text_over_a_heatmap",
        "NLQ": "Can you create a heatmap showing the average number of courses students are enrolled in for each degree program and semester? I'd like to see the degree programs on the y-axis and semesters on the x-axis. Use a viridis color scheme where darker colors represent higher enrollment numbers, and display the actual average values as text on each cell (with one decimal place). Make text black for cells with more than 5 courses and white for others. Also, please add a title \"Average Courses Enrolled by Degree Program and Semester\" and make sure the color legend is labeled \"Average Courses Enrolled\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/student_transcripts_tracking.sqlite')\n\nquery = '''\nSELECT \n    dp.degree_summary_name AS Degree_Program,\n    s.semester_name AS Semester,\n    AVG(COUNT(sec.course_id)) OVER (PARTITION BY dp.degree_summary_name, s.semester_name) AS Avg_Courses_Enrolled\nFROM \n    Student_Enrolment AS se\nJOIN \n    Degree_Programs AS dp ON se.degree_program_id = dp.degree_program_id\nJOIN \n    Semesters AS s ON se.semester_id = s.semester_id\nJOIN \n    Student_Enrolment_Courses AS sec ON se.student_enrolment_id = sec.student_enrolment_id\nGROUP BY \n    dp.degree_summary_name, s.semester_name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.X('Semester:O', title='Semester'),\n    alt.Y('Degree_Program:O', title='Degree Program')\n)\n\nheatmap = base.mark_rect().encode(\n    alt.Color('Avg_Courses_Enrolled:Q')\n        .scale(scheme='viridis')\n        .title(\"Average Courses Enrolled\")\n)\n\ncolor = (\n    alt.when(alt.datum.Avg_Courses_Enrolled > 5)\n    .then(alt.value(\"black\"))\n    .otherwise(alt.value(\"white\"))\n)\n\ntext = base.mark_text(baseline='middle').encode(\n    alt.Text('Avg_Courses_Enrolled:Q', format=\".1f\"), color=color\n)\n\nchart = heatmap + text\nchart.properties(title=\"Average Courses Enrolled by Degree Program and Semester\")",
        "reference_path": "./vis_bench/code/altair/Tables___text_over_a_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "student_transcripts_tracking",
        "chart_category": "Tables",
        "chart_type": "text_over_a_heatmap",
        "NLQ": "I have this heatmap showing horsepower by origin and cylinders, but I need to change it to show average courses enrolled by degree program and semester instead. Can you pull this data from our student database and display it as a color-coded grid? I'd like to keep the text values on each cell, but make them black on dark cells and white on light cells for better readability. Also, please add a title that says \"Average Courses Enrolled by Degree Program and Semester\" and format the numbers to show one decimal place.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/student_transcripts_tracking.sqlite')\n\nquery = '''\nSELECT \n    dp.degree_summary_name AS Degree_Program,\n    s.semester_name AS Semester,\n    AVG(COUNT(sec.course_id)) OVER (PARTITION BY dp.degree_summary_name, s.semester_name) AS Avg_Courses_Enrolled\nFROM \n    Student_Enrolment AS se\nJOIN \n    Degree_Programs AS dp ON se.degree_program_id = dp.degree_program_id\nJOIN \n    Semesters AS s ON se.semester_id = s.semester_id\nJOIN \n    Student_Enrolment_Courses AS sec ON se.student_enrolment_id = sec.student_enrolment_id\nGROUP BY \n    dp.degree_summary_name, s.semester_name\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.X('Semester:O', title='Semester'),\n    alt.Y('Degree_Program:O', title='Degree Program')\n)\n\nheatmap = base.mark_rect().encode(\n    alt.Color('Avg_Courses_Enrolled:Q')\n        .scale(scheme='viridis')\n        .title(\"Average Courses Enrolled\")\n)\n\ncolor = (\n    alt.when(alt.datum.Avg_Courses_Enrolled > 5)\n    .then(alt.value(\"black\"))\n    .otherwise(alt.value(\"white\"))\n)\n\ntext = base.mark_text(baseline='middle').encode(\n    alt.Text('Avg_Courses_Enrolled:Q', format=\".1f\"), color=color\n)\n\nchart = heatmap + text\nchart.properties(title=\"Average Courses Enrolled by Degree Program and Semester\")",
        "reference_path": "./vis_bench/code/matplotlib/Tables___text_over_a_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "swimming",
        "chart_category": "Tables",
        "chart_type": "text_over_a_heatmap",
        "NLQ": "I like the heatmap visualization you showed me, but instead of car data, can you create one for swimming statistics? I want to see the average 100-meter swimming times for different countries. Put the countries along the x-axis and the average times on the y-axis. Use a blue-green color scheme (viridis) to show the differences in times, with the actual time values displayed on each cell. Make the text white on darker cells and black on lighter ones, based on whether the time is above or below average. Also, could you make the chart a bit larger, about 600 by 400 pixels? The data should come from our swimming database.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/swimming.sqlite')\n\nquery = '''\nSELECT Nationality, AVG(meter_100) AS avg_time\nFROM swimmer\nGROUP BY Nationality\nORDER BY avg_time DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.X('Nationality:O', title='Country'),\n    alt.Y('avg_time:Q', title='Average 100m Time (seconds)')\n)\n\nheatmap = base.mark_rect().encode(\n    alt.Color('avg_time:Q')\n        .scale(scheme='viridis')\n        .title(\"Average Time (s)\")\n)\n\ncolor = (\n    alt.when(alt.datum.avg_time > df['avg_time'].mean())\n    .then(alt.value(\"black\"))\n    .otherwise(alt.value(\"white\"))\n)\n\ntext = base.mark_text(baseline='middle').encode(\n    alt.Text('avg_time:Q', format=\".2f\"), color=color\n)\n\nchart = heatmap + text\nchart.properties(width=600, height=400)",
        "reference_path": "./vis_bench/code/altair/Tables___text_over_a_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "swimming",
        "chart_category": "Tables",
        "chart_type": "text_over_a_heatmap",
        "NLQ": "Instead of showing car horsepower data by origin and cylinders, I'd like to create a similar heatmap but for swimming data. Can you show the average 100m swimming times for different countries? I want the countries listed along the x-axis and their average times on the y-axis, with a color gradient to highlight the differences in performance. Make sure to display the actual time values on each cell, but format them to show two decimal places. Also, can you make the text color automatically adjust to be either black or white depending on the background color for better readability? Please make the chart wider and taller than the original example.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/swimming.sqlite')\n\nquery = '''\nSELECT Nationality, AVG(meter_100) AS avg_time\nFROM swimmer\nGROUP BY Nationality\nORDER BY avg_time DESC\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).encode(\n    alt.X('Nationality:O', title='Country'),\n    alt.Y('avg_time:Q', title='Average 100m Time (seconds)')\n)\n\nheatmap = base.mark_rect().encode(\n    alt.Color('avg_time:Q')\n        .scale(scheme='viridis')\n        .title(\"Average Time (s)\")\n)\n\ncolor = (\n    alt.when(alt.datum.avg_time > df['avg_time'].mean())\n    .then(alt.value(\"black\"))\n    .otherwise(alt.value(\"white\"))\n)\n\ntext = base.mark_text(baseline='middle').encode(\n    alt.Text('avg_time:Q', format=\".2f\"), color=color\n)\n\nchart = heatmap + text\nchart.properties(width=600, height=400)",
        "reference_path": "./vis_bench/code/matplotlib/Tables___text_over_a_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "swimming",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_grouped_bar_chart",
        "NLQ": "Instead of showing wheat production by year, can you create a bar chart that shows 100-meter swim times grouped by nationality? I want each swimmer's name to be shown in a different color, and I'd like to see their details when I hover over the bars. Please make the chart wider and taller, and add a title that says \"100-Meter Swim Times by Nationality\". The data should come from my swimming database instead of the random data we used before.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/swimming.sqlite')\n\nquery = '''\nSELECT name, Nationality, meter_100\nFROM swimmer\nORDER BY Nationality, meter_100 ASC\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='meter_100:Q',\n    y='Nationality:N',\n    color='name:N',\n    tooltip=['name', 'Nationality', 'meter_100']\n).properties(\n    width=600,\n    height=400,\n    title='100-Meter Swim Times by Nationality'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Bar Charts___horizontal_grouped_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "swimming",
        "chart_category": "Bar Charts",
        "chart_type": "horizontal_grouped_bar_chart",
        "NLQ": "Instead of showing wheat production by year in a horizontal bar chart, I'd like to create a chart that groups swimmers by their country and shows their 100-meter swim times. Can you make a horizontal bar chart where each bar represents a swimmer's time, grouped by nationality? I want each swimmer's name to be shown in different colors, and I'd like to add tooltips so people can see the swimmer's name, nationality and exact time when hovering over the bars. Please title it \"100-Meter Swim Times by Nationality\" and make it a good size so it's easy to read.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/swimming.sqlite')\nquery = '''\nSELECT name, Nationality, meter_100\nFROM swimmer\nORDER BY Nationality, meter_100 ASC\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='meter_100:Q',\n    y='Nationality:N',\n    color='name:N',\n    tooltip=['name', 'Nationality', 'meter_100']\n).properties(\n    width=600,\n    height=400,\n    title='100-Meter Swim Times by Nationality'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___horizontal_grouped_bar_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "tracking_grants_for_research",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "error_bars_with_confidence_interval",
        "NLQ": "Can you create a chart showing the average grant amounts for different types of organizations? I'd like to see error bars that show the range from minimum to maximum grant amount for each organization type, with a black dot marking the average amount. Please label the y-axis as \"Organisation Type\" and the x-axis as \"Grant Amount\". The data should come from our research grants database instead of the random data in the example.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/tracking_grants_for_research.sqlite')\n\nquery = '''\nSELECT\n    OT.organisation_type_description,\n    AVG(G.grant_amount) AS avg_grant_amount,\n    MIN(G.grant_amount) AS min_grant_amount,\n    MAX(G.grant_amount) AS max_grant_amount\nFROM Grants AS G\nJOIN Organisations AS O ON G.organisation_id = O.organisation_id\nJOIN Organisation_Types AS OT ON O.organisation_type = OT.organisation_type\nGROUP BY OT.organisation_type_description;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nerror_bars = alt.Chart(df).mark_errorbar().encode(\n    x=alt.X('min_grant_amount:Q', title='Grant Amount'),\n    x2='max_grant_amount:Q',\n    y=alt.Y('organisation_type_description:N', title='Organisation Type')\n)\n\npoints = alt.Chart(df).mark_point(filled=True, color='black').encode(\n    x=alt.X('avg_grant_amount:Q', title='Grant Amount'),\n    y=alt.Y('organisation_type_description:N', title='Organisation Type')\n)\n\nerror_bars + points",
        "reference_path": "./vis_bench/code/altair/Uncertainties And Trends___error_bars_with_confidence_interval.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "tracking_grants_for_research",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "error_bars_with_confidence_interval",
        "NLQ": "Can you create a chart that shows the average grant amounts for different types of organizations from our research grants database? I'd like to see the range between the minimum and maximum grant amounts for each organization type, with a point showing the average amount. Please use the organization type descriptions on the y-axis and the grant amounts on the x-axis. Make it look clean and professional, similar to the error bar style in my example code.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/tracking_grants_for_research.sqlite')\n\nquery = '''\nSELECT\n    OT.organisation_type_description,\n    AVG(G.grant_amount) AS avg_grant_amount,\n    MIN(G.grant_amount) AS min_grant_amount,\n    MAX(G.grant_amount) AS max_grant_amount\nFROM Grants AS G\nJOIN Organisations AS O ON G.organisation_id = O.organisation_id\nJOIN Organisation_Types AS OT ON O.organisation_type = OT.organisation_type\nGROUP BY OT.organisation_type_description;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nerror_bars = alt.Chart(df).mark_errorbar().encode(\n    x=alt.X('min_grant_amount:Q', title='Grant Amount'),\n    x2='max_grant_amount:Q',\n    y=alt.Y('organisation_type_description:N', title='Organisation Type')\n)\n\npoints = alt.Chart(df).mark_point(filled=True, color='black').encode(\n    x=alt.X('avg_grant_amount:Q', title='Grant Amount'),\n    y=alt.Y('organisation_type_description:N', title='Organisation Type')\n)\n\nerror_bars + points",
        "reference_path": "./vis_bench/code/matplotlib/Uncertainties And Trends___error_bars_with_confidence_interval.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "tracking_software_problems",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "error_bars_with_standard_deviation",
        "NLQ": "Instead of using the barley yield data, can you create a similar error bar chart using our problem tracking database? I want to see how many days it takes to close different problem categories. Keep the error bars to show the standard deviation for each category, but make the points black and filled. Also, please label the x-axis as \"Days to Close Problem\" and the y-axis as \"Problem Category\", and make sure the x-axis doesn't start at zero since that would distort the comparison.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/tracking_software_problems.sqlite')\n\nquery = '''\nSELECT\n    PCC.problem_category_description AS variety,\n    STRFTIME('%J', P.date_problem_closed) - STRFTIME('%J', P.date_problem_reported) AS yield\nFROM Problems AS P\nJOIN Problem_Log AS PL\n    ON P.problem_id = PL.problem_id\nJOIN Problem_Category_Codes AS PCC\n    ON PL.problem_category_code = PCC.problem_category_code\nWHERE\n    P.date_problem_closed IS NOT NULL AND P.date_problem_reported IS NOT NULL\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nerror_bars = alt.Chart(df).mark_errorbar(extent='stdev').encode(\n  x=alt.X('yield:Q', scale=alt.Scale(zero=False), title='Days to Close Problem'),\n  y=alt.Y('variety:N', title='Problem Category')\n)\n\npoints = alt.Chart(df).mark_point(filled=True, color='black').encode(\n  x=alt.X('mean(yield):Q', title='Days to Close Problem'),\n  y=alt.Y('variety:N'),\n)\n\nerror_bars + points",
        "reference_path": "./vis_bench/code/altair/Uncertainties And Trends___error_bars_with_standard_deviation.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "tracking_software_problems",
        "chart_category": "Uncertainties And Trends",
        "chart_type": "error_bars_with_standard_deviation",
        "NLQ": "Instead of using the barley yield data from my example, can you create a similar horizontal error bar chart but using our problem tracking database? I'd like to see how many days it takes to close different problem categories. Keep the black dots showing the mean values, but use the standard deviation to show the variation in closing times. Make sure the chart has proper titles for both axes - \"Problem Category\" on the y-axis and \"Days to Close Problem\" on the x-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/tracking_software_problems.sqlite')\n\nquery = '''\nSELECT\n    PCC.problem_category_description AS variety,\n    STRFTIME('%J', P.date_problem_closed) - STRFTIME('%J', P.date_problem_reported) AS yield\nFROM Problems AS P\nJOIN Problem_Log AS PL\n    ON P.problem_id = PL.problem_id\nJOIN Problem_Category_Codes AS PCC\n    ON PL.problem_category_code = PCC.problem_category_code\nWHERE\n    P.date_problem_closed IS NOT NULL AND P.date_problem_reported IS NOT NULL\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nerror_bars = alt.Chart(df).mark_errorbar(extent='stdev').encode(\n  x=alt.X('yield:Q', scale=alt.Scale(zero=False), title='Days to Close Problem'),\n  y=alt.Y('variety:N', title='Problem Category')\n)\n\npoints = alt.Chart(df).mark_point(filled=True, color='black').encode(\n  x=alt.X('mean(yield):Q', title='Days to Close Problem'),\n  y=alt.Y('variety:N'),\n)\n\nerror_bars + points",
        "reference_path": "./vis_bench/code/matplotlib/Uncertainties And Trends___error_bars_with_standard_deviation.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "workshop_paper",
        "chart_category": "Interactive Charts",
        "chart_type": "selection_histogram",
        "NLQ": "I want to create a chart that shows how many submissions were accepted or rejected for each workshop using my database. Can you make a bar chart where the workshops are on the x-axis and the count of submissions on the y-axis? I'd like to be able to select specific workshops and have another chart show the breakdown of acceptance results. Make sure to color-code the bars based on whether submissions were accepted or rejected, and when I select certain workshops, highlight those results while making the unselected ones light gray.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/workshop_paper.sqlite')\n\nquery = '''\nSELECT \n    w.Name AS Workshop_Name,\n    a.Result AS Acceptance_Result,\n    COUNT(*) AS Count\nFROM \n    Acceptance AS a\nJOIN \n    workshop AS w ON a.Workshop_ID = w.Workshop_ID\nGROUP BY \n    w.Name, a.Result\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbrush = alt.selection_interval()\n\npoints = alt.Chart(df).mark_bar().encode(\n    x='Workshop_Name:N',\n    y='Count:Q',\n    color=alt.condition(brush, 'Acceptance_Result:N', alt.value('lightgray'))\n).add_params(\n    brush\n)\n\nbars = alt.Chart(df).mark_bar().encode(\n    y='Acceptance_Result:N',\n    color='Acceptance_Result:N',\n    x='sum(Count):Q'\n).transform_filter(\n    brush\n)\n\npoints & bars",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___selection_histogram.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "world_1",
        "chart_category": "Interactive Charts",
        "chart_type": "simple_interactive_colored_scatter_plot",
        "NLQ": "Instead of using random data about cars, can you create a scatter plot using real data from a database that shows the relationship between population and GNP for different countries? I only want to include countries with populations over 10 million, and I'd like each continent to be shown in a different color. Also, make the chart interactive so I can explore the data better.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/world_1.sqlite')\n\nquery = '''\nSELECT \n    country.Population, \n    country.GNP, \n    country.Continent\nFROM \n    country\nWHERE \n    country.Population > 10000000\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    x='Population:Q',\n    y='GNP:Q',\n    color='Continent:N'\n).interactive()\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___simple_interactive_colored_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "assets_maintenance",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_text_overlay",
        "NLQ": "Can you create a stacked bar chart showing the total number of faults for each asset in our maintenance database? I'd like to see the different fault statuses color-coded for each asset, with the actual count numbers displayed on the bars in white text. Please add a title \"Fault Counts by Asset and Status\" and label the x-axis as \"Total Faults\" and the y-axis as \"Asset\". Also, make sure to include a legend that shows the different fault statuses.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/assets_maintenance.sqlite')\n\nquery = '''\nSELECT \n    A.asset_details AS asset,\n    FLP.fault_status AS status,\n    COUNT(FLP.fault_status) AS fault_count\nFROM \n    Fault_Log_Parts AS FLP\nJOIN \n    Fault_Log AS FL ON FLP.fault_log_entry_id = FL.fault_log_entry_id\nJOIN \n    Assets AS A ON FL.asset_id = A.asset_id\nGROUP BY \n    A.asset_details, FLP.fault_status\nORDER BY \n    A.asset_details, FLP.fault_status;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X('sum(fault_count):Q', stack='zero', title='Total Faults'),\n    y=alt.Y('asset:N', title='Asset'),\n    color=alt.Color('status:N', title='Fault Status')\n)\n\ntext = alt.Chart(df).mark_text(dx=-15, dy=3, color='white').encode(\n    x=alt.X('sum(fault_count):Q', stack='zero'),\n    y=alt.Y('asset:N'),\n    detail='status:N',\n    text=alt.Text('sum(fault_count):Q', format='.0f')\n)\n\nchart = bars + text\nchart.properties(title=\"Fault Counts by Asset and Status\")",
        "reference_path": "./vis_bench/code/altair/Bar Charts___stacked_bar_chart_with_text_overlay.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "assets_maintenance",
        "chart_category": "Bar Charts",
        "chart_type": "stacked_bar_chart_with_text_overlay",
        "NLQ": "Can you change my horizontal stacked bar chart to a vertical one that shows fault counts by asset instead of crop yields by variety? I need to pull data from our maintenance database instead of using random numbers. Please color-code the bars by fault status rather than site, add a proper title \"Fault Counts by Asset and Status\", and display the count numbers directly on the bars in white. Also, can we switch from matplotlib to Altair for this visualization?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/assets_maintenance.sqlite')\n\nquery = '''\nSELECT \n    A.asset_details AS asset,\n    FLP.fault_status AS status,\n    COUNT(FLP.fault_status) AS fault_count\nFROM \n    Fault_Log_Parts AS FLP\nJOIN \n    Fault_Log AS FL ON FLP.fault_log_entry_id = FL.fault_log_entry_id\nJOIN \n    Assets AS A ON FL.asset_id = A.asset_id\nGROUP BY \n    A.asset_details, FLP.fault_status\nORDER BY \n    A.asset_details, FLP.fault_status;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbars = alt.Chart(df).mark_bar().encode(\n    x=alt.X('sum(fault_count):Q', stack='zero', title='Total Faults'),\n    y=alt.Y('asset:N', title='Asset'),\n    color=alt.Color('status:N', title='Fault Status')\n)\n\ntext = alt.Chart(df).mark_text(dx=-15, dy=3, color='white').encode(\n    x=alt.X('sum(fault_count):Q', stack='zero'),\n    y=alt.Y('asset:N'),\n    detail='status:N',\n    text=alt.Text('sum(fault_count):Q', format='.0f')\n)\n\nchart = bars + text\nchart.properties(title=\"Fault Counts by Asset and Status\")",
        "reference_path": "./vis_bench/code/matplotlib/Bar Charts___stacked_bar_chart_with_text_overlay.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "assets_maintenance",
        "chart_category": "Interactive Charts",
        "chart_type": "using_selection_interval_with_mark_area",
        "NLQ": "Can you create a chart showing the total number of faults logged each month from our maintenance database? I'd like an area chart with a blue shaded area that I can click and drag to zoom in on specific time periods. Make sure to label the axes properly with \"Month\" on the x-axis and \"Total Faults Logged\" on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/assets_maintenance.sqlite')\n\nquery = '''\nSELECT \n    strftime('%Y-%m', fault_log_entry_datetime) AS month,\n    COUNT(fault_log_entry_id) AS total_faults\nFROM Fault_Log\nGROUP BY month\nORDER BY month\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).mark_area(\n    color='steelblue',\n    opacity=0.3\n).encode(\n    x=alt.X('month:T', title='Month'),\n    y=alt.Y('total_faults:Q', title='Total Faults Logged')\n)\n\nbrush = alt.selection_interval(encodings=['x'])\nbackground = base.add_params(brush)\nselected = base.transform_filter(brush).mark_area(color='steelblue')\n\nbackground + selected",
        "reference_path": "./vis_bench/code/altair/Interactive Charts___using_selection_interval_with_mark_area.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "body_builder",
        "chart_category": "Line Charts",
        "chart_type": "filled_step_chart",
        "NLQ": "Can you change my stock price chart to show bodybuilder data instead? I'd like to see the total weight lifted by each bodybuilder, ordered by their birth date. Keep the stepped pattern but make the area light blue. Also, change the x-axis to show bodybuilder names instead of dates, and label the y-axis as \"Total Weight Lifted\" instead of showing price.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/body_builder.sqlite')\nquery = '''\nSELECT p.Name, bb.Total, p.Birth_Date\nFROM body_builder AS bb\nJOIN people AS p ON bb.People_ID = p.People_ID\nORDER BY p.Birth_Date\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\nchart = alt.Chart(df).mark_area(\n    color=\"lightblue\",\n    interpolate='step-after',\n    line=True\n).encode(\n    x=alt.X('Name:N', title='Bodybuilder Name'),\n    y=alt.Y('Total:Q', title='Total Weight Lifted')\n)\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___filled_step_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "body_builder",
        "chart_category": "Line Charts",
        "chart_type": "filled_step_chart",
        "NLQ": "Can you change my stock price chart to show bodybuilder data instead? I'd like to see the total weight lifted by each bodybuilder, ordered by their birth date. Use a light blue area chart with stepped lines instead of the current style. Also, I want the x-axis to show the bodybuilders' names rather than dates, and the y-axis should be labeled \"Total Weight Lifted\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/body_builder.sqlite')\n\nquery = '''\nSELECT p.Name, bb.Total, p.Birth_Date\nFROM body_builder AS bb\nJOIN people AS p ON bb.People_ID = p.People_ID\nORDER BY p.Birth_Date\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_area(\n    color=\"lightblue\",\n    interpolate='step-after',\n    line=True\n).encode(\n    x=alt.X('Name:N', title='Bodybuilder Name'),\n    y=alt.Y('Total:Q', title='Total Weight Lifted')\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___filled_step_chart.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "climbing",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_cumulative_sum",
        "NLQ": "Can you create a chart showing the cumulative height of mountains as we go through each Mountain_ID? I need to pull this data from my climbing database instead of using the wheat production data. Make the chart wider (about 600 pixels) and use a simple line without points. I don't need any special axis formatting, just show the Mountain_ID on the x-axis and the running total of heights on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/climbing.sqlite')\n\nquery = '''\nSELECT Mountain_ID, Height\nFROM mountain\nORDER BY Mountain_ID;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, width=600).mark_line().transform_window(\n    sort=[{'field': 'Mountain_ID'}],\n    frame=[None, 0],\n    cumulative_height='sum(Height)'\n).encode(\n    x='Mountain_ID:O',\n    y='cumulative_height:Q'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_cumulative_sum.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "climbing",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_cumulative_sum",
        "NLQ": "Can you create a chart showing the cumulative height of mountains as we go through each mountain ID? I want to see how the total height increases with each mountain added. Instead of using the wheat production data from my previous chart, please use data from the climbing database, specifically the mountain table with Mountain_ID and Height columns. Make it a clean line chart without the markers, and use Altair instead of matplotlib.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/climbing.sqlite')\nquery = '''\nSELECT Mountain_ID, Height\nFROM mountain\nORDER BY Mountain_ID;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df, width=600).mark_line().transform_window(\n    sort=[{'field': 'Mountain_ID'}],\n    frame=[None, 0],\n    cumulative_height='sum(Height)'\n).encode(\n    x='Mountain_ID:O',\n    y='cumulative_height:Q'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_cumulative_sum.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "company_1",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_custom_order",
        "NLQ": "Could you change this chart to show data from our company database instead? I need to see the total hours worked on each project, with the projects ordered by their project numbers. Keep the line chart with points, but make sure the x-axis shows project numbers and the y-axis shows total hours worked. Also, when I hover over a point, I'd like to see the project name, total hours, and project number.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_1.sqlite')\n\nquery = '''\nSELECT \n    p.Pname AS Project_Name,\n    p.Pnumber AS Project_Number,\n    SUM(w.Hours) AS Total_Hours\nFROM \n    works_on AS w\nJOIN \n    project AS p ON w.Pno = p.Pnumber\nGROUP BY \n    p.Pnumber, p.Pname\nORDER BY \n    p.Pnumber\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line(point=True).encode(\n    x=alt.X(\"Project_Number:O\").title(\"Project Number\"),\n    y=alt.Y(\"Total_Hours:Q\").title(\"Total Hours Worked\"),\n    order=\"Project_Number\",\n    tooltip=[\"Project_Name\", \"Total_Hours\", \"Project_Number\"]\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_custom_order.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "company_1",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_custom_order",
        "NLQ": "Instead of plotting gas consumption against miles, could you create a chart that shows the total hours worked on each project? I'd like to see the data from our company database, with project numbers on the x-axis and total hours worked on the y-axis. Please connect the data points with lines and make it interactive so I can hover over points to see the project name, project number, and total hours worked. Also, can you order the projects by their project number?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_1.sqlite')\nquery = '''\nSELECT \n    p.Pname AS Project_Name,\n    p.Pnumber AS Project_Number,\n    SUM(w.Hours) AS Total_Hours\nFROM \n    works_on AS w\nJOIN \n    project AS p ON w.Pno = p.Pnumber\nGROUP BY \n    p.Pnumber, p.Pname\nORDER BY \n    p.Pnumber\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line(point=True).encode(\n    x=alt.X(\"Project_Number:O\").title(\"Project Number\"),\n    y=alt.Y(\"Total_Hours:Q\").title(\"Total Hours Worked\"),\n    order=\"Project_Number\",\n    tooltip=[\"Project_Name\", \"Total_Hours\", \"Project_Number\"]\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_custom_order.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "company_office",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_datum",
        "NLQ": "Could you make a graph that shows how many companies move into buildings each year, using data from our company_office database? I'd like to see a line chart with years on the x-axis and the number of companies on the y-axis. Please include a dashed horizontal line showing the average number of companies per year, and add a vertical cyan line marking the year 2022. Also, can you add tooltips so when I hover over points I can see the exact year and number of companies?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_office.sqlite')\n\nquery = '''\nSELECT \n    move_in_year AS Year, \n    COUNT(company_id) AS Company_Count\nFROM Office_locations\nGROUP BY move_in_year\nORDER BY move_in_year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\naverage_companies = df['Company_Count'].mean()\n\nlines = (\n    alt.Chart(df)\n    .mark_line()\n    .encode(\n        x=alt.X(\"Year:O\", title=\"Year\"),\n        y=alt.Y(\"Company_Count:Q\", title=\"Number of Companies\"),\n        tooltip=[\"Year\", \"Company_Count\"]\n    )\n)\n\nxrule = (\n    alt.Chart().mark_rule(color=\"cyan\", strokeWidth=2)\n    .encode(x=alt.datum(2022))\n)\n\nyrule = (\n    alt.Chart().mark_rule(strokeDash=[12, 6], size=2)\n    .encode(y=alt.datum(average_companies))\n)\n\nchart = lines + xrule + yrule\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_datum.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "company_office",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_datum",
        "NLQ": "Could you create a line chart showing how many companies move into buildings each year? I need to pull this data from our company_office database. Please include a dashed horizontal line showing the average number of companies per year, and add a vertical cyan line marking the year 2022. I'd also like to be able to hover over the points to see the exact year and number of companies.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/company_office.sqlite')\n\nquery = '''\nSELECT \n    move_in_year AS Year, \n    COUNT(company_id) AS Company_Count\nFROM Office_locations\nGROUP BY move_in_year\nORDER BY move_in_year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\naverage_companies = df['Company_Count'].mean()\n\nlines = (\n    alt.Chart(df)\n    .mark_line()\n    .encode(\n        x=alt.X(\"Year:O\", title=\"Year\"),\n        y=alt.Y(\"Company_Count:Q\", title=\"Number of Companies\"),\n        tooltip=[\"Year\", \"Company_Count\"]\n    )\n)\n\nxrule = (\n    alt.Chart().mark_rule(color=\"cyan\", strokeWidth=2)\n    .encode(x=alt.datum(2022))\n)\n\nyrule = (\n    alt.Chart().mark_rule(strokeDash=[12, 6], size=2)\n    .encode(y=alt.datum(average_companies))\n)\n\nchart = lines + xrule + yrule\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_datum.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "course_teach",
        "chart_category": "Distributions",
        "chart_type": "2d_histogram_heatmap",
        "NLQ": "Instead of showing the relationship between IMDB and Rotten Tomatoes ratings, could you create a similar heatmap that shows how teacher ages relate to course grades? I'd like to use data from our course database and display it with a green-blue color scheme to highlight patterns between teacher ages and the grades they teach.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/course_teach.sqlite')\nquery = '''\nSELECT T1.Grade AS Grade, T3.Age AS Age\nFROM course_arrange AS T1\nJOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_rect().encode(\n    alt.X('Grade:Q').bin(maxbins=10),\n    alt.Y('Age:Q').bin(maxbins=10),\n    alt.Color('count():Q').scale(scheme='greenblue')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___2d_histogram_heatmap.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "course_teach",
        "chart_category": "Distributions",
        "chart_type": "2d_histogram_heatmap",
        "NLQ": "Instead of using the movie ratings data with IMDB and Rotten Tomatoes, could you create a similar heatmap but showing the relationship between teacher ages and course grades? I'd like to pull this data from our course database rather than using random numbers. Also, can you use shades of green and blue for the color scheme instead of the default colors? Make sure to bin both the ages and grades appropriately to show the patterns clearly.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/course_teach.sqlite')\n\nquery = '''\nSELECT T1.Grade AS Grade, T3.Age AS Age\nFROM course_arrange AS T1\nJOIN teacher AS T3 ON T1.Teacher_ID = T3.Teacher_ID\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_rect().encode(\n    alt.X('Grade:Q').bin(maxbins=10),\n    alt.Y('Age:Q').bin(maxbins=10),\n    alt.Color('count():Q').scale(scheme='greenblue')\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___2d_histogram_heatmap.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "course_teach",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_datum_for_color",
        "NLQ": "Can you change my chart to use data from our course database instead of random data? I'd like to see how course IDs relate to teacher IDs and grades. Keep the binned x-axis but simplify the chart by removing the points on the lines. Also, could you add a proper y-axis title that says \"Mean of US and Worldwide Gross\" and use a different way to color the lines that doesn't need a legend?",
        "code": "import altair as alt\nfrom vega_datasets import data\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/course_teach.sqlite')\nquery = '''\nSELECT C.Course_ID as IMDB_Rating, T.Teacher_ID as US_Gross, CA.Grade as Worldwide_Gross\nFROM Course AS C\nJOIN course_arrange AS CA ON C.Course_ID = CA.Course_ID\nJOIN Teacher AS T ON CA.Teacher_ID = T.Teacher_ID;\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nalt.Chart(df).mark_line().encode(\n    alt.X(\"IMDB_Rating\").bin(True),\n    alt.Y(alt.repeat(\"layer\"))\n        .aggregate(\"mean\")\n        .title(\"Mean of US and Worldwide Gross\"),\n    color=alt.datum(alt.repeat(\"layer\")),\n).repeat(\n    layer=[\"US_Gross\", \"Worldwide_Gross\"]\n)",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_datum_for_color.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "course_teach",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_datum_for_color",
        "NLQ": "Can you change my matplotlib chart to use Altair instead? I need to pull data from my course_teach SQLite database rather than using random numbers. Keep the same basic idea of showing two lines comparing ratings and performance, but use binning on the x-axis and make sure each line has its own color. I still want to show the mean values for US_Gross and Worldwide_Gross based on IMDB_Rating bins.",
        "code": "import altair as alt\nfrom vega_datasets import data\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('database/course_teach.sqlite')\n\nquery = '''\nSELECT C.Course_ID as IMDB_Rating, T.Teacher_ID as US_Gross, CA.Grade as Worldwide_Gross\nFROM Course AS C\nJOIN course_arrange AS CA ON C.Course_ID = CA.Course_ID\nJOIN Teacher AS T ON CA.Teacher_ID = T.Teacher_ID;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nalt.Chart(df).mark_line().encode(\n    alt.X(\"IMDB_Rating\").bin(True),\n    alt.Y(alt.repeat(\"layer\"))\n        .aggregate(\"mean\")\n        .title(\"Mean of US and Worldwide Gross\"),\n    color=alt.datum(alt.repeat(\"layer\")),\n).repeat(\n    layer=[\"US_Gross\", \"Worldwide_Gross\"]\n)",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_datum_for_color.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "cre_Doc_Control_Systems",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_datum_for_color",
        "NLQ": "Can you create a line chart that shows how the average number of drafts changes over the years for different types of documents? I need to pull this data from our document control database instead of using random data. I want to see the year on the x-axis and the average number of drafts on the y-axis, with different colors for each document type. Make sure to label the axes clearly so it's easy to understand what we're looking at.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/cre_Doc_Control_Systems.sqlite')\n\nquery = '''\nSELECT \n    T1.document_type_code,\n    strftime('%Y', T2.receipt_date) AS year,\n    COUNT(T3.draft_number) AS draft_count\nFROM \n    Documents AS T2\nJOIN \n    Ref_Document_Types AS T1 ON T2.document_type_code = T1.document_type_code\nLEFT JOIN \n    Document_Drafts AS T3 ON T2.document_id = T3.document_id\nGROUP BY \n    T1.document_type_code, year\nORDER BY \n    year ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_line().encode(\n    alt.X(\"year:N\", title=\"Year\"),\n    alt.Y(\"mean(draft_count):Q\", title=\"Average Number of Drafts\"),\n    color=alt.datum(\"document_type_code:N\")\n).repeat(\n    layer=[\"document_type_code\"]\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Line Charts___line_chart_with_datum_for_color.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "cre_Doc_Control_Systems",
        "chart_category": "Line Charts",
        "chart_type": "line_chart_with_datum_for_color",
        "NLQ": "Can you change this chart to show how the average number of drafts changes over the years for different types of documents? Instead of using random data, I'd like to pull real information from our document control database. I need to see the trends by year for each document type, with different colors for each document type. Please put years on the x-axis and the average number of drafts on the y-axis. Can you make it a line chart that's easy to read?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/cre_Doc_Control_Systems.sqlite')\n\nquery = '''\nSELECT \n    T1.document_type_code,\n    strftime('%Y', T2.receipt_date) AS year,\n    COUNT(T3.draft_number) AS draft_count\nFROM \n    Documents AS T2\nJOIN \n    Ref_Document_Types AS T1 ON T2.document_type_code = T1.document_type_code\nLEFT JOIN \n    Document_Drafts AS T3 ON T2.document_id = T3.document_id\nGROUP BY \n    T1.document_type_code, year\nORDER BY \n    year ASC;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_line().encode(\n    alt.X(\"year:N\", title=\"Year\"),\n    alt.Y(\"mean(draft_count):Q\", title=\"Average Number of Drafts\"),\n    color=alt.datum(\"document_type_code:N\")\n).repeat(\n    layer=[\"document_type_code\"]\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Line Charts___line_chart_with_datum_for_color.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "cre_Doc_Control_Systems",
        "chart_category": "Distributions",
        "chart_type": "2d_histogram_scatter_plot",
        "NLQ": "Instead of using random data about movie ratings, can you create a scatter plot that shows how many drafts were made each year for documents in our database? I'd like to see receipt years on the x-axis and number of drafts on the y-axis, with the size of the bubbles showing how many documents fall into each category. Please pull this information from our SQLite database called 'cre_Doc_Control_Systems.sqlite' by joining the Documents and Document_Drafts tables. Make sure to label the axes properly as \"Receipt Year\" and \"Number of Drafts\".",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/cre_Doc_Control_Systems.sqlite')\n\nquery = '''\nSELECT \n    strftime('%Y', T1.receipt_date) AS receipt_year,\n    COUNT(T2.draft_number) AS draft_count\nFROM \n    Documents AS T1\nJOIN \n    Document_Drafts AS T2 ON T1.document_id = T2.document_id\nGROUP BY \n    receipt_year, T1.document_id\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    alt.X('receipt_year:N').title('Receipt Year'),\n    alt.Y('draft_count:Q').bin().title('Number of Drafts'),\n    size='count()'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___2d_histogram_scatter_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "cre_Doc_Control_Systems",
        "chart_category": "Distributions",
        "chart_type": "2d_histogram_scatter_plot",
        "NLQ": "Instead of using random data, can you create a bubble chart that shows how many drafts were made for documents each year? I need to pull this information from our SQLite database called 'cre_Doc_Control_Systems'. The x-axis should show the receipt year, the y-axis should show the number of drafts, and the size of the bubbles should represent how many documents fall into each category. Please use Altair instead of matplotlib for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/cre_Doc_Control_Systems.sqlite')\n\nquery = '''\nSELECT \n    strftime('%Y', T1.receipt_date) AS receipt_year,\n    COUNT(T2.draft_number) AS draft_count\nFROM \n    Documents AS T1\nJOIN \n    Document_Drafts AS T2 ON T1.document_id = T2.document_id\nGROUP BY \n    receipt_year, T1.document_id\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    alt.X('receipt_year:N').title('Receipt Year'),\n    alt.Y('draft_count:Q').bin().title('Number of Drafts'),\n    size='count()'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___2d_histogram_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "cre_Doc_Template_Mgt",
        "chart_category": "Distributions",
        "chart_type": "2d_histogram_scatter_plot",
        "NLQ": "Instead of using random data for movie ratings, can you create a bubble chart that shows how many paragraphs are linked to each effective date from our document management database? I'd like to pull this information from our SQLite database and group both the dates and paragraph counts into bins. The size of each bubble should represent how many items fall into each bin. Keep the same circle mark style as my original chart.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/cre_Doc_Template_Mgt.sqlite')\n\nquery = '''\nSELECT \n    T.Date_Effective_From AS Effective_Date,\n    COUNT(P.Paragraph_ID) AS Paragraph_Count\nFROM Templates AS T\nJOIN Documents AS D ON T.Template_ID = D.Template_ID\nJOIN Paragraphs AS P ON D.Document_ID = P.Document_ID\nGROUP BY T.Date_Effective_From\nORDER BY T.Date_Effective_From;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    alt.X('Effective_Date:T').bin(),\n    alt.Y('Paragraph_Count:Q').bin(),\n    size='count()'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/altair/Distributions___2d_histogram_scatter_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "cre_Doc_Template_Mgt",
        "chart_category": "Distributions",
        "chart_type": "2d_histogram_scatter_plot",
        "NLQ": "Can you change my visualization to show real data from our document template database instead of random numbers? I'd like to see how many paragraphs are associated with different effective dates. Please create a bubble chart where the x-axis shows the effective dates grouped into bins, the y-axis shows paragraph counts also in bins, and the size of each bubble represents how many items fall into each group. I want to switch from matplotlib to Altair for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/cre_Doc_Template_Mgt.sqlite')\n\nquery = '''\nSELECT \n    T.Date_Effective_From AS Effective_Date,\n    COUNT(P.Paragraph_ID) AS Paragraph_Count\nFROM Templates AS T\nJOIN Documents AS D ON T.Template_ID = D.Template_ID\nJOIN Paragraphs AS P ON D.Document_ID = P.Document_ID\nGROUP BY T.Date_Effective_From\nORDER BY T.Date_Effective_From;\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_circle().encode(\n    alt.X('Effective_Date:T').bin(),\n    alt.Y('Paragraph_Count:Q').bin(),\n    size='count()'\n)\n\nchart.show()",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___2d_histogram_scatter_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "customers_and_products_contacts",
        "chart_category": "Distributions",
        "chart_type": "distributions_and_medians_of_likert_scale_ratings",
        "NLQ": "Can you create a chart showing how product prices are distributed across different product types? I'd like to see blue circles representing the price ranges with bigger circles showing more products in that range. Add black lines for the median values and labels on the sides showing \"Low Range\" and \"High Range\". Please title it \"Product Price Range Distribution by Product Type\" and include tooltips that show the number of products when I hover over the circles. Can you pull this data from our customer database?",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/customers_and_products_contacts.sqlite')\n\nquery = \"\"\"\nSELECT\n    product_type_code,\n    CASE\n        WHEN product_price < 10000 THEN 1\n        WHEN product_price < 100000 THEN 2\n        WHEN product_price < 1000000 THEN 3\n        WHEN product_price < 10000000 THEN 4\n        ELSE 5\n    END AS price_range_rating\nFROM Products;\n\"\"\"\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nmedians_df = df.groupby('product_type_code')['price_range_rating'].median().reset_index()\nmedians_df.rename(columns={'product_type_code': 'name', 'price_range_rating': 'median'}, inplace=True)\nmedians_df['lo'] = 'Low Range'\nmedians_df['hi'] = 'High Range'\n\nvalues_df = pd.DataFrame()\nfor index, row in df.iterrows():\n    values_df = pd.concat([values_df, pd.DataFrame([{'name': row['product_type_code'], 'value': row['price_range_rating']}])])\n\ny_axis = alt.Y(\"name\").axis(\n    title=None,\n    offset=50,\n    labelFontWeight=\"bold\",\n    ticks=False,\n    grid=True,\n    domain=False,\n)\n\nbase = alt.Chart(\n    medians_df,\n).encode(y_axis)\n\nbubbles = (\n    alt.Chart(values_df)\n    .mark_circle(color=\"#6EB4FD\")\n    .encode(\n        alt.X(\n            \"value:Q\",\n        ).title(None),\n        y_axis,\n        alt.Size(\"count()\").legend(offset=75, title=\"Number of products\"),\n        tooltip=[alt.Tooltip(\"count()\").title(\"Number of products\")],\n    )\n)\n\nticks = base.mark_tick(color=\"black\").encode(\n    alt.X(\"median:Q\")\n    .axis(grid=False, values=[1, 2, 3, 4, 5], format=\".0f\")\n    .scale(domain=[0, 6]),\n)\n\ntexts_lo = base.mark_text(align=\"right\", x=-5).encode(text=\"lo\")\n\ntexts_hi = base.mark_text(align=\"left\", x=255).encode(text=\"hi\")\n\nchart = (bubbles + ticks + texts_lo + texts_hi).properties(\n    title=\"Product Price Range Distribution by Product Type\", width=300, height=200\n).configure_view(stroke=None)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___distributions_and_medians_of_likert_scale_ratings.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "customers_and_products_contacts",
        "chart_category": "Distributions",
        "chart_type": "distributions_and_medians_of_likert_scale_ratings",
        "NLQ": "Can you create a chart showing how product prices are distributed across different product types from our customer database? I'd like to see the price ranges categorized from 1-5, with blue bubbles showing how many products fall into each price range. Please include black lines to mark the median price for each product type, and add labels on the sides showing \"Low Range\" and \"High Range\". Also, add a title \"Product Price Range Distribution by Product Type\" and include a tooltip that shows the number of products when hovering over the bubbles.",
        "code": "import altair as alt\nimport pandas as pd\nimport sqlite3\n\nconn = sqlite3.connect('database/customers_and_products_contacts.sqlite')\n\nquery = \"\"\"\nSELECT\n    product_type_code,\n    CASE\n        WHEN product_price < 10000 THEN 1\n        WHEN product_price < 100000 THEN 2\n        WHEN product_price < 1000000 THEN 3\n        WHEN product_price < 10000000 THEN 4\n        ELSE 5\n    END AS price_range_rating\nFROM Products;\n\"\"\"\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nmedians_df = df.groupby('product_type_code')['price_range_rating'].median().reset_index()\nmedians_df.rename(columns={'product_type_code': 'name', 'price_range_rating': 'median'}, inplace=True)\nmedians_df['lo'] = 'Low Range'\nmedians_df['hi'] = 'High Range'\n\nvalues_df = pd.DataFrame()\nfor index, row in df.iterrows():\n    values_df = pd.concat([values_df, pd.DataFrame([{'name': row['product_type_code'], 'value': row['price_range_rating']}])])\n\ny_axis = alt.Y(\"name\").axis(\n    title=None,\n    offset=50,\n    labelFontWeight=\"bold\",\n    ticks=False,\n    grid=True,\n    domain=False,\n)\n\nbase = alt.Chart(\n    medians_df,\n).encode(y_axis)\n\nbubbles = (\n    alt.Chart(values_df)\n    .mark_circle(color=\"#6EB4FD\")\n    .encode(\n        alt.X(\n            \"value:Q\",\n        ).title(None),\n        y_axis,\n        alt.Size(\"count()\").legend(offset=75, title=\"Number of products\"),\n        tooltip=[alt.Tooltip(\"count()\").title(\"Number of products\")],\n    )\n)\n\nticks = base.mark_tick(color=\"black\").encode(\n    alt.X(\"median:Q\")\n    .axis(grid=False, values=[1, 2, 3, 4, 5], format=\".0f\")\n    .scale(domain=[0, 6]),\n)\n\ntexts_lo = base.mark_text(align=\"right\", x=-5).encode(text=\"lo\")\n\ntexts_hi = base.mark_text(align=\"left\", x=255).encode(text=\"hi\")\n\nchart = (bubbles + ticks + texts_lo + texts_hi).properties(\n    title=\"Product Price Range Distribution by Product Type\", width=300, height=200\n).configure_view(stroke=None)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___distributions_and_medians_of_likert_scale_ratings.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "game_1",
        "chart_category": "Distributions",
        "chart_type": "quantile-quantile_plot",
        "NLQ": "Can you create a quantile-quantile plot to compare the distribution of hours played by students? I want to see if there's a difference between students who are on scholarship versus those who aren't. Please label the y-axis as \"Hours Played\" and organize the charts side by side with labels showing which group is on scholarship and which isn't.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/game_1.sqlite')\n\nquery = '''\nSELECT \n    S.OnScholarship,\n    PG.Hours_Played\nFROM \n    Plays_Games AS PG\nJOIN \n    SportsInfo AS S ON PG.StuID = S.StuID\nWHERE \n    S.OnScholarship IN ('Y', 'N')\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).transform_quantile(\n    'Hours_Played',\n    step=0.01,\n    as_=['p', 'v']\n).transform_calculate(\n    uniform='quantileUniform(datum.p)',\n    normal='quantileNormal(datum.p)'\n).mark_point().encode(\n    alt.Y('v:Q', title='Hours Played')\n)\n\nchart = base.encode(x='uniform:Q').facet(\n    column=alt.Column('OnScholarship:N', title='On Scholarship')\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Distributions___quantile-quantile_plot.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "game_1",
        "chart_category": "Distributions",
        "chart_type": "quantile-quantile_plot",
        "NLQ": "Can you create a quantile-quantile plot to compare the distribution of hours played by students who are on scholarships versus those who aren't? I need to pull this data from our game database instead of using random numbers. Please put the scholarship status in separate columns side by side, and label the y-axis as \"Hours Played\" so it's clear what we're measuring.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/game_1.sqlite')\n\nquery = '''\nSELECT \n    S.OnScholarship,\n    PG.Hours_Played\nFROM \n    Plays_Games AS PG\nJOIN \n    SportsInfo AS S ON PG.StuID = S.StuID\nWHERE \n    S.OnScholarship IN ('Y', 'N')\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nbase = alt.Chart(df).transform_quantile(\n    'Hours_Played',\n    step=0.01,\n    as_=['p', 'v']\n).transform_calculate(\n    uniform='quantileUniform(datum.p)',\n    normal='quantileNormal(datum.p)'\n).mark_point().encode(\n    alt.Y('v:Q', title='Hours Played')\n)\n\nchart = base.encode(x='uniform:Q').facet(\n    column=alt.Column('OnScholarship:N', title='On Scholarship')\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Distributions___quantile-quantile_plot.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "performance_attendance",
        "chart_category": "Scatter Plots",
        "chart_type": "simple_scatter_plot_with_labels",
        "NLQ": "Instead of using my sample data with x and y coordinates, can you create a scatter plot that shows attendance numbers for different performance locations? I'd like to pull this data from my SQLite database called 'performance_attendance.sqlite'. Put the attendance numbers on the x-axis and the location names on the y-axis. Also, instead of putting the location labels directly on top of the points, can you position them slightly to the right of each point so they're easier to read?",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/performance_attendance.sqlite')\n\nquery = '''\nSELECT Location, Attendance\nFROM performance\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\npoints = alt.Chart(df).mark_point().encode(\n    x='Attendance:Q',\n    y='Location:N'\n)\n\ntext = points.mark_text(\n    align='left',\n    baseline='middle',\n    dx=7\n).encode(\n    text='Location:N'\n)\n\npoints + text",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___simple_scatter_plot_with_labels.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "performance_attendance",
        "chart_category": "Scatter Plots",
        "chart_type": "simple_scatter_plot_with_labels",
        "NLQ": "Instead of using my sample data with x and y points, can you create a scatter plot that shows attendance numbers for different performance locations? I need to pull this data from my SQLite database called 'performance_attendance.sqlite'. Please put the attendance numbers on the x-axis and the location names on the y-axis. Also, add text labels next to each point showing the location name. I'd prefer to use Altair instead of Matplotlib for this visualization.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/performance_attendance.sqlite')\n\nquery = '''\nSELECT Location, Attendance\nFROM performance\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\npoints = alt.Chart(df).mark_point().encode(\n    x='Attendance:Q',\n    y='Location:N'\n)\n\ntext = points.mark_text(\n    align='left',\n    baseline='middle',\n    dx=7\n).encode(\n    text='Location:N'\n)\n\npoints + text",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___simple_scatter_plot_with_labels.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "perpetrator",
        "chart_category": "Scatter Plots",
        "chart_type": "simple_scatter_plot_with_labels",
        "NLQ": "Could you create a scatter plot using my database of perpetrator information? I want to see the relationship between the number of people killed on the x-axis and the number injured on the y-axis. Each point should represent a location, and I'd like to see the location name as a label next to each point instead of directly on top of it. Make sure the labels are aligned to the left of each point so they're easier to read.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/perpetrator.sqlite')\n\nquery = '''\nSELECT Location, Killed, Injured\nFROM perpetrator\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\npoints = alt.Chart(df).mark_point().encode(\n    x='Killed:Q',\n    y='Injured:Q'\n)\n\ntext = points.mark_text(\n    align='left',\n    baseline='middle',\n    dx=7\n).encode(\n    text='Location'\n)\n\nchart = points + text\nchart",
        "reference_path": "./vis_bench/code/altair/Scatter Plots___simple_scatter_plot_with_labels.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "perpetrator",
        "chart_category": "Scatter Plots",
        "chart_type": "simple_scatter_plot_with_labels",
        "NLQ": "Could you create a scatter plot showing the relationship between the number of people killed and injured in different locations? I need to pull this data from my SQLite database called 'perpetrator.sqlite' instead of using the sample data in my current chart. Please keep the text labels next to each point showing the location name, but make them appear slightly to the right of each point for better readability. I'd prefer to use Altair for this visualization instead of Matplotlib.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/perpetrator.sqlite')\nquery = '''\nSELECT Location, Killed, Injured\nFROM perpetrator\n'''\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\npoints = alt.Chart(df).mark_point().encode(\n    x='Killed:Q',\n    y='Injured:Q'\n)\n\ntext = points.mark_text(\n    align='left',\n    baseline='middle',\n    dx=7\n).encode(\n    text='Location'\n)\n\nchart = points + text\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Scatter Plots___simple_scatter_plot_with_labels.py"
    },
    {
        "type": "type_C_altair",
        "db_id": "pilot_record",
        "chart_category": "Simple Charts",
        "chart_type": "simple_bar_chart",
        "NLQ": "Instead of using the sample data in my code, can you create a bar chart that shows how many flights happened each year? I need to pull this information from my pilot_record database, where I want to count the total number of flights grouped by year. The years should be on the x-axis and the flight counts on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/pilot_record.sqlite')\n\nquery = '''\nSELECT \n    SUBSTR(Date, 1, 4) AS Year,\n    COUNT(*) AS Total_Flights\nFROM pilot_record\nGROUP BY Year\nORDER BY Year\n'''\n\ndf = pd.read_sql_query(query, conn)\n\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Year:N',\n    y='Total_Flights:Q'\n)\n\nchart",
        "reference_path": "./vis_bench/code/altair/Simple Charts___simple_bar_chart.py"
    },
    {
        "type": "type_C_matplotlib",
        "db_id": "pilot_record",
        "chart_category": "Simple Charts",
        "chart_type": "simple_bar_chart",
        "NLQ": "I want to create a bar chart that shows how many flights happened each year. Instead of using the sample data in the example, can you pull the real flight data from my SQLite database? I need to count the total number of flights grouped by year from my pilot_record table. Also, can you use Altair instead of Matplotlib for the visualization? I'd like to keep it simple with years on the x-axis and flight counts on the y-axis.",
        "code": "import sqlite3\nimport pandas as pd\nimport altair as alt\n\nconn = sqlite3.connect('database/pilot_record.sqlite')\n\nquery = '''\nSELECT \n    SUBSTR(Date, 1, 4) AS Year,\n    COUNT(*) AS Total_Flights\nFROM pilot_record\nGROUP BY Year\nORDER BY Year\n'''\n\ndf = pd.read_sql_query(query, conn)\nconn.close()\n\nchart = alt.Chart(df).mark_bar().encode(\n    x='Year:N',\n    y='Total_Flights:Q'\n)\n\nchart",
        "reference_path": "./vis_bench/code/matplotlib/Simple Charts___simple_bar_chart.py"
    }
]